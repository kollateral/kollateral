{
  "language": "Solidity",
  "sources": {
    "contracts/__oz__/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n\t/**\n\t * @dev Returns the largest of two numbers.\n\t */\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a >= b ? a : b;\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\t/**\n\t * @dev Returns the average of two numbers. The result is rounded towards\n\t * zero.\n\t */\n\tfunction average(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// (a + b) / 2 can overflow, so we distribute\n\t\treturn (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n\t}\n}\n"
    },
    "contracts/common/utils/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.8.2;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n\t/**\n\t * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n\t * given `owner`'s signed approval.\n\t *\n\t * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n\t * ordering also apply here.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be `address(0)`.\n\t * - `spender` cannot be `address(0)`.\n\t * - `deadline` must be a timestamp in the future.\n\t * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n\t * over the EIP712-formatted function arguments.\n\t * - the signature must use `owner`'s current nonce (see {nonces}).\n\t *\n\t * For more information on the signature format, see the\n\t * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n\t * section].\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n\t * included whenever a signature is generated for {permit}.\n\t *\n\t * Every successful call to {permit} increases `owner`'s nonce by one. This\n\t * prevents a signature from being used multiple times.\n\t */\n\tfunction nonces(address owner) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by EIP712.\n\t */\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/common/utils/IWETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2021\npragma solidity 0.8.2;\n\nimport \"./IERC2612.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"../../interfaces/token/ERC20/IERC20.sol\";\n\n/// @dev Wrapped Ether v10 (WETH10) is an Ether (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance which can then be operated as an ERC-20 token. You can\n/// `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet. The amount of WETH10 token in any wallet is always identical to the\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\ninterface IWETH10 is IERC20, IERC2612, IERC3156FlashLender {\n\t/// @dev Returns current amount of flash-minted WETH10 token.\n\tfunction flashMinted() external view returns (uint256);\n\n\t/// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\n\t/// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\n\tfunction deposit() external payable;\n\n\t/// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\n\t/// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\n\tfunction depositTo(address to) external payable;\n\n\t/// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\n\t/// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\n\t/// Requirements:\n\t///   - caller account must have at least `value` balance of WETH10 token.\n\tfunction withdraw(uint256 value) external;\n\n\t/// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\n\t/// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\n\t/// Requirements:\n\t///   - caller account must have at least `value` balance of WETH10 token.\n\tfunction withdrawTo(address payable to, uint256 value) external;\n\n\t/// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\n\t/// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n\t/// unless allowance is set to `type(uint256).max`\n\t/// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\n\t/// Requirements:\n\t///   - `from` account must have at least `value` balance of WETH10 token.\n\t///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n\tfunction withdrawFrom(\n\t\taddress from,\n\t\taddress payable to,\n\t\tuint256 value\n\t) external;\n\n\t/// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\n\t/// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n\t/// Emits {Transfer} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\n\tfunction depositToAndCall(address to, bytes calldata data) external payable returns (bool);\n\n\t/// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\n\t/// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n\t/// Emits {Approval} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\n\tfunction approveAndCall(\n\t\taddress spender,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external returns (bool);\n\n\t/// @dev Moves `value` WETH10 token from caller's account to account (`to`),\n\t/// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n\t/// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\n\t/// Emits {Transfer} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// Requirements:\n\t///   - caller account must have at least `value` WETH10 token.\n\t/// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\n\tfunction transferAndCall(\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external returns (bool);\n}\n"
    },
    "erc3156/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\nimport \"./IERC3156FlashBorrower.sol\";\n\n\ninterface IERC3156FlashLender {\n\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(\n        address token\n    ) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}"
    },
    "contracts/interfaces/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "erc3156/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n\ninterface IERC3156FlashBorrower {\n\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/testing/WETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2021\npragma solidity 0.8.2;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"../common/utils/IWETH10.sol\";\n\ninterface ITransferReceiver {\n\tfunction onTokenTransfer(\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata\n\t) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n\tfunction onTokenApproval(\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata\n\t) external returns (bool);\n}\n\n/// @dev Wrapped Ether v10 (WETH10) is an Ether (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance which can then be operated as an ERC-20 token. You can\n/// `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet. The amount of WETH10 token in any wallet is always identical to the\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\ncontract WETH10 is IWETH10 {\n\tstring public constant name = \"Wrapped Ether v10\";\n\tstring public constant symbol = \"WETH10\";\n\tuint8 public constant decimals = 18;\n\n\tbytes32 public immutable CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\tbytes32 public immutable PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tuint256 public immutable deploymentChainId;\n\tbytes32 private immutable _DOMAIN_SEPARATOR;\n\n\t/// @dev Records amount of WETH10 token owned by account.\n\tmapping(address => uint256) public override balanceOf;\n\n\t/// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\n\t/// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\n\tmapping(address => uint256) public override nonces;\n\n\t/// @dev Records number of WETH10 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\n\tmapping(address => mapping(address => uint256)) public override allowance;\n\n\t/// @dev Current amount of flash-minted WETH10 token.\n\tuint256 public override flashMinted;\n\n\tconstructor() {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\tdeploymentChainId = chainId;\n\t\t_DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);\n\t}\n\n\t/// @dev Calculate the DOMAIN_SEPARATOR.\n\tfunction _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n\t\t\t\t\tkeccak256(bytes(name)),\n\t\t\t\t\tkeccak256(bytes(\"1\")),\n\t\t\t\t\tchainId,\n\t\t\t\t\taddress(this)\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t/// @dev Return the DOMAIN_SEPARATOR.\n\tfunction DOMAIN_SEPARATOR() external view override returns (bytes32) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n\t}\n\n\t/// @dev Returns the total supply of WETH10 token as the ETH held in this contract.\n\tfunction totalSupply() external view override returns (uint256) {\n\t\treturn address(this).balance + flashMinted;\n\t}\n\n\t/// @dev Fallback, `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\n\t/// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\n\treceive() external payable {\n\t\t// _mintTo(msg.sender, msg.value);\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\temit Transfer(address(0), msg.sender, msg.value);\n\t}\n\n\t/// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\n\t/// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\n\tfunction deposit() external payable override {\n\t\t// _mintTo(msg.sender, msg.value);\n\t\tbalanceOf[msg.sender] += msg.value;\n\t\temit Transfer(address(0), msg.sender, msg.value);\n\t}\n\n\t/// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\n\t/// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\n\tfunction depositTo(address to) external payable override {\n\t\t// _mintTo(to, msg.value);\n\t\tbalanceOf[to] += msg.value;\n\t\temit Transfer(address(0), to, msg.value);\n\t}\n\n\t/// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\n\t/// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n\t/// Emits {Transfer} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\n\tfunction depositToAndCall(address to, bytes calldata data) external payable override returns (bool success) {\n\t\t// _mintTo(to, msg.value);\n\t\tbalanceOf[to] += msg.value;\n\t\temit Transfer(address(0), to, msg.value);\n\n\t\treturn ITransferReceiver(to).onTokenTransfer(msg.sender, msg.value, data);\n\t}\n\n\t/// @dev Return the amount of WETH10 token that can be flash-lent.\n\tfunction maxFlashLoan(address token) external view override returns (uint256) {\n\t\treturn token == address(this) ? type(uint112).max - flashMinted : 0; // Can't underflow\n\t}\n\n\t/// @dev Return the fee (zero) for flash lending an amount of WETH10 token.\n\tfunction flashFee(address token, uint256) external view override returns (uint256) {\n\t\trequire(token == address(this), \"WETH: flash mint only WETH10\");\n\t\treturn 0;\n\t}\n\n\t/// @dev Flash lends `value` WETH10 token to the receiver address.\n\t/// By the end of the transaction, `value` WETH10 token will be burned from the receiver.\n\t/// The flash-minted WETH10 token is not backed by real ETH, but can be withdrawn as such up to the ETH balance of this contract.\n\t/// Arbitrary data can be passed as a bytes calldata parameter.\n\t/// Emits {Approval} event to reflect reduced allowance `value` for this contract to spend from receiver account (`receiver`),\n\t/// unless allowance is set to `type(uint256).max`\n\t/// Emits two {Transfer} events for minting and burning of the flash-minted amount.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// Requirements:\n\t///   - `value` must be less or equal to type(uint112).max.\n\t///   - The total of all flash loans in a tx must be less or equal to type(uint112).max.\n\tfunction flashLoan(\n\t\tIERC3156FlashBorrower receiver,\n\t\taddress token,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external override returns (bool) {\n\t\trequire(token == address(this), \"WETH: flash mint only WETH10\");\n\t\trequire(value <= type(uint112).max, \"WETH: individual loan limit exceeded\");\n\t\tflashMinted = flashMinted + value;\n\t\trequire(flashMinted <= type(uint112).max, \"WETH: total loan limit exceeded\");\n\n\t\t// _mintTo(address(receiver), value);\n\t\tbalanceOf[address(receiver)] += value;\n\t\temit Transfer(address(0), address(receiver), value);\n\n\t\trequire(\n\t\t\treceiver.onFlashLoan(msg.sender, address(this), value, 0, data) == CALLBACK_SUCCESS,\n\t\t\t\"WETH: flash loan failed\"\n\t\t);\n\n\t\t// _decreaseAllowance(address(receiver), address(this), value);\n\t\tuint256 allowed = allowance[address(receiver)][address(this)];\n\t\tif (allowed != type(uint256).max) {\n\t\t\trequire(allowed >= value, \"WETH: request exceeds allowance\");\n\t\t\tuint256 reduced = allowed - value;\n\t\t\tallowance[address(receiver)][address(this)] = reduced;\n\t\t\temit Approval(address(receiver), address(this), reduced);\n\t\t}\n\n\t\t// _burnFrom(address(receiver), value);\n\t\tuint256 balance = balanceOf[address(receiver)];\n\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\tbalanceOf[address(receiver)] = balance - value;\n\t\temit Transfer(address(receiver), address(0), value);\n\n\t\tflashMinted = flashMinted - value;\n\t\treturn true;\n\t}\n\n\t/// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\n\t/// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\n\t/// Requirements:\n\t///   - caller account must have at least `value` balance of WETH10 token.\n\tfunction withdraw(uint256 value) external override {\n\t\t// _burnFrom(msg.sender, value);\n\t\tuint256 balance = balanceOf[msg.sender];\n\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\tbalanceOf[msg.sender] = balance - value;\n\t\temit Transfer(msg.sender, address(0), value);\n\n\t\t// _transferEther(msg.sender, value);\n\t\t(bool success, ) = msg.sender.call{ value: value }(\"\");\n\t\trequire(success, \"WETH: ETH transfer failed\");\n\t}\n\n\t/// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\n\t/// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\n\t/// Requirements:\n\t///   - caller account must have at least `value` balance of WETH10 token.\n\tfunction withdrawTo(address payable to, uint256 value) external override {\n\t\t// _burnFrom(msg.sender, value);\n\t\tuint256 balance = balanceOf[msg.sender];\n\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\tbalanceOf[msg.sender] = balance - value;\n\t\temit Transfer(msg.sender, address(0), value);\n\n\t\t// _transferEther(to, value);\n\t\t(bool success, ) = to.call{ value: value }(\"\");\n\t\trequire(success, \"WETH: ETH transfer failed\");\n\t}\n\n\t/// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\n\t/// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n\t/// unless allowance is set to `type(uint256).max`\n\t/// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\n\t/// Requirements:\n\t///   - `from` account must have at least `value` balance of WETH10 token.\n\t///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n\tfunction withdrawFrom(\n\t\taddress from,\n\t\taddress payable to,\n\t\tuint256 value\n\t) external override {\n\t\tif (from != msg.sender) {\n\t\t\t// _decreaseAllowance(from, msg.sender, value);\n\t\t\tuint256 allowed = allowance[from][msg.sender];\n\t\t\tif (allowed != type(uint256).max) {\n\t\t\t\trequire(allowed >= value, \"WETH: request exceeds allowance\");\n\t\t\t\tuint256 reduced = allowed - value;\n\t\t\t\tallowance[from][msg.sender] = reduced;\n\t\t\t\temit Approval(from, msg.sender, reduced);\n\t\t\t}\n\t\t}\n\n\t\t// _burnFrom(from, value);\n\t\tuint256 balance = balanceOf[from];\n\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\tbalanceOf[from] = balance - value;\n\t\temit Transfer(from, address(0), value);\n\n\t\t// _transferEther(to, value);\n\t\t(bool success, ) = to.call{ value: value }(\"\");\n\t\trequire(success, \"WETH: Ether transfer failed\");\n\t}\n\n\t/// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token.\n\t/// Emits {Approval} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\tfunction approve(address spender, uint256 value) external override returns (bool) {\n\t\t// _approve(msg.sender, spender, value);\n\t\tallowance[msg.sender][spender] = value;\n\t\temit Approval(msg.sender, spender, value);\n\n\t\treturn true;\n\t}\n\n\t/// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\n\t/// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n\t/// Emits {Approval} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\n\tfunction approveAndCall(\n\t\taddress spender,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external override returns (bool) {\n\t\t// _approve(msg.sender, spender, value);\n\t\tallowance[msg.sender][spender] = value;\n\t\temit Approval(msg.sender, spender, value);\n\n\t\treturn IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\n\t}\n\n\t/// @dev Sets `value` as allowance of `spender` account over `owner` account's WETH10 token, given `owner` account's signed approval.\n\t/// Emits {Approval} event.\n\t/// Requirements:\n\t///   - `deadline` must be timestamp in future.\n\t///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\n\t///   - the signature must use `owner` account's current nonce (see {nonces}).\n\t///   - the signer cannot be `address(0)` and must be `owner` account.\n\t/// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\n\t/// WETH10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external override {\n\t\trequire(block.timestamp <= deadline, \"WETH: Expired permit\");\n\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\tbytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n\n\t\tbytes32 hash =\n\t\t\tkeccak256(\n\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\"\\x19\\x01\",\n\t\t\t\t\tchainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId),\n\t\t\t\t\thashStruct\n\t\t\t\t)\n\t\t\t);\n\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0) && signer == owner, \"WETH: invalid permit\");\n\n\t\t// _approve(owner, spender, value);\n\t\tallowance[owner][spender] = value;\n\t\temit Approval(owner, spender, value);\n\t}\n\n\t/// @dev Moves `value` WETH10 token from caller's account to account (`to`).\n\t/// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\n\t/// Emits {Transfer} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// Requirements:\n\t///   - caller account must have at least `value` WETH10 token.\n\tfunction transfer(address to, uint256 value) external override returns (bool) {\n\t\t// _transferFrom(msg.sender, to, value);\n\t\tif (to != address(0)) {\n\t\t\t// Transfer\n\t\t\tuint256 balance = balanceOf[msg.sender];\n\t\t\trequire(balance >= value, \"WETH: transfer amount exceeds balance\");\n\n\t\t\tbalanceOf[msg.sender] = balance - value;\n\t\t\tbalanceOf[to] += value;\n\t\t\temit Transfer(msg.sender, to, value);\n\t\t} else {\n\t\t\t// Withdraw\n\t\t\tuint256 balance = balanceOf[msg.sender];\n\t\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\t\tbalanceOf[msg.sender] = balance - value;\n\t\t\temit Transfer(msg.sender, address(0), value);\n\n\t\t\t(bool success, ) = msg.sender.call{ value: value }(\"\");\n\t\t\trequire(success, \"WETH: ETH transfer failed\");\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\n\t/// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\n\t/// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\n\t/// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n\t/// unless allowance is set to `type(uint256).max`\n\t/// Emits {Transfer} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// Requirements:\n\t///   - `from` account must have at least `value` balance of WETH10 token.\n\t///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external override returns (bool) {\n\t\tif (from != msg.sender) {\n\t\t\t// _decreaseAllowance(from, msg.sender, value);\n\t\t\tuint256 allowed = allowance[from][msg.sender];\n\t\t\tif (allowed != type(uint256).max) {\n\t\t\t\trequire(allowed >= value, \"WETH: request exceeds allowance\");\n\t\t\t\tuint256 reduced = allowed - value;\n\t\t\t\tallowance[from][msg.sender] = reduced;\n\t\t\t\temit Approval(from, msg.sender, reduced);\n\t\t\t}\n\t\t}\n\n\t\t// _transferFrom(from, to, value);\n\t\tif (to != address(0)) {\n\t\t\t// Transfer\n\t\t\tuint256 balance = balanceOf[from];\n\t\t\trequire(balance >= value, \"WETH: transfer amount exceeds balance\");\n\n\t\t\tbalanceOf[from] = balance - value;\n\t\t\tbalanceOf[to] += value;\n\t\t\temit Transfer(from, to, value);\n\t\t} else {\n\t\t\t// Withdraw\n\t\t\tuint256 balance = balanceOf[from];\n\t\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\t\tbalanceOf[from] = balance - value;\n\t\t\temit Transfer(from, address(0), value);\n\n\t\t\t(bool success, ) = msg.sender.call{ value: value }(\"\");\n\t\t\trequire(success, \"WETH: ETH transfer failed\");\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/// @dev Moves `value` WETH10 token from caller's account to account (`to`),\n\t/// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n\t/// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\n\t/// Emits {Transfer} event.\n\t/// Returns boolean value indicating whether operation succeeded.\n\t/// Requirements:\n\t///   - caller account must have at least `value` WETH10 token.\n\t/// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\n\tfunction transferAndCall(\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external override returns (bool) {\n\t\t// _transferFrom(msg.sender, to, value);\n\t\tif (to != address(0)) {\n\t\t\t// Transfer\n\t\t\tuint256 balance = balanceOf[msg.sender];\n\t\t\trequire(balance >= value, \"WETH: transfer amount exceeds balance\");\n\n\t\t\tbalanceOf[msg.sender] = balance - value;\n\t\t\tbalanceOf[to] += value;\n\t\t\temit Transfer(msg.sender, to, value);\n\t\t} else {\n\t\t\t// Withdraw\n\t\t\tuint256 balance = balanceOf[msg.sender];\n\t\t\trequire(balance >= value, \"WETH: burn amount exceeds balance\");\n\t\t\tbalanceOf[msg.sender] = balance - value;\n\t\t\temit Transfer(msg.sender, address(0), value);\n\n\t\t\t(bool success, ) = msg.sender.call{ value: value }(\"\");\n\t\t\trequire(success, \"WETH: ETH transfer failed\");\n\t\t}\n\n\t\treturn ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\n\t}\n}\n"
    },
    "contracts/testing/LenderWithLiquidity.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract LenderWithLiquidity is IERC3156FlashLender {\n\tconstructor() {}\n\n\tfunction maxFlashLoan(address token) external view override returns (uint256) {\n\t\treturn IERC20(token).balanceOf(address(this));\n\t}\n\n\tfunction flashFee(address token, uint256 amount) external view override returns (uint256) {\n\t\trequire(\n\t\t\tamount <= this.maxFlashLoan(token),\n\t\t\t\"LendingPoolsAggregator: Liquidity is not sufficient for requested amount\"\n\t\t);\n\n\t\treturn amount / 1000;\n\t}\n\n\tfunction flashLoan(\n\t\tIERC3156FlashBorrower receiver,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external override returns (bool) {\n\t\trequire(\n\t\t\tamount <= this.maxFlashLoan(token),\n\t\t\t\"LendingPoolsAggregator: Liquidity is not sufficient for requested amount\"\n\t\t);\n\n\t\tuint256 fee = this.flashFee(token, amount);\n\n\t\tIERC20(token).transfer(address(receiver), amount);\n\n\t\trequire(\n\t\t\treceiver.onFlashLoan(msg.sender, token, amount, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\"),\n\t\t\t\"IERC3156: Callback failed\"\n\t\t);\n\n\t\trequire(IERC20(token).transferFrom(address(receiver), address(this), amount + fee), \"FlashLender: Repay failed\");\n\n\t\treturn true;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/testing/Borrower.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Borrower is IERC3156FlashBorrower {\n\tstring myData = \"my precious data\";\n\n\tIERC3156FlashLender _lender;\n\n\tconstructor(IERC3156FlashLender lender) {\n\t\t_lender = lender;\n\t}\n\n\tfunction borrow(address token, uint256 amount) external {\n\t\tbytes memory data = abi.encode(myData);\n\t\t_lender.flashLoan(this, token, amount, data);\n\t}\n\n\tfunction onFlashLoan(\n\t\taddress initiator,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tuint256 fee,\n\t\tbytes calldata data\n\t) external override returns (bytes32) {\n\t\trequire(initiator == address(this), \"Initiator must be the lending contract\");\n\n\t\tstring memory decoded = abi.decode(data, (string));\n\t\trequire(keccak256(abi.encodePacked(decoded)) == keccak256(abi.encodePacked(myData)), \"my data is not kept as is\");\n\n\t\tIERC20(token).approve(msg.sender, amount + fee);\n\n\t\treturn keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\t}\n}\n"
    },
    "contracts/testing/LenderWithNoLiquidity.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\n\ncontract LenderWithNoLiquidity is IERC3156FlashLender {\n\tconstructor() {}\n\n\tfunction maxFlashLoan(address token) external pure override returns (uint256) {\n\t\treturn 0;\n\t}\n\n\tfunction flashFee(address token, uint256 amount) external pure override returns (uint256) {\n\t\trequire(false, \"LendingPoolsAggregator: Unsupported currency\");\n\n\t\treturn 0;\n\t}\n\n\tfunction flashLoan(\n\t\tIERC3156FlashBorrower receiver,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external override returns (bool) {\n\t\treturn false;\n\t}\n}\n"
    },
    "contracts/liquidity/LendingPoolsAggregator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./LendingPool.sol\";\n\ncontract LendingPoolsAggregator is LendingPool, IERC3156FlashLender, IERC3156FlashBorrower {\n\tbytes32 public immutable CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n\tstruct BorrowerData {\n\t\tbytes callerData;\n\t\tuint256 originalAmount;\n\t\taddress receiver;\n\t}\n\n\tstruct FlashStepLoadData {\n\t\tBorrowerData borrower;\n\t\tuint256 step;\n\t\tuint256 remainingAmount;\n\t\tuint256 cumulativeFee;\n\t}\n\n\tconstructor() {}\n\n\tfunction maxFlashLoan(address token) external view override returns (uint256) {\n\t\tuint256 maxBalance = 0;\n\n\t\tfor (uint256 i = 0; i < _lenders[token].length; i++) {\n\t\t\tIERC3156FlashLender lender = IERC3156FlashLender(_lenders[token][i]._address);\n\t\t\tmaxBalance = maxBalance + lender.maxFlashLoan(token);\n\t\t}\n\n\t\treturn maxBalance;\n\t}\n\n\tfunction flashFee(address token, uint256 amount) external view override returns (uint256) {\n\t\trequire(_lenders[token].length > 0, \"LendingPoolsAggregator: Unsupported currency\");\n\n\t\trequire(\n\t\t\tamount <= this.maxFlashLoan(token),\n\t\t\t\"LendingPoolsAggregator: Liquidity is not sufficient for requested amount\"\n\t\t);\n\n\t\tuint256 loanFee = 0;\n\t\tuint256 remainingLoanBalance = amount;\n\n\t\tfor (uint256 i = 0; i < _lenders[token].length && remainingLoanBalance > 0; i++) {\n\t\t\tLender memory lenderPool = _lenders[token][i];\n\t\t\tIERC3156FlashLender lender = IERC3156FlashLender(lenderPool._address);\n\t\t\tuint256 loanAmount = loanableAmount(lender, token, remainingLoanBalance);\n\n\t\t\tif (loanAmount > 0) {\n\t\t\t\tremainingLoanBalance = remainingLoanBalance - loanAmount;\n\t\t\t\tloanFee = loanFee + lender.flashFee(token, loanAmount) + calculatePoolFee(loanAmount, lenderPool);\n\t\t\t}\n\t\t}\n\n\t\treturn loanFee + calculatePlatformFee(amount);\n\t}\n\n\tfunction flashLoan(\n\t\tIERC3156FlashBorrower receiver,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external override returns (bool) {\n\t\trequire(\n\t\t\tamount <= this.maxFlashLoan(token),\n\t\t\t\"LendingPoolsAggregator: Liquidity is not sufficient for requested amount\"\n\t\t);\n\n\t\tBorrowerData memory borrower = BorrowerData(data, amount, address(receiver));\n\t\tFlashStepLoadData memory stepData = FlashStepLoadData(borrower, 0, amount, 0);\n\n\t\treturn executeFlashLoanStep(token, stepData);\n\t}\n\n\tfunction executeFlashLoanStep(address token, FlashStepLoadData memory stepData) internal returns (bool) {\n\t\tIERC3156FlashLender lender = IERC3156FlashLender(_lenders[token][stepData.step]._address);\n\t\tuint256 loanAmount = loanableAmount(lender, token, stepData.remainingAmount);\n\n\t\tif (loanAmount > 0) {\n\t\t\tIERC20(token).approve(address(lender), loanAmount + lender.flashFee(token, loanAmount));\n\t\t\tbytes memory stepEncodedData = abi.encode(stepData);\n\n\t\t\treturn lender.flashLoan(IERC3156FlashBorrower(address(this)), token, loanAmount, stepEncodedData);\n\t\t} else {\n\t\t\treturn executeNextFlashLoanStep(token, stepData);\n\t\t}\n\t}\n\n\tfunction onFlashLoan(\n\t\taddress initiator,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tuint256 fee,\n\t\tbytes calldata data\n\t) external override returns (bytes32) {\n\t\trequire(initiator == address(this), \"Initiator must be LendingPoolAggregator\");\n\n\t\tFlashStepLoadData memory stepData = abi.decode(data, (FlashStepLoadData));\n\t\trequire(stepData.step < _lenders[token].length, \"Incorrect flash loan step id\");\n\n\t\tLender memory lender = _lenders[token][stepData.step];\n\t\trequire(msg.sender == lender._address, \"Caller must be the Lender pool\");\n\n\t\tuint256 poolFee = calculatePoolFee(amount, lender);\n\t\tstepData.remainingAmount = stepData.remainingAmount - amount;\n\t\tstepData.cumulativeFee = stepData.cumulativeFee + fee + poolFee;\n\n\t\tif (stepData.remainingAmount > 0) {\n\t\t\texecuteNextFlashLoanStep(token, stepData);\n\t\t} else {\n\t\t\tconcludeFlashLoan(stepData, token);\n\t\t}\n\n\t\tIERC20(token).transfer(lender._feeCollectionAddress, poolFee);\n\n\t\treturn CALLBACK_SUCCESS;\n\t}\n\n\tfunction executeNextFlashLoanStep(address token, FlashStepLoadData memory stepData) internal returns (bool) {\n\t\tstepData.step = stepData.step + 1;\n\t\treturn executeFlashLoanStep(token, stepData);\n\t}\n\n\tfunction concludeFlashLoan(FlashStepLoadData memory stepData, address token) internal {\n\t\trequire(\n\t\t\tIERC20(token).transfer(address(stepData.borrower.receiver), stepData.borrower.originalAmount),\n\t\t\t\"FlashLender: Transfer failed\"\n\t\t);\n\n\t\tuint256 platformFees = calculatePlatformFee(stepData.borrower.originalAmount);\n\t\tuint256 totalFees = stepData.cumulativeFee + platformFees;\n\n\t\tIERC3156FlashBorrower receiver = IERC3156FlashBorrower(stepData.borrower.receiver);\n\t\trequire(\n\t\t\treceiver.onFlashLoan(\n\t\t\t\tstepData.borrower.receiver,\n\t\t\t\ttoken,\n\t\t\t\tstepData.borrower.originalAmount,\n\t\t\t\ttotalFees,\n\t\t\t\tstepData.borrower.callerData\n\t\t\t) == CALLBACK_SUCCESS,\n\t\t\t\"IERC3156: Callback failed\"\n\t\t);\n\n\t\trequire(\n\t\t\tIERC20(token).transferFrom(address(receiver), address(this), stepData.borrower.originalAmount + totalFees),\n\t\t\t\"FlashLender: Repay failed\"\n\t\t);\n\n\t\tIERC20(token).transfer(_platformFeeCollectionAddress, platformFees);\n\t}\n\n\tfunction loanableAmount(\n\t\tIERC3156FlashLender lender,\n\t\taddress token,\n\t\tuint256 amount\n\t) internal view returns (uint256) {\n\t\treturn Math.min(lender.maxFlashLoan(token), amount);\n\t}\n\n\tfunction calculatePoolFee(uint256 tokenAmount, Lender memory lender) internal pure returns (uint256) {\n\t\treturn (tokenAmount * lender._feeBips) / 10000;\n\t}\n\n\tfunction calculatePlatformFee(uint256 tokenAmount) internal view returns (uint256) {\n\t\treturn (tokenAmount * _platformFeeBips) / 10000;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/liquidity/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LendingPool is Ownable {\n\tstruct Lender {\n\t\taddress _address;\n\t\taddress _feeCollectionAddress;\n\t\tuint256 _feeBips;\n\t}\n\n\tmapping(address => Lender[]) internal _lenders;\n\n\tuint256 internal _platformFeeBips;\n\taddress internal _platformFeeCollectionAddress;\n\n\tconstructor() {}\n\n\tfunction platformFeeBips() external view returns (uint256) {\n\t\treturn _platformFeeBips;\n\t}\n\n\tfunction platformFeeCollectionAddress() external view returns (address) {\n\t\treturn _platformFeeCollectionAddress;\n\t}\n\n\tfunction lenders(address tokenAddress) external view returns (Lender[] memory) {\n\t\treturn _lenders[tokenAddress];\n\t}\n\n\tfunction setPlatformFeeBips(uint256 bips) external onlyOwner {\n\t\t_platformFeeBips = bips;\n\t}\n\n\tfunction setPlatformFeeCollectionAddress(address feeCollectionAddress) external onlyOwner {\n\t\t_platformFeeCollectionAddress = feeCollectionAddress;\n\t}\n\n\tfunction setLenders(address tokenAddress, Lender[] memory newLenders) external onlyOwner {\n\t\tdelete _lenders[tokenAddress];\n\t\tfor (uint256 index = 0; index < newLenders.length; index++) {\n\t\t\t_lenders[tokenAddress].push(newLenders[index]);\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/tokens/UnlimitedApprovalERC20.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nabstract contract UnlimitedApprovalERC20 is ERC20 {\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t// Check for and update remaining allowance\n\t\tif (allowance(sender, _msgSender()) != type(uint256).max) {\n\t\t\t_approve(\n\t\t\t\tsender,\n\t\t\t\t_msgSender(),\n\t\t\t\tSafeMath.sub(\n\t\t\t\t\tallowance(sender, _msgSender()),\n\t\t\t\t\tamount,\n\t\t\t\t\t\"UnlimitedApprovalERC20: transfer amount exceeds allowance\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/governance/KING.sol": {
      "content": "/* solhint-disable max-line-length */\n/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n                                                                                    \n                                                                                  \n                                                                                \n                                                                            \n                                                                            \n                                                                              \n                                                                          \n                                                                        \n                                                                    \n                                                                        \n                                                                              \n                                                                            \n                                                                          \n                                                                                        \n                                                                            \n                                                            \n                                                \n                                      \n                  \n                  \n              \n                    \n                      \n                  \n                \n                    \n            \n                \n                  \n                \n              \n              \n                \n                      \n                              \n                                \n                            \n                          \n                                \n                            \n                            \n                              \n                              \n                            \n                              \n                              \n                              \n                                \n                                      \n                                            \n                                        \n                                      \n                                \n                                \n                                  \n                                                                  \n                                      \n                                  \n                                                  \n\n*/\n/* solhint-enable max-line-length */\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/governance/ICrownGovernanceToken.sol\";\n\n/**\n * @title KING\n * @dev The governance token for the Kingmaker protocol\n * @notice ERC-20 with supply controls + add-ons to allow for offchain signing (see EIP-712, EIP-2612, and EIP-3009)\n */\ncontract KING is ICrownGovernanceToken {\n\tusing ECDSA for *;\n\tusing SafeMath for uint256;\n\n\t/// @notice EIP-20 token name for this token\n\tstring public override name = \"Kingmaker Crown Governance Token\";\n\n\t/// @notice EIP-20 token symbol for this token\n\tstring public override symbol = \"KING\"; // or unicode\"\" ?\n\n\t/// @notice EIP-20 token decimals for this token\n\tuint8 public constant override decimals = 18;\n\n\t/// @notice Total number of tokens in circulation\n\tuint256 public override totalSupply = 90000e18; // 90 thousands units\n\n\t/// @notice Address which may mint/burn tokens\n\taddress public override supplyManager;\n\n\t/// @notice Address which may change token metadata\n\taddress public override metadataManager;\n\n\t/// @notice The timestamp after which a supply change may occur\n\tuint256 public override supplyChangeAllowedAfter;\n\n\t/// @notice The initial minimum waiting time for changing the token supply\n\tuint32 public override supplyChangeWaitingPeriod = 1 days * 365; // 1 year\n\n\t/// @notice Hard cap on the minimum waiting time for changing the token supply\n\tuint32 public constant override supplyChangeWaitingPeriodMinimum = 1 days * 90;\n\t// solhint-disable-next-line max-line-length\n\t/// @notice Cap on the total amount that can be minted at each mint (measured in bips: 10,000 bips = 1% of current totalSupply)\n\tuint32 public override mintCap = 900000;\n\n\t/// @dev Allowance amounts on behalf of others\n\tmapping(address => mapping(address => uint256)) internal allowances;\n\n\t/// @dev Official record of token balances for each account\n\tmapping(address => uint256) internal balances;\n\n\t/// @notice The EIP-712 typehash for the contract's domain\n\t/// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant override DOMAIN_SEPARATOR =\n\t\t0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n\t/// @notice The EIP-712 version hash\n\t/// keccak256(\"1\");\n\tbytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n\t/// @notice The EIP-712 typehash for permit (EIP-2612)\n\t/// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/// @notice The EIP-712 typehash for transferWithAuthorization (EIP-3009)\n\t// solhint-disable-next-line max-line-length\n\t/// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n\t\t0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/// @notice The EIP-712 typehash for receiveWithAuthorization (EIP-3009)\n\t// solhint-disable-next-line max-line-length\n\t/// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\n\t\t0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/// @notice A record of states for signing / validating signatures\n\tmapping(address => uint256) public override nonces;\n\n\t/// @dev authorizer address > nonce > state (true = used / false = unused)\n\tmapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n\t/**\n\t * @notice Construct a new KING token\n\t * @param _metadataManager The address with the ability to alter the token metadata\n\t * @param _supplyManager The address with the ability to mint more tokens\n\t * @param _firstSupplyChangeAllowed The timestamp after which the first supply change may occur\n\t */\n\tconstructor(\n\t\taddress _metadataManager,\n\t\taddress _supplyManager,\n\t\tuint256 _firstSupplyChangeAllowed\n\t) {\n\t\trequire(\n\t\t\t_firstSupplyChangeAllowed >= block.timestamp,\n\t\t\t\"KING::constructor: minting can only begin after deployment\"\n\t\t);\n\n\t\tbalances[msg.sender] = totalSupply;\n\t\temit Transfer(address(0), msg.sender, totalSupply);\n\n\t\tsupplyChangeAllowedAfter = _firstSupplyChangeAllowed;\n\t\tsupplyManager = _supplyManager;\n\t\temit SupplyManagerChanged(address(0), _supplyManager);\n\n\t\tmetadataManager = _metadataManager;\n\t\temit MetadataManagerChanged(address(0), metadataManager);\n\n\t\t// gasless method to prevent tokens transfers to the token address\n\t\tbalances[address(this)] = type(uint256).max;\n\t}\n\n\t/**\n\t * @notice Change the supplyManager address\n\t * @param newSupplyManager The address of the new supply manager\n\t * @return true if successful\n\t */\n\tfunction setSupplyManager(address newSupplyManager) external override returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setSupplyManager: only SM can change SM\");\n\t\temit SupplyManagerChanged(supplyManager, newSupplyManager);\n\t\tsupplyManager = newSupplyManager;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Change the metadataManager address\n\t * @param newMetadataManager The address of the new metadata manager\n\t * @return true if successful\n\t */\n\tfunction setMetadataManager(address newMetadataManager) external override returns (bool) {\n\t\trequire(msg.sender == metadataManager, \"KING::setMetadataManager: only MM can change MM\");\n\t\temit MetadataManagerChanged(metadataManager, newMetadataManager);\n\t\tmetadataManager = newMetadataManager;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Mint new tokens\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to be minted\n\t * @return Boolean indicating success of mint\n\t */\n\tfunction mint(address dst, uint256 amount) external override returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::mint: only the supplyManager can mint\");\n\t\trequire(dst != address(0), \"KING::mint: cannot transfer to the zero address\");\n\t\trequire(amount <= (totalSupply * (mintCap)) / (1000000), \"KING::mint: exceeded mint cap\");\n\t\trequire(block.timestamp >= supplyChangeAllowedAfter, \"KING::mint: minting not allowed yet\");\n\n\t\t// update the next supply change allowed timestamp\n\t\tsupplyChangeAllowedAfter = block.timestamp + supplyChangeWaitingPeriod;\n\n\t\t// mint the amount\n\t\t_mint(dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Burn tokens\n\t * @param src The account that will burn tokens\n\t * @param amount The number of tokens to be burned\n\t * @return Boolean indicating success of burn\n\t */\n\tfunction burn(address src, uint256 amount) external override returns (bool) {\n\t\taddress spender = msg.sender;\n\t\trequire(spender == supplyManager, \"KING::burn: only the supplyManager can burn\");\n\t\trequire(src != address(0), \"KING::burn: cannot transfer from the zero address\");\n\t\trequire(block.timestamp >= supplyChangeAllowedAfter, \"KING::burn: burning not allowed yet\");\n\n\t\tuint256 spenderAllowance = allowances[src][spender];\n\t\t// check allowance and reduce by amount\n\t\tif (spender != src && spenderAllowance != type(uint256).max) {\n\t\t\tuint256 newAllowance = spenderAllowance.sub(amount, \"KING::burn: burn amount exceeds allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t// update the next supply change allowed timestamp\n\t\tsupplyChangeAllowedAfter = block.timestamp + supplyChangeWaitingPeriod;\n\n\t\t// burn the amount\n\t\t_burn(src, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Set the maximum amount of tokens that can be minted at once\n\t * @param newCap The new mint cap in bips (10,000 bips = 1% of totalSupply)\n\t * @return true if successful\n\t */\n\tfunction setMintCap(uint32 newCap) external override returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setMintCap: only SM can change mint cap\");\n\t\temit MintCapChanged(mintCap, newCap);\n\t\tmintCap = newCap;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Set the minimum time between supply changes\n\t * @param period The new supply change waiting period\n\t * @return true if succssful\n\t */\n\tfunction setSupplyChangeWaitingPeriod(uint32 period) external override returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setSupplyChangeWaitingPeriod: only SM can change waiting period\");\n\t\trequire(\n\t\t\tperiod >= supplyChangeWaitingPeriodMinimum,\n\t\t\t\"KING::setSupplyChangeWaitingPeriod: waiting period must be > minimum\"\n\t\t);\n\t\temit SupplyChangeWaitingPeriodChanged(supplyChangeWaitingPeriod, period);\n\t\tsupplyChangeWaitingPeriod = period;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Update the token name and symbol\n\t * @param tokenName The new name for the token\n\t * @param tokenSymbol The new symbol for the token\n\t * @return true if successful\n\t */\n\tfunction updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external override returns (bool) {\n\t\trequire(msg.sender == metadataManager, \"KING::updateTokenMeta: only MM can update token metadata\");\n\t\tname = tokenName;\n\t\tsymbol = tokenSymbol;\n\t\temit TokenMetaUpdated(name, symbol);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n\t * @param account The address of the account holding the funds\n\t * @param spender The address of the account spending the funds\n\t * @return The number of tokens approved\n\t */\n\tfunction allowance(address account, address spender) external view override returns (uint256) {\n\t\treturn allowances[account][spender];\n\t}\n\n\t/**\n\t * @notice Approve `spender` to transfer up to `amount` from `src`\n\t * @dev This will overwrite the approval amount for `spender`\n\t * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\t * It is recommended to use increaseAllowance and decreaseAllowance instead\n\t * @param spender The address of the account which may transfer tokens\n\t * @param amount The number of tokens that are approved (2^256-1 means infinite)\n\t * @return Whether or not the approval succeeded\n\t */\n\tfunction approve(address spender, uint256 amount) external override returns (bool) {\n\t\t_approve(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Increase the allowance by a given amount\n\t * @param spender Spender's address\n\t * @param addedValue Amount of increase in allowance\n\t * @return True if successful\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n\t\t_increaseAllowance(msg.sender, spender, addedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Decrease the allowance by a given amount\n\t * @param spender Spender's address\n\t * @param subtractedValue Amount of decrease in allowance\n\t * @return True if successful\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n\t\t_decreaseAllowance(msg.sender, spender, subtractedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Triggers an approval from owner to spender\n\t * @param owner The address to approve from\n\t * @param spender The address to be approved\n\t * @param value The number of tokens that are approved (2^256-1 means infinite)\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external override {\n\t\trequire(deadline >= block.timestamp, \"KING::permit: signature expired\");\n\n\t\tbytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n\t\t_validateSignedData(owner, encodeData, v, r, s);\n\n\t\t_approve(owner, spender, value);\n\t}\n\n\t/**\n\t * @notice Get the number of tokens held by the `account`\n\t * @param account The address of the account to get the balance of\n\t * @return The number of tokens held\n\t */\n\tfunction balanceOf(address account) external view override returns (uint256) {\n\t\treturn balances[account];\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transfer(address dst, uint256 amount) external override returns (bool) {\n\t\t_transferTokens(msg.sender, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `src` to `dst`\n\t * @param src The address of the source account\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transferFrom(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 amount\n\t) external override returns (bool) {\n\t\taddress spender = msg.sender;\n\t\tuint256 spenderAllowance = allowances[src][spender];\n\n\t\tif (spender != src && spenderAllowance != type(uint256).max) {\n\t\t\tuint256 newAllowance = spenderAllowance.sub(amount, \"KING::transferFrom: transfer amount exceeds allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t_transferTokens(src, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer tokens with a signed authorization\n\t * @param from Payer's address (Authorizer)\n\t * @param to Payee's address\n\t * @param value Amount to be transferred\n\t * @param validAfter The time after which this is valid (unix time)\n\t * @param validBefore The time before which this is valid (unix time)\n\t * @param nonce Unique nonce\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(block.timestamp > validAfter, \"KING::transferWithAuth: auth not yet valid\");\n\t\trequire(block.timestamp < validBefore, \"KING::transferWithAuth: auth expired\");\n\t\trequire(!authorizationState[from][nonce], \"KING::transferWithAuth: auth already used\");\n\n\t\tbytes32 encodeData =\n\t\t\tkeccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n\t\t_validateSignedData(from, encodeData, v, r, s);\n\n\t\tauthorizationState[from][nonce] = true;\n\t\temit AuthorizationUsed(from, nonce);\n\n\t\t_transferTokens(from, to, value);\n\t}\n\n\t/**\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t * @dev This has an additional check to ensure that the payee's address matches\n\t * the caller of this function to prevent front-running attacks.\n\t * @param from Payer's address (Authorizer)\n\t * @param to Payee's address\n\t * @param value Amount to be transferred\n\t * @param validAfter The time after which this is valid (unix time)\n\t * @param validBefore The time before which this is valid (unix time)\n\t * @param nonce Unique nonce\n\t * @param v v of the signature\n\t * @param r r of the signature\n\t * @param s s of the signature\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(to == msg.sender, \"KING::receiveWithAuth: caller must be the payee\");\n\t\trequire(block.timestamp > validAfter, \"KING::receiveWithAuth: auth not yet valid\");\n\t\trequire(block.timestamp < validBefore, \"KING::receiveWithAuth: auth expired\");\n\t\trequire(!authorizationState[from][nonce], \"KING::receiveWithAuth: auth already used\");\n\n\t\tbytes32 encodeData =\n\t\t\tkeccak256(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n\t\t_validateSignedData(from, encodeData, v, r, s);\n\n\t\tauthorizationState[from][nonce] = true;\n\t\temit AuthorizationUsed(from, nonce);\n\n\t\t_transferTokens(from, to, value);\n\t}\n\n\t/**\n\t * @notice EIP-712 Domain separator\n\t * @return Separator\n\t */\n\tfunction getDomainSeparator() public view returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(abi.encode(DOMAIN_SEPARATOR, keccak256(bytes(name)), VERSION_HASH, _getChainId(), address(this)));\n\t}\n\n\t/**\n\t * @notice Recovers address from signed data and validates the signature\n\t * @param signer Address that signed the data\n\t * @param encodeData Data signed by the address\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction _validateSignedData(\n\t\taddress signer,\n\t\tbytes32 encodeData,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal view {\n\t\tbytes32 dataHash = ECDSA.toTypedDataHash(getDomainSeparator(), encodeData);\n\t\taddress recoveredAddress = ECDSA.recover(dataHash, v, r, s);\n\n\t\t// Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == signer, \"KING::validateSig: invalid signature\");\n\t}\n\n\t/**\n\t * @notice Approval implementation\n\t * @param owner The address of the account which owns tokens\n\t * @param spender The address of the account which may transfer tokens\n\t * @param amount The number of tokens that are approved (2^256-1 means infinite)\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(owner != address(0), \"KING::_approve: approve from the zero address\");\n\t\trequire(spender != address(0), \"KING::_approve: approve to the zero address\");\n\t\tallowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction _increaseAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 addedValue\n\t) internal {\n\t\t_approve(owner, spender, allowances[owner][spender] + addedValue);\n\t}\n\n\tfunction _decreaseAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 subtractedValue\n\t) internal {\n\t\t_approve(\n\t\t\towner,\n\t\t\tspender,\n\t\t\tallowances[owner][spender].sub(subtractedValue, \"KING::_decreaseAllowance: decreased allowance below zero\")\n\t\t);\n\t}\n\n\t/**\n\t * @notice Transfer implementation\n\t * @param from The address of the account which owns tokens\n\t * @param to The address of the account which is receiving tokens\n\t * @param value The number of tokens that are being transferred\n\t */\n\tfunction _transferTokens(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\trequire(to != address(0), \"KING::_transferTokens: cannot transfer to the zero address\");\n\n\t\tbalances[from] = balances[from].sub(value, \"KING::_transferTokens: transfer exceeds from balance\");\n\t\tbalances[to] = balances[to] + value;\n\t\temit Transfer(from, to, value);\n\t}\n\n\t/**\n\t * @notice Mint implementation\n\t * @param to The address of the account which is receiving tokens\n\t * @param value The number of tokens that are being minted\n\t */\n\tfunction _mint(address to, uint256 value) internal {\n\t\ttotalSupply = totalSupply + value;\n\t\tbalances[to] = balances[to] + value;\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\t/**\n\t * @notice Burn implementation\n\t * @param from The address of the account which owns tokens\n\t * @param value The number of tokens that are being burned\n\t */\n\tfunction _burn(address from, uint256 value) internal {\n\t\tbalances[from] = balances[from].sub(value, \"KING::_burn: burn amount exceeds from balance\");\n\t\ttotalSupply = totalSupply.sub(value, \"KING::_burn: burn amount exceeds total supply\");\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\t/**\n\t * @notice Current id of the chain where this contract is deployed\n\t * @return Chain id\n\t */\n\tfunction _getChainId() internal view returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/interfaces/governance/ICrownGovernanceToken.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\ninterface ICrownGovernanceToken is IERC20, IERC20Permit {\n\t/// @notice An event that's emitted when the mintCap is changed\n\tevent MintCapChanged(uint32 indexed oldMintCap, uint32 indexed newMintCap);\n\t/// @notice An event that's emitted when the supplyManager address is changed\n\tevent SupplyManagerChanged(address indexed oldManager, address indexed newManager);\n\t/// @notice An event that's emitted when the supplyChangeWaitingPeriod is changed\n\tevent SupplyChangeWaitingPeriodChanged(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\n\t/// @notice An event that's emitted when the metadataManager address is changed\n\tevent MetadataManagerChanged(address indexed oldManager, address indexed newManager);\n\t/// @notice An event that's emitted when the token name and symbol are changed\n\tevent TokenMetaUpdated(string indexed name, string indexed symbol);\n\t/// @notice An event that's emitted whenever an authorized transfer occurs\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\tfunction name() external view returns (string memory);\n\n\tfunction symbol() external view returns (string memory);\n\n\tfunction decimals() external view returns (uint8);\n\n\tfunction mint(address dst, uint256 amount) external returns (bool);\n\n\tfunction burn(address src, uint256 amount) external returns (bool);\n\n\tfunction updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external returns (bool);\n\n\tfunction supplyManager() external view returns (address);\n\n\tfunction metadataManager() external view returns (address);\n\n\tfunction supplyChangeAllowedAfter() external view returns (uint256);\n\n\tfunction supplyChangeWaitingPeriod() external view returns (uint32);\n\n\tfunction supplyChangeWaitingPeriodMinimum() external view returns (uint32);\n\n\tfunction mintCap() external view returns (uint32);\n\n\tfunction setSupplyManager(address newSupplyManager) external returns (bool);\n\n\tfunction setMetadataManager(address newMetadataManager) external returns (bool);\n\n\tfunction setSupplyChangeWaitingPeriod(uint32 period) external returns (bool);\n\n\tfunction setMintCap(uint32 newCap) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/utils/Multisend.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../interfaces/governance/ICrownGovernanceToken.sol\";\n\n/**\n * @title Multisend\n * @dev Allows the sender to perform batch transfers of KING tokens\n */\ncontract Multisend is ReentrancyGuard {\n\t/// @notice Kingmaker governance token\n\tICrownGovernanceToken public token;\n\n\t/**\n\t * @notice Construct a new Multisend contract\n\t * @param _token Address of KING token\n\t */\n\tconstructor(ICrownGovernanceToken _token) {\n\t\ttoken = _token;\n\t}\n\n\t/**\n\t * @notice Batches multiple transfers\n\t * @dev Must approve this contract for `totalAmount` before calling\n\t * @param totalAmount Total amount to be transferred\n\t * @param recipients Array of accounts to receive transfers\n\t * @param amounts Array of amounts to send to accounts via transfers\n\t */\n\tfunction batchTransfer(\n\t\tuint256 totalAmount,\n\t\taddress[] calldata recipients,\n\t\tuint256[] calldata amounts\n\t) external nonReentrant {\n\t\t_batchTransfer(totalAmount, recipients, amounts);\n\t}\n\n\t/**\n\t * @notice Batches multiple transfers with approval provided by permit function\n\t * @param totalAmount Total amount to be transferred\n\t * @param recipients Array of accounts to receive transfers\n\t * @param amounts Array of amounts to send to accounts via transfers\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction batchTransferWithPermit(\n\t\tuint256 totalAmount,\n\t\taddress[] calldata recipients,\n\t\tuint256[] calldata amounts,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external nonReentrant {\n\t\ttoken.permit(msg.sender, address(this), totalAmount, deadline, v, r, s);\n\t\t_batchTransfer(totalAmount, recipients, amounts);\n\t}\n\n\t/**\n\t * @notice Internal implementation of batch transfer\n\t * @param totalAmount Total amount to be transferred\n\t * @param recipients Array of accounts to receive transfers\n\t * @param amounts Array of amounts to send to accounts via transfers\n\t */\n\tfunction _batchTransfer(\n\t\tuint256 totalAmount,\n\t\taddress[] calldata recipients,\n\t\tuint256[] calldata amounts\n\t) internal {\n\t\trequire(\n\t\t\ttoken.allowance(msg.sender, address(this)) >= totalAmount,\n\t\t\t\"Multisend::_batchTransfer: allowance too low\"\n\t\t);\n\t\trequire(token.balanceOf(msg.sender) >= totalAmount, \"Multisend::_batchTransfer: sender balance too low\");\n\t\trequire(recipients.length == amounts.length, \"Multisend::_batchTransfer: recipients length != amounts length\");\n\t\tuint256 amountTransferred = 0;\n\t\tfor (uint256 i; i < recipients.length; i++) {\n\t\t\tbool success = token.transferFrom(msg.sender, recipients[i], amounts[i]);\n\t\t\trequire(success, \"Multisend::_batchTransfer: failed to transfer tokens\");\n\t\t\tamountTransferred = amountTransferred + amounts[i];\n\t\t}\n\t\trequire(amountTransferred == totalAmount, \"Multisend::_batchTransfer: total != transferred amount\");\n\t}\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/governance/Treasurer.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../libraries/governance/LibCrownStorage.sol\";\n\nimport \"../../interfaces/governance/ILockManager.sol\";\nimport \"../../interfaces/governance/IMasterChef.sol\";\nimport \"../../interfaces/governance/IVault.sol\";\n\nabstract contract Treasurer is ReentrancyGuard {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Info of each user.\n\tstruct UserInfo {\n\t\t// We do some basic math here. Basically, at any point in time, the amount of reward tokens\n\t\t// entitled to a user, pending to be distributed, is given by:\n\t\t//\n\t\t//   pendingReward = (user.amount * pool.accRewardsPerShare) - user.rewardDebt\n\t\t//\n\t\t// Whenever a user deposits or withdraws tokens to a pool. Here's what happens:\n\t\t//   1. The pool's `accRewardsPerShare` (and `lastRewardBlock`) gets updated.\n\t\t//   2. User receives the pending reward sent to his/her address.\n\t\t//   3. User's `amount` gets updated.\n\t\t//   4. User's `rewardDebt` gets updated.\n\t\tuint256 amount; // How many tokens the user has provided.\n\t\tuint256 rewardTokenDebt; // Reward debt for reward token. See explanation above.\n\t\tuint256 sushiRewardDebt; // Reward debt for Sushi rewards. See explanation above.\n\t}\n\n\t/// @notice Info of each pool.\n\tstruct PoolInfo {\n\t\tIERC20 token; // Address of token contract.\n\t\tuint256 allocPoint; // How many allocation points assigned to this pool. Reward tokens to distribute per block.\n\t\tuint256 lastRewardBlock; // Last block number where reward tokens were distributed.\n\t\tuint256 accRewardsPerShare; // Accumulated reward tokens per share, times 1e12. See below.\n\t\tuint32 vestingPercent; // Percentage of rewards that vest (measured in bips: 500,000 bips = 50% of rewards)\n\t\tuint16 vestingPeriod; // Vesting period in days for vesting rewards\n\t\tuint16 vestingCliff; // Vesting cliff in days for vesting rewards\n\t\tuint256 totalStaked; // Total amount of token staked via Rewards Manager\n\t\tbool vpForDeposit; // Should users gain voting power for depositing this token?\n\t\tbool vpForVesting; // Should users gain voting power for vesting this token?\n\t}\n\n\t/// @notice Reward token\n\tIERC20 public rewardToken;\n\n\t/// @notice SUSHI token\n\tIERC20 public sushiToken;\n\n\t/// @notice Sushi Master Chef\n\tIMasterChef public masterChef;\n\n\t/// @notice Vault for vesting tokens\n\tIVault public vault;\n\n\t/// @notice LockManager contract\n\tILockManager public lockManager;\n\n\t/// @notice Reward tokens rewarded per block.\n\tuint256 public rewardTokensPerBlock;\n\n\t/// @notice Info of each pool.\n\tPoolInfo[] public poolInfo;\n\n\t/// @notice Mapping of Sushi tokens to MasterChef pids\n\tmapping(address => uint256) public sushiPools;\n\n\t/// @notice Info of each user that stakes tokens.\n\tmapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n\t/// @notice Total allocation points. Must be the sum of all allocation points in all pools.\n\tuint256 public totalAllocPoint;\n\n\t/// @notice The block number when rewards start.\n\tuint256 public startBlock;\n\n\t/// @notice The block number when rewards end.\n\tuint256 public endBlock;\n\n\t/// @notice Current master of this contract\n\taddress public master;\n\n\t/// @notice Event emitted when a user deposits funds in the rewards manager\n\tevent Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n\n\t/// @notice Event emitted when a user withdraws their original funds + rewards from the rewards manager\n\tevent Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n\t/// @notice Event emitted when a user withdraws their original funds from the rewards manager without claiming rewards\n\tevent EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n\t/// @notice Event emitted when new pool is added to the rewards manager\n\tevent PoolAdded(\n\t\tuint256 indexed pid,\n\t\taddress indexed token,\n\t\tuint256 allocPoints,\n\t\tuint256 totalAllocPoints,\n\t\tuint256 rewardStartBlock,\n\t\tuint256 sushiPid,\n\t\tbool vpForDeposit,\n\t\tbool vpForVesting\n\t);\n\n\t/// @notice Event emitted when pool allocation points are updated\n\tevent PoolUpdated(uint256 indexed pid, uint256 oldAllocPoints, uint256 newAllocPoints, uint256 newTotalAllocPoints);\n\n\t/// @notice Event emitted when the master of the rewards manager contract is updated\n\tevent ChangedMaster(address indexed oldMaster, address indexed newMaster);\n\n\t/// @notice Event emitted when the amount of reward tokens per block is updated\n\tevent ChangedRewardTokensPerBlock(uint256 indexed oldRewardTokensPerBlock, uint256 indexed newRewardTokensPerBlock);\n\n\t/// @notice Event emitted when the rewards start block is set\n\tevent SetRewardsStartBlock(uint256 indexed startBlock);\n\n\t/// @notice Event emitted when the rewards end block is updated\n\tevent ChangedRewardsEndBlock(uint256 indexed oldEndBlock, uint256 indexed newEndBlock);\n\n\t/// @notice Event emitted when contract address is changed\n\tevent ChangedAddress(string indexed addressType, address indexed oldAddress, address indexed newAddress);\n\n\t/// @notice restrict functions to just master address\n\tmodifier onlyMaster {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(crown.king == address(0) || msg.sender == crown.king, \"Crown::onlyMaster: not the king\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice View function to see current poolInfo array length\n\t * @return pool length\n\t */\n\tfunction poolLength() external view returns (uint256) {\n\t\treturn poolInfo.length;\n\t}\n\n\t/**\n\t * @notice Add a new reward token to the pool\n\t * @dev Can only be called by the master. DO NOT add the same token more than once. Rewards will be messed up if you do.\n\t * @param allocPoint Number of allocation points to allot to this token/pool\n\t * @param token The token that will be staked for rewards\n\t * @param vestingPercent The percentage of rewards from this pool that will vest\n\t * @param vestingPeriod The number of days for the vesting period\n\t * @param vestingCliff The number of days for the vesting cliff\n\t * @param withUpdate if specified, update all pools before adding new pool\n\t * @param sushiPid The pid of the Sushiswap pool in the Masterchef contract (if exists, otherwise provide zero)\n\t * @param vpForDeposit If true, users get voting power for deposits\n\t * @param vpForVesting If true, users get voting power for vesting balances\n\t */\n\tfunction add(\n\t\tuint256 allocPoint,\n\t\taddress token,\n\t\tuint32 vestingPercent,\n\t\tuint16 vestingPeriod,\n\t\tuint16 vestingCliff,\n\t\tbool withUpdate,\n\t\tuint256 sushiPid,\n\t\tbool vpForDeposit,\n\t\tbool vpForVesting\n\t) external onlyMaster {\n\t\tif (withUpdate) {\n\t\t\tmassUpdatePools();\n\t\t}\n\t\tuint256 rewardStartBlock = block.number > startBlock ? block.number : startBlock;\n\t\tif (totalAllocPoint == 0) {\n\t\t\t_setRewardsEndBlock();\n\t\t}\n\t\ttotalAllocPoint = totalAllocPoint + allocPoint;\n\t\tpoolInfo.push(\n\t\t\tPoolInfo({\n\t\t\t\ttoken: IERC20(token),\n\t\t\t\tallocPoint: allocPoint,\n\t\t\t\tlastRewardBlock: rewardStartBlock,\n\t\t\t\taccRewardsPerShare: 0,\n\t\t\t\tvestingPercent: vestingPercent,\n\t\t\t\tvestingPeriod: vestingPeriod,\n\t\t\t\tvestingCliff: vestingCliff,\n\t\t\t\ttotalStaked: 0,\n\t\t\t\tvpForDeposit: vpForDeposit,\n\t\t\t\tvpForVesting: vpForVesting\n\t\t\t})\n\t\t);\n\t\tif (sushiPid != uint256(0)) {\n\t\t\tsushiPools[token] = sushiPid;\n\t\t\tIERC20(token).safeIncreaseAllowance(address(masterChef), type(uint256).max);\n\t\t}\n\t\tIERC20(token).safeIncreaseAllowance(address(vault), type(uint256).max);\n\t\temit PoolAdded(\n\t\t\tpoolInfo.length - 1,\n\t\t\ttoken,\n\t\t\tallocPoint,\n\t\t\ttotalAllocPoint,\n\t\t\trewardStartBlock,\n\t\t\tsushiPid,\n\t\t\tvpForDeposit,\n\t\t\tvpForVesting\n\t\t);\n\t}\n\n\t/**\n\t * @notice Update the given pool's allocation points\n\t * @dev Can only be called by the master\n\t * @param pid The RewardManager pool id\n\t * @param allocPoint New number of allocation points for pool\n\t * @param withUpdate if specified, update all pools before setting allocation points\n\t */\n\tfunction set(\n\t\tuint256 pid,\n\t\tuint256 allocPoint,\n\t\tbool withUpdate\n\t) external onlyMaster {\n\t\tif (withUpdate) {\n\t\t\tmassUpdatePools();\n\t\t}\n\t\ttotalAllocPoint = totalAllocPoint - poolInfo[pid].allocPoint + allocPoint;\n\t\temit PoolUpdated(pid, poolInfo[pid].allocPoint, allocPoint, totalAllocPoint);\n\t\tpoolInfo[pid].allocPoint = allocPoint;\n\t}\n\n\t/**\n\t * @notice View function to see pending reward tokens on frontend.\n\t * @param pid pool id\n\t * @param account user account to check\n\t * @return pending rewards\n\t */\n\tfunction pendingRewardTokens(uint256 pid, address account) external view returns (uint256) {\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tUserInfo storage user = userInfo[pid][account];\n\t\tuint256 accRewardsPerShare = pool.accRewardsPerShare;\n\t\tuint256 tokenSupply = pool.totalStaked;\n\t\tif (block.number > pool.lastRewardBlock && tokenSupply != 0) {\n\t\t\tuint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n\t\t\tuint256 totalReward = (multiplier * rewardTokensPerBlock * pool.allocPoint) / totalAllocPoint;\n\t\t\taccRewardsPerShare = accRewardsPerShare + (totalReward * 1e12) / tokenSupply;\n\t\t}\n\n\t\tuint256 accumulatedRewards = (user.amount * accRewardsPerShare) / 1e12;\n\n\t\tif (accumulatedRewards < user.rewardTokenDebt) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn accumulatedRewards - user.rewardTokenDebt;\n\t}\n\n\t/**\n\t * @notice View function to see pending SUSHI on frontend.\n\t * @param pid pool id\n\t * @param account user account to check\n\t * @return pending SUSHI rewards\n\t */\n\tfunction pendingSushi(uint256 pid, address account) external view returns (uint256) {\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tUserInfo storage user = userInfo[pid][account];\n\t\tuint256 sushiPid = sushiPools[address(pool.token)];\n\t\tif (sushiPid == uint256(0)) {\n\t\t\treturn 0;\n\t\t}\n\t\tIMasterChef.PoolInfo memory sushiPool = masterChef.poolInfo(sushiPid);\n\t\tuint256 sushiPerBlock = masterChef.sushiPerBlock();\n\t\tuint256 totalSushiAllocPoint = masterChef.totalAllocPoint();\n\t\tuint256 accSushiPerShare = sushiPool.accSushiPerShare;\n\t\tuint256 lpSupply = sushiPool.lpToken.balanceOf(address(masterChef));\n\t\tif (block.number > sushiPool.lastRewardBlock && lpSupply != 0) {\n\t\t\tuint256 multiplier = masterChef.getMultiplier(sushiPool.lastRewardBlock, block.number);\n\t\t\tuint256 sushiReward = (multiplier * sushiPerBlock * sushiPool.allocPoint) / totalSushiAllocPoint;\n\t\t\taccSushiPerShare = accSushiPerShare + (sushiReward * 1e12) / lpSupply;\n\t\t}\n\n\t\tuint256 accumulatedSushi = (user.amount * accSushiPerShare) / 1e12;\n\n\t\tif (accumulatedSushi < user.sushiRewardDebt) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn accumulatedSushi - user.sushiRewardDebt;\n\t}\n\n\t/**\n\t * @notice Update reward variables for all pools\n\t * @dev Be careful of gas spending!\n\t */\n\tfunction massUpdatePools() public {\n\t\tfor (uint256 pid = 0; pid < poolInfo.length; ++pid) {\n\t\t\tupdatePool(pid);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Update reward variables of the given pool to be up-to-date\n\t * @param pid pool id\n\t */\n\tfunction updatePool(uint256 pid) public {\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tif (block.number <= pool.lastRewardBlock) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 tokenSupply = pool.totalStaked;\n\t\tif (tokenSupply == 0) {\n\t\t\tpool.lastRewardBlock = block.number;\n\t\t\treturn;\n\t\t}\n\t\tuint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n\t\tuint256 totalReward = (multiplier * rewardTokensPerBlock * pool.allocPoint) / totalAllocPoint;\n\t\tpool.accRewardsPerShare = pool.accRewardsPerShare + (totalReward * 1e12) / tokenSupply;\n\t\tpool.lastRewardBlock = block.number;\n\t}\n\n\t/**\n\t * @notice Deposit tokens to Dragon for rewards allocation.\n\t * @param pid pool id\n\t * @param amount number of tokens to deposit\n\t */\n\tfunction deposit(uint256 pid, uint256 amount) external nonReentrant {\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tUserInfo storage user = userInfo[pid][msg.sender];\n\t\t_deposit(pid, amount, pool, user);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to Dragon for rewards allocation, using permit for approval\n\t * @dev It is up to the frontend developer to ensure the pool token implements permit - otherwise this will fail\n\t * @param pid pool id\n\t * @param amount number of tokens to deposit\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\n\tfunction depositWithPermit(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external nonReentrant {\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tUserInfo storage user = userInfo[pid][msg.sender];\n\t\t// TODO: find the best way to provide a richer ERC20 interface here\n\t\t// pool.token.permit(msg.sender, address(this), amount, deadline, v, r, s);\n\t\t// _deposit(pid, amount, pool, user);\n\t\tconsole.log(\"Dragon::depositWithPermit: not supported atm\");\n\t}*/\n\n\t/**\n\t * @notice Withdraw tokens from Dragon, claiming rewards.\n\t * @param pid pool id\n\t * @param amount number of tokens to withdraw\n\t */\n\tfunction withdraw(uint256 pid, uint256 amount) external nonReentrant {\n\t\trequire(amount > 0, \"Dragon::withdraw: amount must be > 0\");\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tUserInfo storage user = userInfo[pid][msg.sender];\n\t\t_withdraw(pid, amount, pool, user);\n\t}\n\n\t/**\n\t * @notice Set approvals for external addresses to use contract tokens\n\t * @dev Can only be called by the master\n\t * @param tokensToApprove the tokens to approve\n\t * @param approvalAmounts the token approval amounts\n\t * @param spender the address to allow spending of token\n\t */\n\tfunction tokenAllow(\n\t\taddress[] memory tokensToApprove,\n\t\tuint256[] memory approvalAmounts,\n\t\taddress spender\n\t) external onlyMaster {\n\t\trequire(tokensToApprove.length == approvalAmounts.length, \"Dragon::tokenAllow: not same length\");\n\t\tfor (uint256 i = 0; i < tokensToApprove.length; i++) {\n\t\t\tIERC20 token = IERC20(tokensToApprove[i]);\n\t\t\tif (token.allowance(address(this), spender) != type(uint256).max) {\n\t\t\t\ttoken.safeApprove(spender, approvalAmounts[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Rescue (withdraw) tokens from the smart contract\n\t * @dev Can only be called by the master\n\t * @param tokens the tokens to withdraw\n\t * @param amounts the amount of each token to withdraw.  If zero, withdraws the maximum allowed amount for each token\n\t * @param receiver the address that will receive the tokens\n\t * @param updateRewardsEndBlock if true, update the rewards end block after performing transfers\n\t */\n\tfunction rescueTokens(\n\t\taddress[] calldata tokens,\n\t\tuint256[] calldata amounts,\n\t\taddress receiver,\n\t\tbool updateRewardsEndBlock\n\t) external onlyMaster {\n\t\trequire(tokens.length == amounts.length, \"Dragon::rescueTokens: not same length\");\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\tIERC20 token = IERC20(tokens[i]);\n\t\t\tuint256 withdrawalAmount;\n\t\t\tuint256 tokenBalance = token.balanceOf(address(this));\n\t\t\tuint256 tokenAllowance = token.allowance(address(this), receiver);\n\t\t\tif (amounts[i] == 0) {\n\t\t\t\tif (tokenBalance > tokenAllowance) {\n\t\t\t\t\twithdrawalAmount = tokenAllowance;\n\t\t\t\t} else {\n\t\t\t\t\twithdrawalAmount = tokenBalance;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trequire(tokenBalance >= amounts[i], \"Dragon::rescueTokens: contract balance too low\");\n\t\t\t\trequire(tokenAllowance >= amounts[i], \"Dragon::rescueTokens: increase token allowance\");\n\t\t\t\twithdrawalAmount = amounts[i];\n\t\t\t}\n\t\t\ttoken.safeTransferFrom(address(this), receiver, withdrawalAmount);\n\t\t}\n\n\t\tif (updateRewardsEndBlock) {\n\t\t\t_setRewardsEndBlock();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n\t * @param pid pool id\n\t */\n\tfunction emergencyWithdraw(uint256 pid) external nonReentrant {\n\t\tPoolInfo storage pool = poolInfo[pid];\n\t\tUserInfo storage user = userInfo[pid][msg.sender];\n\n\t\tif (user.amount > 0) {\n\t\t\tuint256 sushiPid = sushiPools[address(pool.token)];\n\t\t\tif (sushiPid != uint256(0)) {\n\t\t\t\tmasterChef.withdraw(sushiPid, user.amount);\n\t\t\t}\n\n\t\t\tif (pool.vpForDeposit) {\n\t\t\t\tlockManager.removeVotingPower(msg.sender, address(pool.token), user.amount);\n\t\t\t}\n\n\t\t\tpool.totalStaked = pool.totalStaked - user.amount;\n\t\t\tpool.token.safeTransfer(msg.sender, user.amount);\n\n\t\t\temit EmergencyWithdraw(msg.sender, pid, user.amount);\n\n\t\t\tuser.amount = 0;\n\t\t\tuser.rewardTokenDebt = 0;\n\t\t\tuser.sushiRewardDebt = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Add rewards to contract\n\t * @dev Can only be called by the master\n\t * @param amount amount of tokens to add\n\t */\n\tfunction addRewardsBalance(uint256 amount) external onlyMaster {\n\t\trewardToken.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_setRewardsEndBlock();\n\t}\n\n\t/**\n\t * @notice Reset rewards end block manually based on new balances\n\t */\n\tfunction resetRewardsEndBlock() external onlyMaster {\n\t\t_setRewardsEndBlock();\n\t}\n\n\t/**\n\t * @notice Returns true if rewards are actively being accumulated\n\t */\n\tfunction rewardsActive() public view returns (bool) {\n\t\treturn block.number >= startBlock && block.number <= endBlock && totalAllocPoint > 0 ? true : false;\n\t}\n\n\t/**\n\t * @notice Return reward multiplier over the given from to to block.\n\t * @param from From block number\n\t * @param to To block number\n\t * @return multiplier\n\t */\n\tfunction getMultiplier(uint256 from, uint256 to) public view returns (uint256) {\n\t\tuint256 toBlock = to > endBlock ? endBlock : to;\n\t\treturn toBlock > from ? toBlock - from : 0;\n\t}\n\n\t/**\n\t * @notice Internal implementation of deposit\n\t * @param pid pool id\n\t * @param amount number of tokens to deposit\n\t * @param pool the pool info\n\t * @param user the user info\n\t */\n\tfunction _deposit(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\tPoolInfo storage pool,\n\t\tUserInfo storage user\n\t) internal {\n\t\tupdatePool(pid);\n\n\t\tuint256 sushiPid = sushiPools[address(pool.token)];\n\t\tuint256 pendingSushiTokens = 0;\n\n\t\tif (user.amount > 0) {\n\t\t\tuint256 pendingRewards = (user.amount * pool.accRewardsPerShare) / 1e12 - user.rewardTokenDebt;\n\n\t\t\tif (pendingRewards > 0) {\n\t\t\t\t_distributeRewards(\n\t\t\t\t\tmsg.sender,\n\t\t\t\t\tpendingRewards,\n\t\t\t\t\tpool.vestingPercent,\n\t\t\t\t\tpool.vestingPeriod,\n\t\t\t\t\tpool.vestingCliff,\n\t\t\t\t\tpool.vpForVesting\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (sushiPid != uint256(0)) {\n\t\t\t\tmasterChef.updatePool(sushiPid);\n\t\t\t\tpendingSushiTokens =\n\t\t\t\t\t(user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare) /\n\t\t\t\t\t1e12 -\n\t\t\t\t\tuser.sushiRewardDebt;\n\t\t\t}\n\t\t}\n\n\t\tpool.token.safeTransferFrom(msg.sender, address(this), amount);\n\t\tpool.totalStaked = pool.totalStaked + amount;\n\t\tuser.amount = user.amount + amount;\n\t\tuser.rewardTokenDebt = (user.amount * pool.accRewardsPerShare) / 1e12;\n\n\t\tif (sushiPid != uint256(0)) {\n\t\t\tmasterChef.updatePool(sushiPid);\n\t\t\tuser.sushiRewardDebt = (user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare) / 1e12;\n\t\t\tmasterChef.deposit(sushiPid, amount);\n\t\t}\n\n\t\tif (amount > 0 && pool.vpForDeposit) {\n\t\t\tlockManager.grantVotingPower(msg.sender, address(pool.token), amount);\n\t\t}\n\n\t\tif (pendingSushiTokens > 0) {\n\t\t\t_safeSushiTransfer(msg.sender, pendingSushiTokens);\n\t\t}\n\n\t\temit Deposit(msg.sender, pid, amount);\n\t}\n\n\t/**\n\t * @notice Internal implementation of withdraw\n\t * @param pid pool id\n\t * @param amount number of tokens to withdraw\n\t * @param pool the pool info\n\t * @param user the user info\n\t */\n\tfunction _withdraw(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\tPoolInfo storage pool,\n\t\tUserInfo storage user\n\t) internal {\n\t\trequire(user.amount >= amount, \"Dragon::_withdraw: amount > user balance\");\n\n\t\tupdatePool(pid);\n\n\t\tuint256 sushiPid = sushiPools[address(pool.token)];\n\n\t\tif (sushiPid != uint256(0)) {\n\t\t\tmasterChef.updatePool(sushiPid);\n\t\t\tuint256 pendingSushiTokens =\n\t\t\t\t(user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare) / 1e12 - user.sushiRewardDebt;\n\t\t\tmasterChef.withdraw(sushiPid, amount);\n\t\t\tuser.sushiRewardDebt = user.amount - (amount * masterChef.poolInfo(sushiPid).accSushiPerShare) / 1e12;\n\t\t\tif (pendingSushiTokens > 0) {\n\t\t\t\t_safeSushiTransfer(msg.sender, pendingSushiTokens);\n\t\t\t}\n\t\t}\n\n\t\tuint256 pendingRewards = (user.amount * pool.accRewardsPerShare) / 1e12 - user.rewardTokenDebt;\n\t\tuser.amount = user.amount - amount;\n\t\tuser.rewardTokenDebt = (user.amount * pool.accRewardsPerShare) / 1e12;\n\n\t\tif (pendingRewards > 0) {\n\t\t\t_distributeRewards(\n\t\t\t\tmsg.sender,\n\t\t\t\tpendingRewards,\n\t\t\t\tpool.vestingPercent,\n\t\t\t\tpool.vestingPeriod,\n\t\t\t\tpool.vestingCliff,\n\t\t\t\tpool.vpForVesting\n\t\t\t);\n\t\t}\n\n\t\tif (pool.vpForDeposit) {\n\t\t\tlockManager.removeVotingPower(msg.sender, address(pool.token), amount);\n\t\t}\n\n\t\tpool.totalStaked = pool.totalStaked - amount;\n\t\tpool.token.safeTransfer(msg.sender, amount);\n\n\t\temit Withdraw(msg.sender, pid, amount);\n\t}\n\n\t/**\n\t * @notice Internal function used to distribute rewards, optionally vesting a %\n\t * @param account account that is due rewards\n\t * @param amount amount of rewards to distribute\n\t * @param vestingPercent percent of rewards to vest in bips\n\t * @param vestingPeriod number of days over which to vest rewards\n\t * @param vestingCliff number of days for vesting cliff\n\t * @param vestingVotingPower if true, grant voting power for vesting balance\n\t */\n\tfunction _distributeRewards(\n\t\taddress account,\n\t\tuint256 amount,\n\t\tuint32 vestingPercent,\n\t\tuint16 vestingPeriod,\n\t\tuint16 vestingCliff,\n\t\tbool vestingVotingPower\n\t) internal {\n\t\tuint256 rewardAmount =\n\t\t\tamount > rewardToken.balanceOf(address(this)) ? rewardToken.balanceOf(address(this)) : amount;\n\t\tuint256 vestingRewards = (rewardAmount * vestingPercent) / 1000000;\n\t\tvault.lockTokens(\n\t\t\taddress(rewardToken),\n\t\t\taddress(this),\n\t\t\taccount,\n\t\t\t0,\n\t\t\tvestingRewards,\n\t\t\tvestingPeriod,\n\t\t\tvestingCliff,\n\t\t\tvestingVotingPower\n\t\t);\n\t\t_safeRewardsTransfer(msg.sender, rewardAmount - vestingRewards);\n\t}\n\n\t/**\n\t * @notice Safe reward transfer function, just in case if rounding error causes pool to not have enough reward token.\n\t * @param to account that is receiving rewards\n\t * @param amount amount of rewards to send\n\t */\n\tfunction _safeRewardsTransfer(address to, uint256 amount) internal {\n\t\tuint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\n\t\tif (amount > rewardTokenBalance) {\n\t\t\trewardToken.safeTransfer(to, rewardTokenBalance);\n\t\t} else {\n\t\t\trewardToken.safeTransfer(to, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Safe SUSHI transfer function, just in case if rounding error causes pool to not have enough SUSHI.\n\t * @param to account that is receiving SUSHI\n\t * @param amount amount of SUSHI to send\n\t */\n\tfunction _safeSushiTransfer(address to, uint256 amount) internal {\n\t\tuint256 sushiBalance = sushiToken.balanceOf(address(this));\n\t\tif (amount > sushiBalance) {\n\t\t\tsushiToken.safeTransfer(to, sushiBalance);\n\t\t} else {\n\t\t\tsushiToken.safeTransfer(to, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Internal function that updates rewards end block based on tokens per block and the token balance\n\t *         of the contract\n\t */\n\tfunction _setRewardsEndBlock() internal {\n\t\tif (rewardTokensPerBlock > 0) {\n\t\t\tuint256 rewardFromBlock = block.number >= startBlock ? block.number : startBlock;\n\t\t\tuint256 newEndBlock = rewardFromBlock + rewardToken.balanceOf(address(this)) / rewardTokensPerBlock;\n\t\t\tif (newEndBlock > rewardFromBlock && newEndBlock != endBlock) {\n\t\t\t\temit ChangedRewardsEndBlock(endBlock, newEndBlock);\n\t\t\t\tendBlock = newEndBlock;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/governance/LibCrownStorage.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"../../interfaces/governance/ICrownGovernanceToken.sol\";\nimport \"../../interfaces/governance/IVesting.sol\";\nimport \"../../interfaces/governance/ITokenRegistry.sol\";\n\n/// @notice Crown governance storage\nstruct CrownStorage {\n\t// A record of states for signing / validating signatures\n\tmapping(address => uint256) nonces;\n\t// Crown governance token\n\tICrownGovernanceToken govToken;\n\t// Vesting contract\n\tIVesting vesting;\n\t// Crown owner\n\taddress king;\n\t// lockManager contract\n\taddress lockManager;\n\t// Token registry contract\n\tITokenRegistry tokenRegistry;\n}\n\n/// @notice A checkpoint for marking number of votes from a given block\nstruct CrownCheckpoint {\n\tuint32 fromBlock;\n\tuint256 votes;\n}\n\n/// @notice All storage variables related to checkpoints\nstruct CrownCheckpointStorage {\n\t// A record of vote checkpoints for each account, by index\n\tmapping(address => mapping(uint32 => CrownCheckpoint)) checkpoints;\n\t// The number of checkpoints for each account\n\tmapping(address => uint32) numCheckpoints;\n}\n\n/// @notice The amount of a given token that has been staked, and the resulting voting power\nstruct CrownStake {\n\tuint256 amount;\n\tuint256 votingPower;\n\t// TODO: delegation?\n\t// uint256 expiryTimestamp;\n\t// address delegatedTo;\n}\n\n/// @notice All storage variables related to staking\nstruct CrownStakeStorage {\n\t// Official record of staked balances for each account > token > stake\n\tmapping(address => mapping(address => CrownStake)) stakes;\n}\n\nlibrary LibCrownStorage {\n\tbytes32 constant CROWN_GOVERNANCE_STORAGE = keccak256(\"kingmaker.crown.governance.storage\");\n\tbytes32 constant CROWN_CHECKPOINT_STORAGE = keccak256(\"kingmaker.crown.checkpoint.storage\");\n\tbytes32 constant CROWN_STAKE_STORAGE = keccak256(\"kingmaker.crown.stake.storage\");\n\n\t/**\n\t * @notice Load app storage struct from specified VOTING_POWER_APP_STORAGE_POSITION\n\t * @return crown CrownGovernance struct\n\t */\n\tfunction crownStorage() internal pure returns (CrownStorage storage crown) {\n\t\tbytes32 position = CROWN_GOVERNANCE_STORAGE;\n\t\tassembly {\n\t\t\tcrown.slot := position\n\t\t}\n\t}\n\n\t/**\n\t * @notice Load checkpoint storage struct from specified VOTING_POWER_CHECKPOINT_STORAGE_POSITION\n\t * @return checkpoint CheckpointStorage struct\n\t */\n\tfunction checkpointStorage() internal pure returns (CrownCheckpointStorage storage checkpoint) {\n\t\tbytes32 position = CROWN_CHECKPOINT_STORAGE;\n\t\tassembly {\n\t\t\tcheckpoint.slot := position\n\t\t}\n\t}\n\n\t/**\n\t * @notice Load stake storage struct from specified VOTING_POWER_STAKE_STORAGE_POSITION\n\t * @return stake StakeStorage struct\n\t */\n\tfunction stakeStorage() internal pure returns (CrownStakeStorage storage stake) {\n\t\tbytes32 position = CROWN_STAKE_STORAGE;\n\t\tassembly {\n\t\t\tstake.slot := position\n\t\t}\n\t}\n}\n"
    },
    "contracts/interfaces/governance/ILockManager.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\ninterface ILockManager {\n\tstruct LockedStake {\n\t\tuint256 amount;\n\t\tuint256 votingPower;\n\t}\n\n\tfunction getAmountStaked(address staker, address stakedToken) external view returns (uint256);\n\n\tfunction getStake(address staker, address stakedToken) external view returns (LockedStake memory);\n\n\tfunction calculateVotingPower(address token, uint256 amount) external view returns (uint256);\n\n\tfunction grantVotingPower(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 tokenAmount\n\t) external returns (uint256 votingPowerGranted);\n\n\tfunction removeVotingPower(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 tokenAmount\n\t) external returns (uint256 votingPowerRemoved);\n}\n"
    },
    "contracts/interfaces/governance/IMasterChef.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// TODO: this should be modified to permanently lock liquidity (see https://github.com/ARM-Finance/kingmaker/issues/15)\ninterface IMasterChef {\n\tstruct PoolInfo {\n\t\tIERC20 lpToken; // Address of LP token contract.\n\t\tuint256 allocPoint; // How many allocation points assigned to this pool. SUSHIs to distribute per block.\n\t\tuint256 lastRewardBlock; // Last block number that SUSHIs distribution occurs.\n\t\tuint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12.\n\t}\n\n\tfunction deposit(uint256 _pid, uint256 _amount) external;\n\n\tfunction withdraw(uint256 _pid, uint256 _amount) external;\n\n\tfunction poolInfo(uint256 _pid) external view returns (PoolInfo memory);\n\n\tfunction pendingSushi(uint256 _pid, address _user) external view returns (uint256);\n\n\tfunction updatePool(uint256 _pid) external;\n\n\tfunction sushiPerBlock() external view returns (uint256);\n\n\tfunction totalAllocPoint() external view returns (uint256);\n\n\tfunction getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/governance/IVault.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\ninterface IVault {\n\tstruct Lock {\n\t\taddress token;\n\t\taddress receiver;\n\t\tuint48 startTime;\n\t\tuint16 vestingDurationInDays;\n\t\tuint16 cliffDurationInDays;\n\t\tuint256 amount;\n\t\tuint256 amountClaimed;\n\t\tuint256 votingPower;\n\t}\n\n\tstruct LockBalance {\n\t\tuint256 id;\n\t\tuint256 claimableAmount;\n\t\tLock lock;\n\t}\n\n\tstruct TokenBalance {\n\t\tuint256 totalAmount;\n\t\tuint256 claimableAmount;\n\t\tuint256 claimedAmount;\n\t\tuint256 votingPower;\n\t}\n\n\tfunction lockTokens(\n\t\taddress token,\n\t\taddress locker,\n\t\taddress receiver,\n\t\tuint48 startTime,\n\t\tuint256 amount,\n\t\tuint16 lockDurationInDays,\n\t\tuint16 cliffDurationInDays,\n\t\tbool grantVotingPower\n\t) external;\n\n\tfunction lockTokensWithPermit(\n\t\taddress token,\n\t\taddress locker,\n\t\taddress receiver,\n\t\tuint48 startTime,\n\t\tuint256 amount,\n\t\tuint16 lockDurationInDays,\n\t\tuint16 cliffDurationInDays,\n\t\tbool grantVotingPower,\n\t\tuint256 deadline,\n\t\tbytes memory signature // Prevents CompilerError: Stack too deep when having more than 11 function parameters\n\t) external;\n\n\tfunction claimUnlockedTokenAmounts(uint256[] memory lockIds, uint256[] memory amounts) external;\n\n\tfunction claimAllUnlockedTokens(uint256[] memory lockIds) external;\n\n\tfunction allActiveLockIds() external view returns (uint256[] memory);\n\n\tfunction allActiveLocks() external view returns (Lock[] memory);\n\n\tfunction allActiveLockBalances() external view returns (LockBalance[] memory);\n\n\tfunction activeLockIds(address receiver) external view returns (uint256[] memory);\n\n\tfunction allLocks(address receiver) external view returns (Lock[] memory);\n\n\tfunction activeLocks(address receiver) external view returns (Lock[] memory);\n\n\tfunction activeLockBalances(address receiver) external view returns (LockBalance[] memory);\n\n\tfunction totalTokenBalance(address token) external view returns (TokenBalance memory balance);\n\n\tfunction tokenBalance(address token, address receiver) external view returns (TokenBalance memory balance);\n\n\tfunction lockBalance(uint256 lockId) external view returns (LockBalance memory);\n\n\tfunction claimableBalance(uint256 lockId) external view returns (uint256);\n\n\tfunction extendLock(\n\t\tuint256 lockId,\n\t\tuint16 vestingDaysToAdd,\n\t\tuint16 cliffDaysToAdd\n\t) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/governance/IVesting.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./ICrownGovernanceToken.sol\";\nimport \"./IVotingPower.sol\";\n\ninterface IVesting {\n\tstruct Grant {\n\t\tuint256 startTime;\n\t\tuint256 amount;\n\t\tuint16 vestingDuration;\n\t\tuint16 vestingCliff;\n\t\tuint256 totalClaimed;\n\t}\n\n\tevent GrantAdded(\n\t\taddress indexed recipient,\n\t\tuint256 indexed amount,\n\t\tuint256 startTime,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 vestingCliffInDays\n\t);\n\tevent GrantTokensClaimed(address indexed recipient, uint256 indexed amountClaimed);\n\tevent ChangedOwner(address indexed oldOwner, address indexed newOwner);\n\tevent ChangedVotingPower(address indexed oldContract, address indexed newContract);\n\n\tfunction owner() external view returns (address);\n\n\tfunction token() external view returns (ICrownGovernanceToken);\n\n\tfunction votingPower() external view returns (IVotingPower);\n\n\tfunction addTokenGrant(\n\t\taddress recipient,\n\t\tuint256 startTime,\n\t\tuint256 amount,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 vestingCliffInDays\n\t) external;\n\n\tfunction getTokenGrant(address recipient) external view returns (Grant memory);\n\n\tfunction calculateGrantClaim(address recipient) external view returns (uint256);\n\n\tfunction vestedBalance(address account) external view returns (uint256);\n\n\tfunction claimedBalance(address recipient) external view returns (uint256);\n\n\tfunction claimVestedTokens(address recipient) external;\n\n\tfunction tokensVestedPerDay(address recipient) external view returns (uint256);\n\n\tfunction setVotingPowerContract(address newContract) external;\n\n\tfunction changeOwner(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/governance/ITokenRegistry.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\ninterface ITokenRegistry {\n\t/// @notice Event emitted when a new token is supported\n\tevent TokenFormulaAdded(address indexed token, address indexed formula);\n\t/// @notice Event emitted when a token formula is updated\n\tevent TokenFormulaUpdated(address indexed token, address indexed formula);\n\t/// @notice Event emitted when a supported token is removed\n\tevent TokenFormulaRemoved(address indexed token);\n\n\tfunction tokenFormula(address) external view returns (address);\n\n\tfunction setTokenFormula(address token, address formula) external;\n\n\tfunction removeToken(address token) external;\n\n\tfunction changeOwner(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/governance/IVotingPower.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"../../libraries/governance/PrismProxy.sol\";\n\ninterface IVotingPower {\n\tstruct Stake {\n\t\tuint256 amount;\n\t\tuint256 votingPower;\n\t}\n\n\tevent NewPendingImplementation(address indexed oldPendingImplementation, address indexed newPendingImplementation);\n\tevent NewImplementation(address indexed oldImplementation, address indexed newImplementation);\n\tevent NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\tevent NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\t// TODO: should be able to trim around here, if used as Facet in a Diamond\n\tevent Staked(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\tevent Withdrawn(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\tevent VotingPowerChanged(address indexed voter, uint256 indexed previousBalance, uint256 indexed newBalance);\n\n\tfunction setPendingProxyImplementation(address newPendingImplementation) external returns (bool);\n\n\tfunction acceptProxyImplementation() external returns (bool);\n\n\tfunction setPendingProxyAdmin(address newPendingAdmin) external returns (bool);\n\n\tfunction acceptProxyAdmin() external returns (bool);\n\n\tfunction proxyAdmin() external view returns (address);\n\n\tfunction pendingProxyAdmin() external view returns (address);\n\n\tfunction proxyImplementation() external view returns (address);\n\n\tfunction pendingProxyImplementation() external view returns (address);\n\n\tfunction proxyImplementationVersion() external view returns (uint8);\n\n\tfunction become(PrismProxy prism) external;\n\n\t// TODO: should be able to trim around here, if used as Facet in a Diamond\n\tfunction initialize(address _govToken, address _vestingContract) external;\n\n\tfunction owner() external view returns (address);\n\n\tfunction govToken() external view returns (address);\n\n\tfunction vestingContract() external view returns (address);\n\n\tfunction tokenRegistry() external view returns (address);\n\n\tfunction lockManager() external view returns (address);\n\n\tfunction changeOwner(address newOwner) external;\n\n\tfunction setTokenRegistry(address registry) external;\n\n\tfunction setLockManager(address newLockManager) external;\n\n\tfunction stake(uint256 amount) external;\n\n\tfunction stakeWithPermit(\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tfunction withdraw(uint256 amount) external;\n\n\tfunction addVotingPowerForVestingTokens(address account, uint256 amount) external;\n\n\tfunction removeVotingPowerForClaimedTokens(address account, uint256 amount) external;\n\n\tfunction addVotingPowerForLockedTokens(address account, uint256 amount) external;\n\n\tfunction removeVotingPowerForUnlockedTokens(address account, uint256 amount) external;\n\n\tfunction getCrownTokenAmountStaked(address staker) external view returns (uint256);\n\n\tfunction getAmountStaked(address staker, address stakedToken) external view returns (uint256);\n\n\tfunction getCrownTokenStake(address staker) external view returns (Stake memory);\n\n\tfunction getStake(address staker, address stakedToken) external view returns (Stake memory);\n\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\tfunction balanceOfAt(address account, uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/governance/PrismProxy.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * Older proxy implementation\n */\ncontract PrismProxy {\n\t/// @notice Proxy admin and implementation storage variables\n\tstruct ProxyStorage {\n\t\t// Administrator for this contract\n\t\taddress admin;\n\t\t// Pending administrator for this contract\n\t\taddress pendingAdmin;\n\t\t// Active implementation of this contract\n\t\taddress implementation;\n\t\t// Pending implementation of this contract\n\t\taddress pendingImplementation;\n\t\t// Implementation version of this contract\n\t\tuint8 version;\n\t}\n\n\t/// @dev Position in contract storage where prism ProxyStorage struct will be stored\n\tbytes32 constant PRISM_PROXY_STORAGE_POSITION = keccak256(\"prism.proxy.storage\");\n\n\t/// @notice Emitted when pendingImplementation is changed\n\tevent NewPendingImplementation(address indexed oldPendingImplementation, address indexed newPendingImplementation);\n\n\t/// @notice Emitted when pendingImplementation is accepted, which means implementation is updated\n\tevent NewImplementation(address indexed oldImplementation, address indexed newImplementation);\n\n\t/// @notice Emitted when pendingAdmin is changed\n\tevent NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n\t/// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n\tevent NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n\t/**\n\t * @notice Load proxy storage struct from specified PRISM_PROXY_STORAGE_POSITION\n\t * @return ps ProxyStorage struct\n\t */\n\tfunction proxyStorage() internal pure returns (ProxyStorage storage ps) {\n\t\tbytes32 position = PRISM_PROXY_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tps.slot := position\n\t\t}\n\t}\n\n\t// Admin Functions //\n\n\t/**\n\t * @notice Create new pending implementation for prism. msg.sender must be admin\n\t * @dev Admin function for proposing new implementation contract\n\t * @return boolean indicating success of operation\n\t */\n\tfunction setPendingProxyImplementation(address newPendingImplementation) public returns (bool) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\trequire(msg.sender == s.admin, \"Prism::setPendingProxyImp: caller must be admin\");\n\n\t\taddress oldPendingImplementation = s.pendingImplementation;\n\n\t\ts.pendingImplementation = newPendingImplementation;\n\n\t\temit NewPendingImplementation(oldPendingImplementation, s.pendingImplementation);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Accepts new implementation for prism. msg.sender must be pendingImplementation\n\t * @dev Admin function for new implementation to accept it's role as implementation\n\t * @return boolean indicating success of operation\n\t */\n\tfunction acceptProxyImplementation() public returns (bool) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\t// Check caller is pendingImplementation and pendingImplementation  address(0)\n\t\trequire(\n\t\t\tmsg.sender == s.pendingImplementation && s.pendingImplementation != address(0),\n\t\t\t\"Prism::acceptProxyImp: caller must be pending implementation\"\n\t\t);\n\n\t\t// Save current values for inclusion in log\n\t\taddress oldImplementation = s.implementation;\n\t\taddress oldPendingImplementation = s.pendingImplementation;\n\n\t\ts.implementation = s.pendingImplementation;\n\n\t\ts.pendingImplementation = address(0);\n\t\ts.version++;\n\n\t\temit NewImplementation(oldImplementation, s.implementation);\n\t\temit NewPendingImplementation(oldPendingImplementation, s.pendingImplementation);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Begins transfer of admin rights. The newPendingAdmin must call `acceptAdmin` to finalize the transfer.\n\t * @dev Admin function to begin change of admin. The newPendingAdmin must call `acceptAdmin` to finalize the transfer.\n\t * @param newPendingAdmin New pending admin.\n\t * @return boolean indicating success of operation\n\t */\n\tfunction setPendingProxyAdmin(address newPendingAdmin) public returns (bool) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\t// Check caller = admin\n\t\trequire(msg.sender == s.admin, \"Prism::setPendingProxyAdmin: caller must be admin\");\n\n\t\t// Save current value, if any, for inclusion in log\n\t\taddress oldPendingAdmin = s.pendingAdmin;\n\n\t\t// Store pendingAdmin with value newPendingAdmin\n\t\ts.pendingAdmin = newPendingAdmin;\n\n\t\t// Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\t\temit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n\t * @dev Admin function for pending admin to accept role and update admin\n\t * @return boolean indicating success of operation\n\t */\n\tfunction acceptProxyAdmin() public returns (bool) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\t// Check caller is pendingAdmin and pendingAdmin  address(0)\n\t\trequire(\n\t\t\tmsg.sender == s.pendingAdmin && msg.sender != address(0),\n\t\t\t\"Prism::acceptProxyAdmin: caller must be pending admin\"\n\t\t);\n\n\t\t// Save current values for inclusion in log\n\t\taddress oldAdmin = s.admin;\n\t\taddress oldPendingAdmin = s.pendingAdmin;\n\n\t\t// Store admin with value pendingAdmin\n\t\ts.admin = s.pendingAdmin;\n\n\t\t// Clear the pending value\n\t\ts.pendingAdmin = address(0);\n\n\t\temit NewAdmin(oldAdmin, s.admin);\n\t\temit NewPendingAdmin(oldPendingAdmin, s.pendingAdmin);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Get current admin for prism proxy\n\t * @return admin address\n\t */\n\tfunction proxyAdmin() public view returns (address) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\treturn s.admin;\n\t}\n\n\t/**\n\t * @notice Get pending admin for prism proxy\n\t * @return admin address\n\t */\n\tfunction pendingProxyAdmin() public view returns (address) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\treturn s.pendingAdmin;\n\t}\n\n\t/**\n\t * @notice Address of implementation contract\n\t * @return implementation address\n\t */\n\tfunction proxyImplementation() public view returns (address) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\treturn s.implementation;\n\t}\n\n\t/**\n\t * @notice Address of pending implementation contract\n\t * @return pending implementation address\n\t */\n\tfunction pendingProxyImplementation() public view returns (address) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\treturn s.pendingImplementation;\n\t}\n\n\t/**\n\t * @notice Current implementation version for proxy\n\t * @return version number\n\t */\n\tfunction proxyImplementationVersion() public view returns (uint8) {\n\t\tProxyStorage storage s = proxyStorage();\n\t\treturn s.version;\n\t}\n\n\t/**\n\t * @notice Delegates execution to an implementation contract.\n\t * @dev Returns to the external caller whatever the implementation returns or forwards reverts\n\t */\n\tfunction _forwardToImplementation() internal {\n\t\tProxyStorage storage s = proxyStorage();\n\t\t// delegate all other functions to current implementation\n\t\t(bool success, ) = s.implementation.delegatecall(msg.data);\n\n\t\tassembly {\n\t\t\tlet free_mem_ptr := mload(0x40)\n\t\t\treturndatacopy(free_mem_ptr, 0, returndatasize())\n\n\t\t\tswitch success\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(free_mem_ptr, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(free_mem_ptr, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/governance/Treasury.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n                           .=\"\"_;=.\n                       ,-\"_,=\"\"     `\"=.\n                       \"=._o`\"-._        `\"=.\n                           `\"=._o`\"=._      _`\"=._\n                                :=._o \"=._.\"_.-=\"'\"=.\n                         __.--\" , ; `\"=._o.\" ,-\"\"\"-._ \".\n                      ._\"  ,. .` ` `` ,  `\"-._\"-._   \". '\n                      |o`\"=._` , \"` `; .\". ,  \"-._\"-._; ;\n                      | ;`-.o`\"=._; .\" ` '`.\"\\` . \"-._ /\n                      |o;    `\"-.o`\"=._``  '` \" ,__.--o;\n                      | ;     (#) `-.o `\"=.`_.--\"_o.-; ;\n                      |o;._    \"      `\".o|o_.--\"    ;o;\n                       \"=._o--._        ; | ;        ; ;\n                            \"=._o--._   ;o|o;     _._;o;\n                                 \"=._o._; | ;_.--\"o.--\"\n                                      \"=.o|o_.--\"\"\n\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/governance/ILockManager.sol\";\nimport \"../interfaces/governance/IVault.sol\";\n\n/**\n * @title Treasury (prev. Vault)\n * @dev Contract for locking up tokens for arbitrary time intervals, optionally providing voting power\n */\ncontract Treasury is IVault {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice lockManager contract\n\tILockManager public lockManager;\n\n\t/// @dev Used to translate lock periods specified in days to seconds\n\tuint256 internal constant SECONDS_PER_DAY = 86400;\n\n\t/// @notice Mapping of lock id > token locks\n\tmapping(uint256 => Lock) public tokenLocks;\n\n\t/// @notice Mapping of address to lock id\n\tmapping(address => uint256[]) public lockIds;\n\n\t///@notice Number of locks\n\tuint256 public numLocks;\n\n\t/// @notice Event emitted when a new lock is created\n\tevent LockCreated(\n\t\taddress indexed token,\n\t\taddress indexed locker,\n\t\taddress indexed receiver,\n\t\tuint256 lockId,\n\t\tuint256 amount,\n\t\tuint48 startTime,\n\t\tuint16 durationInDays,\n\t\tuint16 cliffInDays,\n\t\tuint256 votingPower\n\t);\n\n\t/// @notice Event emitted when tokens are claimed by a receiver from an unlocked balance\n\tevent UnlockedTokensClaimed(\n\t\taddress indexed receiver,\n\t\taddress indexed token,\n\t\tuint256 indexed lockId,\n\t\tuint256 amountClaimed,\n\t\tuint256 votingPowerRemoved\n\t);\n\n\t/// @notice Event emitted when lock duration extended\n\tevent LockExtended(\n\t\tuint256 indexed lockId,\n\t\tuint16 indexed oldDuration,\n\t\tuint16 indexed newDuration,\n\t\tuint16 oldCliff,\n\t\tuint16 newCliff,\n\t\tuint48 startTime\n\t);\n\n\t/**\n\t * @notice Create a new Treasury contract\n\t */\n\tconstructor(address _lockManager) {\n\t\tlockManager = ILockManager(_lockManager);\n\t}\n\n\t/**\n\t * @notice Lock tokens, optionally providing voting power\n\t * @param locker The account that is locking tokens\n\t * @param receiver The account that will be able to retrieve unlocked tokens\n\t * @param startTime The unix timestamp when the lock period will start\n\t * @param amount The amount of tokens being locked\n\t * @param vestingDurationInDays The vesting period in days\n\t * @param cliffDurationInDays The cliff duration in days\n\t * @param grantVotingPower if true, give user voting power from tokens\n\t */\n\tfunction lockTokens(\n\t\taddress token,\n\t\taddress locker,\n\t\taddress receiver,\n\t\tuint48 startTime,\n\t\tuint256 amount,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 cliffDurationInDays,\n\t\tbool grantVotingPower\n\t) external override {\n\t\trequire(vestingDurationInDays > 0, \"Treasury::lockTokens: vesting duration must be > 0\");\n\t\trequire(vestingDurationInDays <= 50 * 365, \"Treasury::lockTokens: vesting duration more than 50 years\");\n\t\trequire(vestingDurationInDays >= cliffDurationInDays, \"Treasury::lockTokens: vesting duration < cliff\");\n\t\trequire(amount > 0, \"Treasury::lockTokens: amount not > 0\");\n\n\t\t_lockTokens(\n\t\t\ttoken,\n\t\t\tlocker,\n\t\t\treceiver,\n\t\t\tstartTime,\n\t\t\tamount,\n\t\t\tvestingDurationInDays,\n\t\t\tcliffDurationInDays,\n\t\t\tgrantVotingPower\n\t\t);\n\t}\n\n\t/**\n\t * @notice Lock tokens, using permit for approval\n\t * @dev It is up to the frontend developer to ensure the token implements permit - **otherwise this will fail**\n\t * @param token Address of token to lock\n\t * @param locker The account that is locking tokens\n\t * @param receiver The account that will be able to retrieve unlocked tokens\n\t * @param startTime The unix timestamp when the lock period will start\n\t * @param amount The amount of tokens being locked\n\t * @param vestingDurationInDays The lock period in days\n\t * @param cliffDurationInDays The lock cliff duration in days\n\t * @param grantVotingRights if true, give user voting power from tokens\n\t * @param deadline The time at which to expire the signature\n\t * @param signature The `signature` that signed a hashed message (used to retrieve v,r,s separately and avoid\n\t *\t\t  stack too deep errors\n\t */\n\tfunction lockTokensWithPermit(\n\t\taddress token,\n\t\taddress locker,\n\t\taddress receiver,\n\t\tuint48 startTime,\n\t\tuint256 amount,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 cliffDurationInDays,\n\t\tbool grantVotingRights,\n\t\tuint256 deadline,\n\t\tbytes memory signature\n\t) external override {\n\t\trequire(vestingDurationInDays > 0, \"Treasury::lockTokensWithPermit: vesting duration must be > 0\");\n\t\trequire(vestingDurationInDays <= 50 * 365, \"Treasury::lockTokensWithPermit: vesting duration more than 50 years\");\n\t\trequire(vestingDurationInDays >= cliffDurationInDays, \"Treasury::lockTokensWithPermit: duration < cliff\");\n\t\trequire(amount > 0, \"Treasury::lockTokensWithPermit: amount not > 0\");\n\n\t\t// ecrecover takes the signature parameters, and the only way to get them currently is to use assembly\n\t\tuint8 v;\n\t\tbytes32 r;\n\t\tbytes32 s;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tr := mload(add(signature, 0x20))\n\t\t\ts := mload(add(signature, 0x40))\n\t\t\tv := byte(0, mload(add(signature, 0x60)))\n\t\t}\n\n\t\tIERC20Permit(token).permit(locker, address(this), amount, deadline, v, r, s);\n\t\t_lockTokens(\n\t\t\ttoken,\n\t\t\tlocker,\n\t\t\treceiver,\n\t\t\tstartTime,\n\t\t\tamount,\n\t\t\tvestingDurationInDays,\n\t\t\tcliffDurationInDays,\n\t\t\tgrantVotingRights\n\t\t);\n\t}\n\n\t/**\n\t * @notice Get all active token lock ids\n\t * @return the lock ids\n\t */\n\tfunction allActiveLockIds() external view override returns (uint256[] memory) {\n\t\tuint256 activeCount;\n\n\t\t// Get number of active locks\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory lock = tokenLocks[i];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tactiveCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create result array of length `activeCount`\n\t\tuint256[] memory result = new uint256[](activeCount);\n\t\tuint256 j;\n\n\t\t// Populate result array\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory lock = tokenLocks[i];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tresult[j] = i;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get all active token locks\n\t * @return the locks\n\t */\n\tfunction allActiveLocks() external view override returns (Lock[] memory) {\n\t\tuint256 activeCount;\n\n\t\t// Get number of active locks\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory lock = tokenLocks[i];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tactiveCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create result array of length `activeCount`\n\t\tLock[] memory result = new Lock[](activeCount);\n\t\tuint256 j;\n\n\t\t// Populate result array\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory lock = tokenLocks[i];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tresult[j] = lock;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get all active token lock balances\n\t * @return the active lock balances\n\t */\n\tfunction allActiveLockBalances() external view override returns (LockBalance[] memory) {\n\t\tuint256 activeCount;\n\n\t\t// Get number of active locks\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory lock = tokenLocks[i];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tactiveCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create result array of length `activeCount`\n\t\tLockBalance[] memory result = new LockBalance[](activeCount);\n\t\tuint256 j;\n\n\t\t// Populate result array\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory lock = tokenLocks[i];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tresult[j] = lockBalance(i);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get all active token lock ids for receiver\n\t * @param receiver The address that has locked balances\n\t * @return the active lock ids\n\t */\n\tfunction activeLockIds(address receiver) external view override returns (uint256[] memory) {\n\t\tuint256 activeCount;\n\t\tuint256[] memory receiverLockIds = lockIds[receiver];\n\n\t\t// Get number of active locks\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory lock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tactiveCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create result array of length `activeCount`\n\t\tuint256[] memory result = new uint256[](activeCount);\n\t\tuint256 j;\n\n\t\t// Populate result array\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory lock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tresult[j] = receiverLockIds[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get all token locks for receiver\n\t * @param receiver The address that has locked balances\n\t * @return the locks\n\t */\n\tfunction allLocks(address receiver) external view override returns (Lock[] memory) {\n\t\tuint256[] memory allLockIds = lockIds[receiver];\n\t\tLock[] memory result = new Lock[](allLockIds.length);\n\t\tfor (uint256 i; i < allLockIds.length; i++) {\n\t\t\tresult[i] = tokenLocks[allLockIds[i]];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get all active token locks for receiver\n\t * @param receiver The address that has locked balances\n\t * @return the locks\n\t */\n\tfunction activeLocks(address receiver) external view override returns (Lock[] memory) {\n\t\tuint256 activeCount;\n\t\tuint256[] memory receiverLockIds = lockIds[receiver];\n\n\t\t// Get number of active locks\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory lock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tactiveCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create result array of length `activeCount`\n\t\tLock[] memory result = new Lock[](activeCount);\n\t\tuint256 j;\n\n\t\t// Populate result array\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory lock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tresult[j] = tokenLocks[receiverLockIds[i]];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get all active token lock balances for receiver\n\t * @param receiver The address that has locked balances\n\t * @return the active lock balances\n\t */\n\tfunction activeLockBalances(address receiver) external view override returns (LockBalance[] memory) {\n\t\tuint256 activeCount;\n\t\tuint256[] memory receiverLockIds = lockIds[receiver];\n\n\t\t// Get number of active locks\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory lock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tactiveCount++;\n\t\t\t}\n\t\t}\n\n\t\t// Create result array of length `activeCount`\n\t\tLockBalance[] memory result = new LockBalance[](activeCount);\n\t\tuint256 j;\n\n\t\t// Populate result array\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory lock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (lock.amount != lock.amountClaimed) {\n\t\t\t\tresult[j] = lockBalance(receiverLockIds[i]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @notice Get total token balance\n\t * @param token The token to check\n\t * @return balance the total active balance of `token`\n\t */\n\tfunction totalTokenBalance(address token) external view override returns (TokenBalance memory balance) {\n\t\tfor (uint256 i; i < numLocks; i++) {\n\t\t\tLock memory tokenLock = tokenLocks[i];\n\t\t\tif (tokenLock.token == token && tokenLock.amount != tokenLock.amountClaimed) {\n\t\t\t\tbalance.totalAmount = balance.totalAmount + tokenLock.amount;\n\t\t\t\tbalance.votingPower = balance.votingPower + tokenLock.votingPower;\n\t\t\t\tif (block.timestamp > tokenLock.startTime) {\n\t\t\t\t\tbalance.claimedAmount = balance.claimedAmount + tokenLock.amountClaimed;\n\n\t\t\t\t\tuint256 elapsedTime = block.timestamp - tokenLock.startTime;\n\t\t\t\t\tuint256 elapsedDays = elapsedTime / SECONDS_PER_DAY;\n\n\t\t\t\t\tif (elapsedDays >= tokenLock.cliffDurationInDays) {\n\t\t\t\t\t\tif (elapsedDays >= tokenLock.vestingDurationInDays) {\n\t\t\t\t\t\t\tbalance.claimableAmount =\n\t\t\t\t\t\t\t\tbalance.claimableAmount +\n\t\t\t\t\t\t\t\ttokenLock.amount -\n\t\t\t\t\t\t\t\ttokenLock.amountClaimed;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuint256 vestingDurationInSecs = uint256(tokenLock.vestingDurationInDays) * SECONDS_PER_DAY;\n\t\t\t\t\t\t\tuint256 vestingAmountPerSec = tokenLock.amount / vestingDurationInSecs;\n\t\t\t\t\t\t\tuint256 amountVested = vestingAmountPerSec * elapsedTime;\n\t\t\t\t\t\t\tbalance.claimableAmount = balance.claimableAmount + amountVested - tokenLock.amountClaimed;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Get token balance of receiver\n\t * @param token The token to check\n\t * @param receiver The address that has unlocked balances\n\t * @return balance the total active balance of `token` for `receiver`\n\t */\n\tfunction tokenBalance(address token, address receiver) external view override returns (TokenBalance memory balance) {\n\t\tuint256[] memory receiverLockIds = lockIds[receiver];\n\t\tfor (uint256 i; i < receiverLockIds.length; i++) {\n\t\t\tLock memory receiverLock = tokenLocks[receiverLockIds[i]];\n\t\t\tif (receiverLock.token == token && receiverLock.amount != receiverLock.amountClaimed) {\n\t\t\t\tbalance.totalAmount = balance.totalAmount + receiverLock.amount;\n\t\t\t\tbalance.votingPower = balance.votingPower + receiverLock.votingPower;\n\t\t\t\tif (block.timestamp > receiverLock.startTime) {\n\t\t\t\t\tbalance.claimedAmount = balance.claimedAmount + receiverLock.amountClaimed;\n\n\t\t\t\t\tuint256 elapsedTime = block.timestamp - receiverLock.startTime;\n\t\t\t\t\tuint256 elapsedDays = elapsedTime / SECONDS_PER_DAY;\n\n\t\t\t\t\tif (elapsedDays >= receiverLock.cliffDurationInDays) {\n\t\t\t\t\t\tif (elapsedDays >= receiverLock.vestingDurationInDays) {\n\t\t\t\t\t\t\tbalance.claimableAmount =\n\t\t\t\t\t\t\t\tbalance.claimableAmount +\n\t\t\t\t\t\t\t\treceiverLock.amount -\n\t\t\t\t\t\t\t\treceiverLock.amountClaimed;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuint256 vestingDurationInSecs = uint256(receiverLock.vestingDurationInDays) * SECONDS_PER_DAY;\n\t\t\t\t\t\t\tuint256 vestingAmountPerSec = receiverLock.amount / vestingDurationInSecs;\n\t\t\t\t\t\t\tuint256 amountVested = vestingAmountPerSec * elapsedTime;\n\t\t\t\t\t\t\tbalance.claimableAmount = balance.claimableAmount + amountVested - receiverLock.amountClaimed;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Get lock balance for a given lock id\n\t * @param lockId The lock ID\n\t * @return balance the lock balance\n\t */\n\tfunction lockBalance(uint256 lockId) public view override returns (LockBalance memory balance) {\n\t\tbalance.id = lockId;\n\t\tbalance.claimableAmount = claimableBalance(lockId);\n\t\tbalance.lock = tokenLocks[lockId];\n\t}\n\n\t/**\n\t * @notice Get claimable balance for a given lock id\n\t * @dev Returns 0 if cliff duration has not ended\n\t * @param lockId The lock ID\n\t * @return The amount that can be claimed\n\t */\n\tfunction claimableBalance(uint256 lockId) public view override returns (uint256) {\n\t\tLock storage lock = tokenLocks[lockId];\n\n\t\t// For locks created with a future start date, that hasn't been reached, return 0\n\t\tif (block.timestamp < lock.startTime) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 elapsedTime = block.timestamp - lock.startTime;\n\t\tuint256 elapsedDays = elapsedTime / SECONDS_PER_DAY;\n\n\t\tif (elapsedDays < lock.cliffDurationInDays) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (elapsedDays >= lock.vestingDurationInDays) {\n\t\t\treturn lock.amount - lock.amountClaimed;\n\t\t} else {\n\t\t\tuint256 vestingDurationInSecs = uint256(lock.vestingDurationInDays) * SECONDS_PER_DAY;\n\t\t\tuint256 vestingAmountPerSec = lock.amount / vestingDurationInSecs;\n\t\t\tuint256 amountVested = vestingAmountPerSec * elapsedTime;\n\t\t\treturn amountVested - lock.amountClaimed;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Allows receiver to claim all of their unlocked tokens for a set of locks\n\t * @dev Errors if no tokens are claimable\n\t * @dev It is advised receivers check they are entitled to claim via `claimableBalance` before calling this\n\t * @param locks The lock ids for unlocked token balances\n\t */\n\tfunction claimAllUnlockedTokens(uint256[] memory locks) external override {\n\t\tfor (uint256 i = 0; i < locks.length; i++) {\n\t\t\tuint256 claimableAmount = claimableBalance(locks[i]);\n\t\t\trequire(claimableAmount > 0, \"Treasury::claimAllUnlockedTokens: claimableAmount is 0\");\n\t\t\t_claimTokens(locks[i], claimableAmount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Allows receiver to claim a portion of their unlocked tokens for a given lock\n\t * @dev Errors if token amounts provided are > claimable amounts\n\t * @dev It is advised receivers check they are entitled to claim via `claimableBalance` before calling this\n\t * @param locks The lock ids for unlocked token balances\n\t * @param amounts The amount of each unlocked token to claim\n\t */\n\tfunction claimUnlockedTokenAmounts(uint256[] memory locks, uint256[] memory amounts) external override {\n\t\trequire(locks.length == amounts.length, \"Treasury::claimUnlockedTokenAmounts: arrays must be same length\");\n\n\t\tfor (uint256 i = 0; i < locks.length; i++) {\n\t\t\tuint256 claimableAmount = claimableBalance(locks[i]);\n\t\t\trequire(claimableAmount >= amounts[i], \"Treasury::claimUnlockedTokenAmounts: claimableAmount < amount\");\n\t\t\t_claimTokens(locks[i], amounts[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Allows receiver extend lock periods for a given lock\n\t * @param lockId The lock id for a locked token balance\n\t * @param vestingDaysToAdd The number of days to add to vesting duration\n\t * @param cliffDaysToAdd The number of days to add to cliff duration\n\t */\n\tfunction extendLock(\n\t\tuint256 lockId,\n\t\tuint16 vestingDaysToAdd,\n\t\tuint16 cliffDaysToAdd\n\t) external override {\n\t\tLock storage lock = tokenLocks[lockId];\n\t\trequire(msg.sender == lock.receiver, \"Treasury::extendLock: msg.sender must be receiver\");\n\n\t\tuint16 oldVestingDuration = lock.vestingDurationInDays;\n\t\tuint16 newVestingDuration =\n\t\t\t_add16(oldVestingDuration, vestingDaysToAdd, \"Treasury::extendLock: vesting max days exceeded\");\n\n\t\tuint16 oldCliffDuration = lock.cliffDurationInDays;\n\t\tuint16 newCliffDuration =\n\t\t\t_add16(oldCliffDuration, cliffDaysToAdd, \"Treasury::extendLock: cliff max days exceeded\");\n\n\t\trequire(newVestingDuration >= newCliffDuration, \"Treasury::extendLock: duration < cliff\");\n\t\trequire(newCliffDuration <= 10 * 365, \"Treasury::extendLock: cliff more than 10 years\");\n\t\trequire(newVestingDuration <= 25 * 365, \"Treasury::extendLock: vesting duration more than 25 years\");\n\n\t\tlock.vestingDurationInDays = newVestingDuration;\n\n\t\temit LockExtended(\n\t\t\tlockId,\n\t\t\toldVestingDuration,\n\t\t\tnewVestingDuration,\n\t\t\toldCliffDuration,\n\t\t\tnewCliffDuration,\n\t\t\tlock.startTime\n\t\t);\n\t}\n\n\t/**\n\t * @notice Internal implementation of lockTokens\n\t * @param locker The account that is locking tokens\n\t * @param receiver The account that will be able to retrieve unlocked tokens\n\t * @param startTime The unix timestamp when the lock period will start\n\t * @param amount The amount of tokens being locked\n\t * @param vestingDurationInDays The vesting period in days\n\t * @param cliffDurationInDays The cliff duration in days\n\t * @param grantVotingPower if true, give user voting power from tokens\n\t */\n\tfunction _lockTokens(\n\t\taddress token,\n\t\taddress locker,\n\t\taddress receiver,\n\t\tuint48 startTime,\n\t\tuint256 amount,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 cliffDurationInDays,\n\t\tbool grantVotingPower\n\t) internal {\n\t\t// Transfer the tokens under the control of the vault contract\n\t\tIERC20(token).safeTransferFrom(locker, address(this), amount);\n\n\t\tuint48 lockStartTime = startTime == 0 ? uint48(block.timestamp) : startTime;\n\t\tuint256 votingPowerGranted;\n\n\t\t// Grant voting power, if specified\n\t\tif (grantVotingPower) {\n\t\t\tvotingPowerGranted = lockManager.grantVotingPower(receiver, token, amount);\n\t\t}\n\n\t\t// Create lock\n\t\tLock memory lock =\n\t\t\tLock({\n\t\t\t\ttoken: token,\n\t\t\t\treceiver: receiver,\n\t\t\t\tstartTime: lockStartTime,\n\t\t\t\tvestingDurationInDays: vestingDurationInDays,\n\t\t\t\tcliffDurationInDays: cliffDurationInDays,\n\t\t\t\tamount: amount,\n\t\t\t\tamountClaimed: 0,\n\t\t\t\tvotingPower: votingPowerGranted\n\t\t\t});\n\n\t\ttokenLocks[numLocks] = lock;\n\t\tlockIds[receiver].push(numLocks);\n\n\t\temit LockCreated(\n\t\t\ttoken,\n\t\t\tlocker,\n\t\t\treceiver,\n\t\t\tnumLocks,\n\t\t\tamount,\n\t\t\tlockStartTime,\n\t\t\tvestingDurationInDays,\n\t\t\tcliffDurationInDays,\n\t\t\tvotingPowerGranted\n\t\t);\n\n\t\t// Increment lock id\n\t\tnumLocks++;\n\t}\n\n\t/**\n\t * @notice Internal implementation of token claims\n\t * @param lockId The lock id for claim\n\t * @param claimAmount The amount to claim\n\t */\n\tfunction _claimTokens(uint256 lockId, uint256 claimAmount) internal {\n\t\tLock storage lock = tokenLocks[lockId];\n\t\tuint256 votingPowerRemoved;\n\n\t\t// Remove voting power, if exists\n\t\tif (lock.votingPower > 0) {\n\t\t\tvotingPowerRemoved = lockManager.removeVotingPower(lock.receiver, lock.token, claimAmount);\n\t\t\tlock.votingPower = lock.votingPower - votingPowerRemoved;\n\t\t}\n\n\t\t// Update claimed amount\n\t\tlock.amountClaimed = lock.amountClaimed + claimAmount;\n\n\t\t// Release tokens\n\t\tIERC20(lock.token).safeTransfer(lock.receiver, claimAmount);\n\t\temit UnlockedTokensClaimed(lock.receiver, lock.token, lockId, claimAmount, votingPowerRemoved);\n\t}\n\n\t/**\n\t * @notice Adds uint16 to uint16 safely\n\t * @param a First number\n\t * @param b Second number\n\t * @param errorMessage Error message to use if numbers cannot be added\n\t * @return uint16 number\n\t */\n\tfunction _add16(\n\t\tuint16 a,\n\t\tuint16 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint16) {\n\t\tunchecked {\n\t\t\tuint16 c = a + b;\n\t\t\trequire(c >= a, errorMessage);\n\t\t\treturn c;\n\t\t}\n\t}\n}\n"
    },
    "contracts/governance/Dragon.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n                                                    ___\n                                                  .~))>>\n                                                 .~)>>\n                                               .~))))>>>\n                                             .~))>>             ___\n                                           .~))>>)))>>      .-~))>>\n                                         .~)))))>>       .-~))>>)>\n                                       .~)))>>))))>>  .-~)>>)>\n                   )                 .~))>>))))>>  .-~)))))>>)>\n                ( )@@*)             //)>))))))  .-~))))>>)>\n              ).@(@@               //))>>))) .-~))>>)))))>>)>\n            (( @.@).              //))))) .-~)>>)))))>>)>\n          ))  )@@*.@@ )          //)>))) //))))))>>))))>>)>\n       ((  ((@@@.@@             |/))))) //)))))>>)))>>)>\n      )) @@*. )@@ )   (\\_(\\-\\b  |))>)) //)))>>)))))))>>)>\n    (( @@@(.@(@ .    _/`-`  ~|b |>))) //)>>)))))))>>)>\n     )* @@@ )@*     (@) (@)  /\\b|))) //))))))>>))))>>\n   (( @. )@( @ .   _/       /  \\b)) //))>>)))))>>>_._\n    )@@ (@@*)@@.  (6,   6) / ^  \\b)//))))))>>)))>>   ~~-.\n ( @jgs@@. @@@.*@_ ~^~^~, /\\  ^  \\b/)>>))))>>      _.     `,\n  ((@@ @@@*.(@@ .   \\^^^/' (  ^   \\b)))>>        .'         `,\n   ((@@).*@@ )@ )    `-'   ((   ^  ~)_          /             `,\n     (@@. (@@ ).           (((   ^    `\\        |               `.\n       (*.@*              / ((((        \\        \\      .         `.\n                         /   (((((  \\    \\    _.-~\\     Y,         ;\n                        /   / (((((( \\    \\.-~   _.`\" _.-~`,       ;\n                       /   /   `(((((()    )    (((((~      `,     ;\n                     _/  _/      `\"\"\"/   /'                  ;     ;\n                 _.-~_.-~           /  /'                _.-~   _.'\n               ((((~~              / /'              _.-~ __.--~\n                                  ((((          __.-~ _.-~\n                                              .'   .~~\n                                              :    ,'\n                                              ~~~~~\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../interfaces/governance/ILockManager.sol\";\nimport \"../interfaces/governance/IMasterChef.sol\";\nimport \"../interfaces/governance/IVault.sol\";\n\nimport \"../libraries/governance/LibCrownStorage.sol\";\nimport \"../libraries/governance/Treasurer.sol\";\n\n/**\n * @title Dragon (prev. RewardsManager)\n * @dev Oversees rewards distribution withing the Kingmaker ecosystem\n */\ncontract Dragon is Treasurer {\n\tusing SafeERC20 for IERC20;\n\n\t/**\n\t * @notice Create a new Rewards Manager contract\n\t * @param _master master of contract\n\t * @param _lockManager address of LockManager contract\n\t * @param _vault address of Vault contract\n\t * @param _rewardToken address of token that is being offered as a reward\n\t * @param _sushiToken address of SUSHI token\n\t * @param _masterChef address of SushiSwap MasterChef contract\n\t * @param _startBlock block number when rewards will start\n\t * @param _rewardTokensPerBlock *initial* amount of reward tokens to be distributed per block\n\t */\n\tconstructor(\n\t\taddress _master,\n\t\taddress _lockManager,\n\t\taddress _vault,\n\t\taddress _rewardToken,\n\t\taddress _sushiToken,\n\t\taddress _masterChef,\n\t\tuint256 _startBlock,\n\t\tuint256 _rewardTokensPerBlock\n\t) {\n\t\tmaster = _master;\n\t\temit ChangedMaster(address(0), _master);\n\n\t\tlockManager = ILockManager(_lockManager);\n\t\temit ChangedAddress(\"LOCK_MANAGER\", address(0), _lockManager);\n\n\t\tvault = IVault(_vault);\n\t\temit ChangedAddress(\"VAULT\", address(0), _vault);\n\n\t\trewardToken = IERC20(_rewardToken);\n\t\temit ChangedAddress(\"REWARD_TOKEN\", address(0), _rewardToken);\n\n\t\tsushiToken = IERC20(_sushiToken);\n\t\temit ChangedAddress(\"SUSHI_TOKEN\", address(0), _sushiToken);\n\n\t\tmasterChef = IMasterChef(_masterChef);\n\t\temit ChangedAddress(\"MASTER_CHEF\", address(0), _masterChef);\n\n\t\tstartBlock = _startBlock == 0 ? block.number : _startBlock;\n\t\temit SetRewardsStartBlock(startBlock);\n\n\t\trewardTokensPerBlock = _rewardTokensPerBlock;\n\t\temit ChangedRewardTokensPerBlock(0, _rewardTokensPerBlock);\n\n\t\trewardToken.safeIncreaseAllowance(address(vault), type(uint256).max);\n\t}\n\n\t/**\n\t * @notice Set new rewards per block\n\t * @dev Can only be called by the master\n\t * @param newRewardTokensPerBlock new amount of reward token to reward each block\n\t */\n\tfunction setRewardsPerBlock(uint256 newRewardTokensPerBlock) external onlyMaster {\n\t\temit ChangedRewardTokensPerBlock(rewardTokensPerBlock, newRewardTokensPerBlock);\n\t\trewardTokensPerBlock = newRewardTokensPerBlock;\n\t\t_setRewardsEndBlock();\n\t}\n\n\t/**\n\t * @notice Set new reward token address\n\t * @param newToken address of new reward token\n\t * @param newRewardTokensPerBlock new amount of reward token to reward each block\n\t */\n\tfunction setRewardToken(address newToken, uint256 newRewardTokensPerBlock) external onlyMaster {\n\t\temit ChangedAddress(\"REWARD_TOKEN\", address(rewardToken), newToken);\n\t\trewardToken = IERC20(newToken);\n\t\trewardTokensPerBlock = newRewardTokensPerBlock;\n\t\t_setRewardsEndBlock();\n\t}\n\n\t/**\n\t * @notice Set new SUSHI token address\n\t * @dev Can only be called by the master\n\t * @param newToken address of new SUSHI token\n\t */\n\tfunction setSushiToken(address newToken) external onlyMaster {\n\t\temit ChangedAddress(\"SUSHI_TOKEN\", address(sushiToken), newToken);\n\t\tsushiToken = IERC20(newToken);\n\t}\n\n\t/**\n\t * @notice Set new MasterChef address\n\t * @dev Can only be called by the master\n\t * @param newAddress address of new MasterChef\n\t */\n\tfunction setMasterChef(address newAddress) external onlyMaster {\n\t\temit ChangedAddress(\"MASTER_CHEF\", address(masterChef), newAddress);\n\t\tmasterChef = IMasterChef(newAddress);\n\t}\n\n\t/**\n\t * @notice Set new Vault address\n\t * @param newAddress address of new Vault\n\t */\n\tfunction setVault(address newAddress) external onlyMaster {\n\t\temit ChangedAddress(\"VAULT\", address(vault), newAddress);\n\t\tvault = IVault(newAddress);\n\t}\n\n\t/**\n\t * @notice Set new LockManager address\n\t * @param newAddress address of new LockManager\n\t */\n\tfunction setLockManager(address newAddress) external onlyMaster {\n\t\temit ChangedAddress(\"LOCK_MANAGER\", address(lockManager), newAddress);\n\t\tlockManager = ILockManager(newAddress);\n\t}\n\n\t/**\n\t * @notice Change master of vesting contract\n\t * @dev Can only be called by the master\n\t * @param newOwner New master address\n\t */\n\tfunction changeMaster(address newOwner) external onlyMaster {\n\t\trequire(newOwner != address(0) && newOwner != address(this), \"Dragon::changeMaster: not valid address\");\n\t\temit ChangedMaster(master, newOwner);\n\t\tmaster = newOwner;\n\t}\n}\n"
    },
    "contracts/governance/Miners.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n        \n      \n        \n                \n              \n              \n              \n              \n              \n                \n                            \n                          \n                              \n                                    \n                                \n                                  \n                              \n                              \n                    \n                \n                  \n                    \n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../interfaces/governance/ICrownGovernanceToken.sol\";\n\nimport \"../libraries/governance/LibCrownStorage.sol\";\n\n/**\n * @title Miners (prev. SupplyManager)\n * @dev Collective responsible for enacting decisions related to Crown governance token supply\n * @notice Decisions are made via a timelocked propose/accept scheme\n * @notice Initial proposal length (timelock) is 30 days\n */\ncontract Miners {\n\t/// @notice Crown Governance token\n\tICrownGovernanceToken public token;\n\n\t/// @notice Address which may make changes the token supply by calling provided functions\n\taddress public king;\n\n\t/// @notice The timestamp after which a change may occur\n\tuint256 public changeAllowedAfter;\n\n\t/// @notice The current time between proposal and acceptance\n\tuint32 public proposalLength = 1 days * 30;\n\n\t/// @notice The minimum time between proposal and acceptance\n\tuint32 public proposalLengthMinimum = 1 days * 7;\n\n\t/// @notice New king proposal\n\tstruct RoyalDecree {\n\t\tuint256 eta;\n\t\taddress newKing;\n\t}\n\n\t/// @notice New mint proposal\n\tstruct MintProposal {\n\t\tuint256 eta;\n\t\taddress destination;\n\t\tuint256 amount;\n\t}\n\n\t/// @notice New burn proposal\n\tstruct BurnProposal {\n\t\tuint256 eta;\n\t\taddress source;\n\t\tuint256 amount;\n\t}\n\n\t/// @notice New mint cap proposal\n\tstruct MintCapProposal {\n\t\tuint256 eta;\n\t\tuint32 newCap;\n\t}\n\n\t/// @notice New waiting period proposal\n\tstruct WaitingPeriodProposal {\n\t\tuint256 eta;\n\t\tuint32 newPeriod;\n\t}\n\n\t/// @notice New supply manager proposal\n\tstruct MinersProposal {\n\t\tuint256 eta;\n\t\taddress newMiners;\n\t}\n\n\t/// @notice New proposal length proposal\n\tstruct ProposalLengthProposal {\n\t\tuint256 eta;\n\t\tuint32 newLength;\n\t}\n\n\t/// @notice Current pending king proposal\n\tRoyalDecree public pendingKing;\n\n\t/// @notice Current pending mint proposal\n\tMintProposal public pendingMint;\n\n\t/// @notice Current pending burn proposal\n\tBurnProposal public pendingBurn;\n\n\t/// @notice Current pending mint cap proposal\n\tMintCapProposal public pendingMintCap;\n\n\t/// @notice Current pending waiting period proposal\n\tWaitingPeriodProposal public pendingWaitingPeriod;\n\n\t/// @notice Current pending supply manager proposal\n\tMinersProposal public pendingMiners;\n\n\t/// @notice Current pending proposal length proposal\n\tProposalLengthProposal public pendingProposalLength;\n\n\t/// @notice An event that's emitted when a new king is proposed\n\tevent KingProposed(address indexed oldKing, address indexed newKing, uint256 eta);\n\n\t/// @notice An event that's emitted when an king proposal is canceled\n\tevent KingCanceled(address indexed proposedKing);\n\n\t/// @notice An event that's emitted when a new king is accepted\n\tevent KingAccepted(address indexed oldKing, address indexed newKing);\n\n\t/// @notice An event that's emitted when a new mint is proposed\n\tevent MintProposed(\n\t\tuint256 indexed amount,\n\t\taddress indexed recipient,\n\t\tuint256 oldSupply,\n\t\tuint256 newSupply,\n\t\tuint256 eta\n\t);\n\n\t/// @notice An event that's emitted when a mint proposal is canceled\n\tevent MintCanceled(uint256 indexed amount, address indexed recipient);\n\n\t/// @notice An event that's emitted when a new mint is accepted\n\tevent MintAccepted(uint256 indexed amount, address indexed recipient, uint256 oldSupply, uint256 newSupply);\n\n\t/// @notice An event that's emitted when a new burn is proposed\n\tevent BurnProposed(uint256 indexed amount, address indexed source, uint256 oldSupply, uint256 newSupply, uint256 eta);\n\n\t/// @notice An event that's emitted when a burn proposal is canceled\n\tevent BurnCanceled(uint256 indexed amount, address indexed source);\n\n\t/// @notice An event that's emitted when a new burn is accepted\n\tevent BurnAccepted(uint256 indexed amount, address indexed source, uint256 oldSupply, uint256 newSupply);\n\n\t/// @notice An event that's emitted when a new mint cap is proposed\n\tevent MintCapProposed(uint32 indexed oldCap, uint32 indexed newCap, uint256 eta);\n\n\t/// @notice An event that's emitted when a mint cap proposal is canceled\n\tevent MintCapCanceled(uint32 indexed proposedCap);\n\n\t/// @notice An event that's emitted when a new mint cap is accepted\n\tevent MintCapAccepted(uint32 indexed oldCap, uint32 indexed newCap);\n\n\t/// @notice An event that's emitted when a new waiting period is proposed\n\tevent WaitingPeriodProposed(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod, uint256 eta);\n\n\t/// @notice An event that's emitted when a waiting period proposal is canceled\n\tevent WaitingPeriodCanceled(uint32 indexed proposedWaitingPeriod);\n\n\t/// @notice An event that's emitted when a new waiting period is accepted\n\tevent WaitingPeriodAccepted(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\n\n\t/// @notice An event that's emitted when a new supply manager is proposed\n\tevent MinersProposed(address indexed oldMiners, address indexed newMiners, uint256 eta);\n\n\t/// @notice An event that's emitted when a supply manager proposal is canceled\n\tevent MinersCanceled(address indexed proposedMiners);\n\n\t/// @notice An event that's emitted when a new supply manager is accepted\n\tevent MinersAccepted(address indexed oldMiners, address indexed newMiners);\n\n\t/// @notice An event that's emitted when a new proposal length is proposed\n\tevent ProposalLengthProposed(uint32 indexed oldProposalLength, uint32 indexed newProposalLength, uint256 eta);\n\n\t/// @notice An event that's emitted when a proposal length proposal is canceled\n\tevent ProposalLengthCanceled(uint32 indexed proposedProposalLength);\n\n\t/// @notice An event that's emitted when a new proposal length is accepted\n\tevent ProposalLengthAccepted(uint32 indexed oldProposalLength, uint32 indexed newProposalLength);\n\n\t/// @notice restrict functions to just owner address\n\tmodifier onlyTheKing {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(crown.king == address(0) || msg.sender == crown.king, \"Crown::onlyTheKing: not the king\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Construct a new supply manager\n\t * @param _token The address for the token\n\t * @param _king The king account for this contract\n\t */\n\tconstructor(address _token, address _king) {\n\t\ttoken = ICrownGovernanceToken(_token);\n\t\tchangeAllowedAfter = token.supplyChangeAllowedAfter();\n\t\tking = _king;\n\t}\n\n\t/**\n\t * @notice Propose a new token mint\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to be minted\n\t */\n\tfunction proposeMint(address dst, uint256 amount) external onlyTheKing {\n\t\tuint256 currentSupply = token.totalSupply();\n\t\trequire(dst != address(0), \"Miners::proposeMint: cannot transfer to the zero address\");\n\t\trequire(amount <= (currentSupply * token.mintCap()) / 1000000, \"Miners::proposeMint: amount exceeds mint cap\");\n\t\tuint256 eta = block.timestamp + proposalLength;\n\t\trequire(eta >= token.supplyChangeAllowedAfter(), \"Miners::proposeMint: minting not allowed yet\");\n\t\tpendingMint = MintProposal(eta, dst, amount);\n\t\temit MintProposed(amount, dst, currentSupply, currentSupply + amount, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed token mint\n\t */\n\tfunction cancelMint() external onlyTheKing {\n\t\trequire(pendingMint.eta != 0, \"Miners::cancelMint: no active proposal\");\n\t\temit MintCanceled(pendingMint.amount, pendingMint.destination);\n\t\tpendingMint = MintProposal(0, address(0), 0);\n\t}\n\n\t/**\n\t * @notice Accept proposed token mint\n\t */\n\tfunction acceptMint() external onlyTheKing {\n\t\trequire(pendingMint.eta != 0, \"Miners::acceptMint: no active proposal\");\n\t\trequire(block.timestamp >= pendingMint.eta, \"Miners::acceptMint: proposal eta not yet passed\");\n\t\taddress dst = pendingMint.destination;\n\t\tuint256 amount = pendingMint.amount;\n\t\tuint256 oldSupply = token.totalSupply();\n\t\tpendingMint = MintProposal(0, address(0), 0);\n\t\trequire(token.mint(dst, amount), \"Miners::acceptMint: unsuccessful\");\n\t\temit MintAccepted(amount, dst, oldSupply, oldSupply + amount);\n\t}\n\n\t/**\n\t * @notice Propose a new token burn\n\t * @param src The address of the account that will burn tokens\n\t * @param amount The number of tokens to be burned\n\t */\n\tfunction proposeBurn(address src, uint256 amount) external onlyTheKing {\n\t\trequire(src != address(0), \"Miners::proposeBurn: cannot transfer from the zero address\");\n\t\trequire(token.allowance(src, address(this)) >= amount, \"Miners::proposeBurn: supplyManager approval < amount\");\n\t\tuint256 currentSupply = token.totalSupply();\n\t\tuint256 newSupply = currentSupply - amount;\n\t\tuint256 eta = block.timestamp + proposalLength;\n\t\trequire(eta >= token.supplyChangeAllowedAfter(), \"Miners::proposeBurn: burning not allowed yet\");\n\t\tpendingBurn = BurnProposal(eta, src, amount);\n\t\temit BurnProposed(amount, src, currentSupply, newSupply, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed token burn\n\t */\n\tfunction cancelBurn() external onlyTheKing {\n\t\trequire(pendingBurn.eta != 0, \"Miners::cancelBurn: no active proposal\");\n\t\temit BurnCanceled(pendingBurn.amount, pendingBurn.source);\n\t\tpendingBurn = BurnProposal(0, address(0), 0);\n\t}\n\n\t/**\n\t * @notice Accept proposed token burn\n\t */\n\tfunction acceptBurn() external onlyTheKing {\n\t\trequire(pendingBurn.eta != 0, \"Miners::acceptBurn: no active proposal\");\n\t\trequire(block.timestamp >= pendingBurn.eta, \"Miners::acceptBurn: proposal eta not yet passed\");\n\t\taddress src = pendingBurn.source;\n\t\tuint256 amount = pendingBurn.amount;\n\t\tpendingBurn = BurnProposal(0, address(0), 0);\n\t\trequire(token.burn(src, amount), \"Miners::acceptBurn: unsuccessful\");\n\t\tuint256 newSupply = token.totalSupply();\n\t\temit BurnAccepted(amount, src, newSupply + amount, newSupply);\n\t}\n\n\t/**\n\t * @notice Propose change to the maximum amount of tokens that can be minted at once\n\t * @param newCap The new mint cap in bips (10,000 bips = 1% of totalSupply)\n\t */\n\tfunction proposeMintCap(uint32 newCap) external onlyTheKing {\n\t\tuint256 eta = block.timestamp + proposalLength;\n\t\tpendingMintCap = MintCapProposal(eta, newCap);\n\t\temit MintCapProposed(token.mintCap(), newCap, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed mint cap\n\t */\n\tfunction cancelMintCap() external onlyTheKing {\n\t\trequire(pendingMintCap.eta != 0, \"Miners::cancelMC: no active proposal\");\n\t\temit MintCapCanceled(pendingMintCap.newCap);\n\t\tpendingMintCap = MintCapProposal(0, 0);\n\t}\n\n\t/**\n\t * @notice Accept change to the maximum amount of tokens that can be minted at once\n\t */\n\tfunction acceptMintCap() external onlyTheKing {\n\t\trequire(pendingMintCap.eta != 0, \"Miners::acceptMC: no active proposal\");\n\t\trequire(block.timestamp >= pendingMintCap.eta, \"Miners::acceptMC: proposal eta not yet passed\");\n\t\tuint32 oldCap = token.mintCap();\n\t\tuint32 newCap = pendingMintCap.newCap;\n\t\tpendingMintCap = MintCapProposal(0, 0);\n\t\trequire(token.setMintCap(newCap), \"Miners::acceptMC: unsuccessful\");\n\t\temit MintCapAccepted(oldCap, newCap);\n\t}\n\n\t/**\n\t * @notice Propose change to the supply change waiting period\n\t * @param newPeriod new waiting period\n\t */\n\tfunction proposeSupplyChangeWaitingPeriod(uint32 newPeriod) external onlyTheKing {\n\t\tuint256 eta = block.timestamp + proposalLength;\n\t\tpendingWaitingPeriod = WaitingPeriodProposal(eta, newPeriod);\n\t\temit WaitingPeriodProposed(token.supplyChangeWaitingPeriod(), newPeriod, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed waiting period\n\t */\n\tfunction cancelWaitingPeriod() external onlyTheKing {\n\t\trequire(pendingWaitingPeriod.eta != 0, \"Miners::cancelWaitingPeriod: no active proposal\");\n\t\tpendingWaitingPeriod = WaitingPeriodProposal(0, 0);\n\t\temit WaitingPeriodCanceled(pendingWaitingPeriod.newPeriod);\n\t}\n\n\t/**\n\t * @notice Accept change to the supply change waiting period\n\t */\n\tfunction acceptSupplyChangeWaitingPeriod() external onlyTheKing {\n\t\trequire(pendingWaitingPeriod.eta != 0, \"Miners::acceptWP: no active proposal\");\n\t\trequire(block.timestamp >= pendingWaitingPeriod.eta, \"Miners::acceptWP: proposal eta not yet passed\");\n\t\tuint32 oldPeriod = token.supplyChangeWaitingPeriod();\n\t\tuint32 newPeriod = pendingWaitingPeriod.newPeriod;\n\t\tpendingWaitingPeriod = WaitingPeriodProposal(0, 0);\n\t\trequire(token.setSupplyChangeWaitingPeriod(newPeriod), \"Miners::acceptWP: unsuccessful\");\n\t\temit WaitingPeriodAccepted(oldPeriod, newPeriod);\n\t}\n\n\t/**\n\t * @notice Propose change to the supplyManager address\n\t * @param newMiners new supply manager address\n\t */\n\tfunction proposeMiners(address newMiners) external onlyTheKing {\n\t\tuint256 eta = block.timestamp + proposalLength;\n\t\tpendingMiners = MinersProposal(eta, newMiners);\n\t\temit MinersProposed(token.supplyManager(), newMiners, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed supply manager update\n\t */\n\tfunction cancelMiners() external onlyTheKing {\n\t\trequire(pendingMiners.eta != 0, \"Miners::cancelSM: no active proposal\");\n\t\temit MinersCanceled(pendingMiners.newMiners);\n\t\tpendingMiners = MinersProposal(0, address(0));\n\t}\n\n\t/**\n\t * @notice Accept change to the supplyManager address\n\t */\n\tfunction acceptMiners() external onlyTheKing {\n\t\trequire(pendingMiners.eta != 0, \"Miners::acceptSM: no active proposal\");\n\t\trequire(block.timestamp >= pendingMiners.eta, \"Miners::acceptSM: proposal eta not yet passed\");\n\t\taddress oldMiners = token.supplyManager();\n\t\taddress newMiners = pendingMiners.newMiners;\n\t\tpendingMiners = MinersProposal(0, address(0));\n\t\trequire(token.setSupplyManager(newMiners), \"Miners::acceptSM: unsuccessful\");\n\t\temit MinersAccepted(oldMiners, newMiners);\n\t}\n\n\t/**\n\t * @notice Propose change to the proposal length\n\t * @param newLength new proposal length\n\t */\n\tfunction proposeNewProposalLength(uint32 newLength) external onlyTheKing {\n\t\trequire(newLength >= proposalLengthMinimum, \"Miners::proposePL: length must be >= minimum\");\n\t\tuint256 eta = block.timestamp + proposalLength;\n\t\tpendingProposalLength = ProposalLengthProposal(eta, newLength);\n\t\temit ProposalLengthProposed(proposalLength, newLength, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed update to proposal length\n\t */\n\tfunction cancelProposalLength() external onlyTheKing {\n\t\trequire(pendingProposalLength.eta != 0, \"Miners::cancelPL: no active proposal\");\n\t\temit ProposalLengthCanceled(pendingProposalLength.newLength);\n\t\tpendingProposalLength = ProposalLengthProposal(0, 0);\n\t}\n\n\t/**\n\t * @notice Accept change to the proposal length\n\t */\n\tfunction acceptProposalLength() external onlyTheKing {\n\t\trequire(pendingProposalLength.eta != 0, \"Miners::acceptPL: no active proposal\");\n\t\trequire(block.timestamp >= pendingProposalLength.eta, \"Miners::acceptPL: proposal eta not yet passed\");\n\t\tuint32 oldLength = proposalLength;\n\t\tuint32 newLength = pendingProposalLength.newLength;\n\t\tpendingProposalLength = ProposalLengthProposal(0, 0);\n\t\tproposalLength = newLength;\n\t\temit ProposalLengthAccepted(oldLength, newLength);\n\t}\n\n\t/**\n\t * @notice Propose a new king\n\t * @param newKing The address of the new king\n\t */\n\tfunction proposeKing(address newKing) external onlyTheKing {\n\t\t// ETA set to minimum to allow for quicker changes if necessary\n\t\tuint256 eta = block.timestamp + proposalLengthMinimum;\n\t\tpendingKing = RoyalDecree(eta, newKing);\n\t\temit KingProposed(king, newKing, eta);\n\t}\n\n\t/**\n\t * @notice Cancel proposed king change\n\t */\n\tfunction cancelKing() external onlyTheKing {\n\t\trequire(pendingKing.eta != 0, \"Miners::cancelKing: no active proposal\");\n\t\temit KingCanceled(pendingKing.newKing);\n\t\tpendingKing = RoyalDecree(0, address(0));\n\t}\n\n\t/**\n\t * @notice Accept proposed king\n\t */\n\tfunction acceptKing() external onlyTheKing {\n\t\trequire(pendingKing.eta != 0, \"Miners::acceptKing: no active proposal\");\n\t\trequire(block.timestamp >= pendingKing.eta, \"Miners::acceptKing: proposal eta not yet passed\");\n\t\taddress oldKing = king;\n\t\taddress newKing = pendingKing.newKing;\n\t\tpendingKing = RoyalDecree(0, address(0));\n\t\tking = newKing;\n\t\temit KingAccepted(oldKing, newKing);\n\t}\n}\n"
    },
    "contracts/governance/Scribe.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n          __...--~~~~~-._   _.-~~~~~--...__\n        //               `V'               \\\\\n       //                 |                 \\\\\n      //__...--~~~~~~-._  |  _.-~~~~~~--...__\\\\\n     //__.....----~~~~._\\ | /_.~~~~----.....__\\\\\n    ====================\\\\|//====================\n                        `---`\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../interfaces/governance/ITokenRegistry.sol\";\n\n/**\n * @title Scribe (prev. TokenRegistry)\n * @dev Maintains the official registry of tokens (along with their respective conversion formulae)\n * \t\tcounted by the Crown and Bailiff in voting power calculations\n */\ncontract Scribe is ITokenRegistry {\n\t/// @notice Current owner of this contract\n\taddress public clergy;\n\n\t/// @notice mapping of tokens to voting power calculation (formula) smart contract addresses\n\tmapping(address => address) public tokenFormulae;\n\n\t/// @notice Event emitted when the owner of the contract is updated\n\tevent ApostolicSuccession(address indexed oldOwner, address indexed newOwner);\n\n\t/// @notice only clergy can call function\n\tmodifier onlyChurch {\n\t\trequire(msg.sender == clergy, \"Scribe::onlyChurch: not clergy\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Construct a new token registry contract\n\t * @param _owner contract owner\n\t * @param _tokens initially supported tokens\n\t * @param _formulae respective formulae contracts for initial tokens\n\t */\n\tconstructor(\n\t\taddress _owner,\n\t\taddress[] memory _tokens,\n\t\taddress[] memory _formulae\n\t) {\n\t\trequire(_tokens.length == _formulae.length, \"Scribe::constructor: tokens and formulae have different lengths\");\n\t\tfor (uint256 i = 0; i < _tokens.length; i++) {\n\t\t\ttokenFormulae[_tokens[i]] = _formulae[i];\n\t\t\temit TokenFormulaUpdated(_tokens[i], _formulae[i]);\n\t\t}\n\t\tclergy = _owner;\n\t\temit ApostolicSuccession(address(0), clergy);\n\t}\n\n\t/**\n\t * @notice Address of owner\n\t * @return Address of owner\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn clergy;\n\t}\n\n\t/**\n\t * @notice Change owner of token registry contract\n\t * @param newOwner New owner address\n\t */\n\tfunction changeOwner(address newOwner) external override onlyChurch {\n\t\temit ApostolicSuccession(clergy, newOwner);\n\t\tclergy = newOwner;\n\t}\n\n\t/**\n\t * @notice Looks up token formula in contract storage mapping of tokens-to-formulae\n\t * @param token The token to retrieve its formula for\n\t * @return the formula address\n\t */\n\tfunction tokenFormula(address token) external view override returns (address) {\n\t\treturn tokenFormulae[token];\n\t}\n\n\t/**\n\t * @notice Set conversion formula address for token\n\t * @param token token for formula\n\t * @param formula address of formula contract\n\t */\n\tfunction setTokenFormula(address token, address formula) external override onlyChurch {\n\t\tif (tokenFormulae[token] == address(0)) {\n\t\t\ttokenFormulae[token] = formula;\n\t\t\temit TokenFormulaAdded(token, formula);\n\t\t} else {\n\t\t\ttokenFormulae[token] = formula;\n\t\t\temit TokenFormulaUpdated(token, formula);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Remove conversion formula address for token\n\t * @param token token address to remove\n\t */\n\tfunction removeToken(address token) external override onlyChurch {\n\t\ttokenFormulae[token] = address(0);\n\t\temit TokenFormulaRemoved(token);\n\t}\n}\n"
    },
    "contracts/governance/Lord.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n                   {}\n   ,   A           {}\n  / \\, | ,        .--.\n |    =|= >      /.--.\\\n  \\ /` | `       |====|\n   `   |         |`::`|\n       |     .-;`\\..../`;_.-^-._\n      /\\\\/  /  |...::..|`   :   `|\n      |:'\\ |   /'''::''|   .:.   |\n       \\ /\\;-,/\\   ::  |...:::...|\n       |\\ <` >  >._::_.| ':::::' |\n       | `\"\"`  /   ^^  |   ':'   |\n       |       |       \\    :    /\n       |       |        \\   :   /\n       |       |___/\\___|`-.:.-`\n       |        \\_ || _/    `\n       |        <_ >< _>\n       |        |  ||  |\n       |        |  ||  |\n       |       _\\.:||:./_\n       |      /____/\\____\\\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"../interfaces/governance/IVotingPower.sol\";\nimport \"../interfaces/governance/ITokenRegistry.sol\";\nimport \"../interfaces/governance/IVotingPowerFormula.sol\";\n\n/**\n * @title Lord (prev. LockManager)\n * @dev Manages voting power for stakes that are locked within the Kingmaker protocol contracts, but not into the Crown.\n */\ncontract Lord is AccessControl {\n\t/// @notice Admin role to create voting power from locked stakes\n\tbytes32 public constant LOCKER_ROLE = keccak256(\"LOCKER_ROLE\");\n\n\t/// @notice The amount of a given locked token that has been staked, and the resulting voting power\n\tstruct LockedStake {\n\t\tuint256 amount;\n\t\tuint256 votingPower;\n\t}\n\n\t// Official record of staked balances for each account > token > locked stake\n\tmapping(address => mapping(address => LockedStake)) lockedStakes;\n\n\t/// @notice Voting power contract\n\tIVotingPower public crown;\n\n\t/// @notice modifier to restrict functions to only contracts that have been added as lockers\n\tmodifier onlyLords() {\n\t\trequire(hasRole(LOCKER_ROLE, msg.sender), \"Lord::onlyLords: Caller must have LOCKER_ROLE role\");\n\t\t_;\n\t}\n\n\t/// @notice An event that's emitted when a user's staked balance increases\n\tevent StakeLocked(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\n\t/// @notice An event that's emitted when a user's staked balance decreases\n\tevent StakeUnlocked(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\n\t/**\n\t * @notice Create new LockManager contract\n\t * @param _votingPower VotingPower prism contract\n\t * @param _roleManager address that is in charge of assigning roles\n\t */\n\tconstructor(address _votingPower, address _roleManager) {\n\t\tcrown = IVotingPower(_votingPower);\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, _roleManager);\n\t}\n\n\t/**\n\t * @notice Get total amount of tokens staked in contract by `staker`\n\t * @param staker The user with staked tokens\n\t * @param stakedToken The staked token\n\t * @return total amount staked\n\t */\n\tfunction getAmountStaked(address staker, address stakedToken) public view returns (uint256) {\n\t\treturn getStake(staker, stakedToken).amount;\n\t}\n\n\t/**\n\t * @notice Get total staked amount and voting power from `stakedToken` staked in contract by `staker`\n\t * @param staker The user with staked tokens\n\t * @param stakedToken The staked token\n\t * @return total staked\n\t */\n\tfunction getStake(address staker, address stakedToken) public view returns (LockedStake memory) {\n\t\treturn lockedStakes[staker][stakedToken];\n\t}\n\n\t/**\n\t * @notice Calculate the voting power that will result from locking `amount` of `token`\n\t * @param token token that will be locked\n\t * @param amount amount of token that will be locked\n\t * @return resulting voting power\n\t */\n\tfunction calculateVotingPower(address token, uint256 amount) public view returns (uint256) {\n\t\taddress registry = crown.tokenRegistry();\n\t\trequire(registry != address(0), \"Lord::calculateVotingPower: registry not set\");\n\n\t\taddress tokenFormulaAddress = ITokenRegistry(registry).tokenFormula(token);\n\t\trequire(tokenFormulaAddress != address(0), \"Lord::calculateVotingPower: token not supported\");\n\n\t\tIVotingPowerFormula tokenFormula = IVotingPowerFormula(tokenFormulaAddress);\n\t\treturn tokenFormula.toVotingPower(amount);\n\t}\n\n\t/**\n\t * @notice Grant voting power from locked `tokenAmount` of `token`\n\t * @param receiver recipient of voting power\n\t * @param token token that is locked\n\t * @param tokenAmount amount of token that is locked\n\t * @return votingPowerGranted amount of voting power granted\n\t */\n\tfunction grantVotingPower(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 tokenAmount\n\t) public onlyLords returns (uint256 votingPowerGranted) {\n\t\tvotingPowerGranted = calculateVotingPower(token, tokenAmount);\n\t\tlockedStakes[receiver][token].amount = lockedStakes[receiver][token].amount + tokenAmount;\n\t\tlockedStakes[receiver][token].votingPower = lockedStakes[receiver][token].votingPower + votingPowerGranted;\n\t\tcrown.addVotingPowerForLockedTokens(receiver, votingPowerGranted);\n\n\t\temit StakeLocked(receiver, token, tokenAmount, votingPowerGranted);\n\t}\n\n\t/**\n\t * @notice Remove voting power by unlocking `tokenAmount` of `token`\n\t * @param receiver holder of voting power\n\t * @param token token that is being unlocked\n\t * @param tokenAmount amount of token that is being unlocked\n\t * @return votingPowerRemoved amount of voting power removed\n\t */\n\tfunction removeVotingPower(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 tokenAmount\n\t) public onlyLords returns (uint256 votingPowerRemoved) {\n\t\trequire(lockedStakes[receiver][token].amount >= tokenAmount, \"Lord::removeVotingPower: not enough tokens staked\");\n\n\t\tLockedStake memory s = getStake(receiver, token);\n\t\tvotingPowerRemoved = (tokenAmount * s.votingPower) / s.amount;\n\t\tlockedStakes[receiver][token].amount = lockedStakes[receiver][token].amount - tokenAmount;\n\t\tlockedStakes[receiver][token].votingPower = lockedStakes[receiver][token].votingPower - votingPowerRemoved;\n\t\tcrown.removeVotingPowerForUnlockedTokens(receiver, votingPowerRemoved);\n\n\t\temit StakeUnlocked(receiver, token, tokenAmount, votingPowerRemoved);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/interfaces/governance/IVotingPowerFormula.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\ninterface IVotingPowerFormula {\n\tfunction toVotingPower(uint256 amount) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/governance/formulae/SushiLPFormula.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"../../interfaces/governance/IVotingPowerFormula.sol\";\n\n/**\n * @title SushiLPFormula\n * @dev Convert Sushi LP tokens to voting power\n */\ncontract SushiLPFormula is IVotingPowerFormula {\n\t/// @notice Current owner of this contract\n\taddress public owner;\n\n\t/// @notice Conversion rate of token to voting power (measured in bips: 10,000 bips = 1%)\n\tuint32 public conversionRate;\n\n\t/// @notice Event emitted when the owner of the contract is updated\n\tevent ChangedOwner(address indexed oldOwner, address indexed newOwner);\n\n\t/// @notice Event emitted when the conversion rate of the contract is changed\n\tevent ConversionRateChanged(uint32 oldRate, uint32 newRate);\n\n\t/// @notice only owner can call function\n\tmodifier onlyOwner {\n\t\trequire(msg.sender == owner, \"not owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Construct a new voting power formula contract\n\t * @param _owner contract owner\n\t * @param _cvrRate the conversion rate in bips\n\t */\n\tconstructor(address _owner, uint32 _cvrRate) {\n\t\towner = _owner;\n\t\temit ChangedOwner(address(0), owner);\n\n\t\tconversionRate = _cvrRate;\n\t\temit ConversionRateChanged(uint32(0), conversionRate);\n\t}\n\n\t/**\n\t * @notice Set conversion rate of contract\n\t * @param newConversionRate New conversion rate\n\t */\n\tfunction setConversionRate(uint32 newConversionRate) external onlyOwner {\n\t\temit ConversionRateChanged(conversionRate, newConversionRate);\n\t\tconversionRate = newConversionRate;\n\t}\n\n\t/**\n\t * @notice Change owner of contract\n\t * @param newOwner New owner address\n\t */\n\tfunction changeOwner(address newOwner) external onlyOwner {\n\t\temit ChangedOwner(owner, newOwner);\n\t\towner = newOwner;\n\t}\n\n\t/**\n\t * @notice Convert token amount to voting power\n\t * @param amount token amount\n\t * @return voting power amount\n\t */\n\tfunction toVotingPower(uint256 amount) external view override returns (uint256) {\n\t\treturn (amount * conversionRate) / 1000000;\n\t}\n}\n"
    },
    "contracts/governance/formulae/KingmakerFormula.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"../../interfaces/governance/IVotingPowerFormula.sol\";\n\n/**\n * @title KingmakerFormula\n * @dev Convert Kingmaker Crown governance token to its voting power equivalent to aid in gov calculations\n */\ncontract KingmakerFormula is IVotingPowerFormula {\n\t/**\n\t * @notice Convert KING amount to voting power\n\t * @dev Always converts 1-1\n\t * @param amount token amount\n\t * @return voting power amount\n\t */\n\tfunction toVotingPower(uint256 amount) external pure override returns (uint256) {\n\t\treturn amount;\n\t}\n}\n"
    },
    "contracts/governance/Crown.sol": {
      "content": "/* solhint-disable max-line-length */\n/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by crownlicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n                                                                          \n                                                                                                                      \n                                                                                                                          \n                                                                                                                    \n                                                                                                    \n                                                                                                \n                                                                                              \n                                                                                              \n                                                                                        \n                                                                                  \n                                                                                      \n                                                                                                \n                                                                                                    \n                                                                                                          \n                                                                                                  \n                                                                                  \n                                                                            \n                                                                      \n                                                                          \n                                                                  \n                                                                \n                                                                      \n                                                              \n                                                                    \n                                                            \n                                                    \n                                                          \n                                      \n                                        \n                            \n                              \n                            \n                            \n                                    \n                                      \n                                            \n                                              \n                                \n                                \n                                    \n                                    \n                                  \n                            \n                        \n                      \n                                \n                                          \n                                            \n                      \n                          \n                              \n                                            \n\n*/\n/* solhint-enable max-line-length */\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/governance/IVotingPowerFormula.sol\";\n\nimport \"../libraries/governance/LibCrownStorage.sol\";\nimport \"../libraries/governance/PrismProxyImplementation.sol\";\nimport \"../libraries/security/ReentrancyGuardUpgradeSafe.sol\";\n\n/**\n * @title CrownCourt (prev. VotingPower)\n * @dev Implementation contract for voting power prism proxy.\n * Calls should not be made directly to this contract, instead make calls to the VotingPowerPrism proxy contract.\n * The exception to this is the `become` function specified in PrismProxyImplementation.\n * This function is called once and is used by this contract to accept its role as the implementation for the prism proxy\n */\ncontract Crown is PrismProxyImplementation, ReentrancyGuardUpgradeSafe {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice An event that's emitted when a user's staked balance increases\n\tevent Staked(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\n\t/// @notice An event that's emitted when a user's staked balance decreases\n\tevent Withdrawn(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\n\t/// @notice An event that's emitted when an account's vote balance changes\n\tevent VotingPowerChanged(address indexed voter, uint256 indexed previousBalance, uint256 indexed newBalance);\n\n\t/// @notice Event emitted when the owner of the voting power contract is updated\n\tevent RoyalSuccession(address indexed oldKing, address indexed newKing);\n\n\t/// @notice restrict functions to just king (diamond owner) address\n\tmodifier onlyKing {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(crown.king == address(0) || msg.sender == crown.king, \"Crown::onlyKing: not the king\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Initialize VotingPower contract\n\t * @dev Should be called via VotingPowerPrism before calling anything else\n\t * @param _govToken address of KING token\n\t * @param _vestingContract address of Vesting contract\n\t */\n\tfunction initialize(address _govToken, address _vestingContract) public initializer {\n\t\t__ReentrancyGuard_init_unchained();\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\tcrown.govToken = ICrownGovernanceToken(_govToken);\n\t\tcrown.vesting = IVesting(_vestingContract);\n\t}\n\n\t/**\n\t * @notice Address of KING token\n\t * @return Address of KING token\n\t */\n\tfunction govToken() public view returns (address) {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\treturn address(crown.govToken);\n\t}\n\n\t/**\n\t * @notice Decimals used for voting power\n\t * @return decimals\n\t */\n\tfunction votingDecimals() public pure returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @notice Address of vesting contract\n\t * @return Address of vesting contract\n\t */\n\tfunction vestingContract() public view returns (address) {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\treturn address(crown.vesting);\n\t}\n\n\t/**\n\t * @notice Address of token registry\n\t * @return Address of token registry\n\t */\n\tfunction tokenRegistry() public view returns (address) {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\treturn address(crown.tokenRegistry);\n\t}\n\n\t/**\n\t * @notice Address of lockManager\n\t * @return Address of lockManager\n\t */\n\tfunction lockManager() public view returns (address) {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\treturn crown.lockManager;\n\t}\n\n\t/**\n\t * @notice Address of owner\n\t * @return Address of owner\n\t */\n\tfunction owner() public view returns (address) {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\treturn crown.king;\n\t}\n\n\t/**\n\t * @notice Sets token registry address\n\t * @param registry Address of token registry\n\t */\n\tfunction setTokenRegistry(address registry) public onlyKing {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\tcrown.tokenRegistry = ITokenRegistry(registry);\n\t}\n\n\t/**\n\t * @notice Sets lockManager address\n\t * @param newLockManager Address of lockManager\n\t */\n\tfunction setLockManager(address newLockManager) public onlyKing {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\tcrown.lockManager = newLockManager;\n\t}\n\n\t/**\n\t * @notice Change owner of vesting contract\n\t * @param newKing New owner address\n\t */\n\tfunction succeed(address newKing) external onlyKing {\n\t\trequire(newKing != address(0) && newKing != address(this), \"Crown::succeed: not valid address\");\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\temit RoyalSuccession(crown.king, newKing);\n\t\tcrown.king = newKing;\n\t}\n\n\t/**\n\t * @notice Stake KING tokens using offchain approvals to unlock voting power\n\t * @param amount The amount to stake\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction stakeWithPermit(\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external nonReentrant {\n\t\trequire(amount > 0, \"Crown::stakeWithPermit: cannot stake 0\");\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(crown.govToken.balanceOf(msg.sender) >= amount, \"Crown::stakeWithPermit: not enough tokens\");\n\n\t\tcrown.govToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n\n\t\t_stake(msg.sender, address(crown.govToken), amount, amount);\n\t}\n\n\t/**\n\t * @notice Stake KING tokens to unlock voting power for `msg.sender`\n\t * @param amount The amount to stake\n\t */\n\tfunction stake(uint256 amount) external nonReentrant {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(amount > 0, \"Crown::stake: cannot stake 0\");\n\t\trequire(crown.govToken.balanceOf(msg.sender) >= amount, \"Crown::stake: not enough tokens\");\n\t\trequire(\n\t\t\tcrown.govToken.allowance(msg.sender, address(this)) >= amount,\n\t\t\t\"Crown::stake: must approve tokens before staking\"\n\t\t);\n\n\t\t_stake(msg.sender, address(crown.govToken), amount, amount);\n\t}\n\n\t/**\n\t * @notice Stake LP tokens to unlock voting power for `msg.sender`\n\t * @param token The token to stake\n\t * @param amount The amount to stake\n\t */\n\tfunction stake(address token, uint256 amount) external nonReentrant {\n\t\tIERC20 lptoken = IERC20(token);\n\t\trequire(amount > 0, \"Crown::stake: cannot stake 0\");\n\t\trequire(lptoken.balanceOf(msg.sender) >= amount, \"Crown::stake: not enough tokens\");\n\t\trequire(\n\t\t\tlptoken.allowance(msg.sender, address(this)) >= amount,\n\t\t\t\"Crown::stake: must approve tokens before staking\"\n\t\t);\n\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\taddress tokenFormulaAddress = crown.tokenRegistry.tokenFormula(token);\n\t\trequire(tokenFormulaAddress != address(0), \"Crown::stake: token not supported\");\n\n\t\tIVotingPowerFormula tokenFormula = IVotingPowerFormula(tokenFormulaAddress);\n\t\tuint256 votingPower = tokenFormula.toVotingPower(amount);\n\t\t_stake(msg.sender, token, amount, votingPower);\n\t}\n\n\t/**\n\t * @notice Count vesting KING tokens toward voting power for `account`\n\t * @param account The recipient of voting power\n\t * @param amount The amount of voting power to add\n\t */\n\tfunction addVotingPowerForVestingTokens(address account, uint256 amount) external nonReentrant {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(amount > 0, \"Crown::addVPforVT: cannot add 0 voting power\");\n\t\trequire(msg.sender == address(crown.vesting), \"Crown::addVPforVT: only Monastery contract\");\n\n\t\t_increaseVotingPower(account, amount);\n\t}\n\n\t/**\n\t * @notice Remove claimed vesting KING tokens from voting power for `account`\n\t * @param account The account with voting power\n\t * @param amount The amount of voting power to remove\n\t */\n\tfunction removeVotingPowerForClaimedTokens(address account, uint256 amount) external nonReentrant {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(amount > 0, \"Crown::removeVPforCT: cannot remove 0 voting power\");\n\t\trequire(msg.sender == address(crown.vesting), \"Crown::removeVPforCT: only Monastery contract\");\n\n\t\t_decreaseVotingPower(account, amount);\n\t}\n\n\t/**\n\t * @notice Count locked tokens toward voting power for `account`\n\t * @param account The recipient of voting power\n\t * @param amount The amount of voting power to add\n\t */\n\tfunction addVotingPowerForLockedTokens(address account, uint256 amount) external nonReentrant {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(amount > 0, \"Crown::addVPforLT: cannot add 0 voting power\");\n\t\trequire(msg.sender == crown.lockManager, \"Crown::addVPforLT: only lockManager contract\");\n\n\t\t_increaseVotingPower(account, amount);\n\t}\n\n\t/**\n\t * @notice Remove unlocked tokens from voting power for `account`\n\t * @param account The account with voting power\n\t * @param amount The amount of voting power to remove\n\t */\n\tfunction removeVotingPowerForUnlockedTokens(address account, uint256 amount) external nonReentrant {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\trequire(amount > 0, \"Crown::removeVPforUT: cannot remove 0 voting power\");\n\t\trequire(msg.sender == crown.lockManager, \"Crown::removeVPforUT: only lockManager contract\");\n\n\t\t_decreaseVotingPower(account, amount);\n\t}\n\n\t/**\n\t * @notice Withdraw staked KING tokens, removing voting power for `msg.sender`\n\t * @param amount The amount to withdraw\n\t */\n\tfunction withdraw(uint256 amount) external nonReentrant {\n\t\trequire(amount > 0, \"Crown::withdraw: cannot withdraw 0\");\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\t_withdraw(msg.sender, address(crown.govToken), amount, amount);\n\t}\n\n\t/**\n\t * @notice Withdraw staked LP tokens, removing voting power for `msg.sender`\n\t * @param token The token to withdraw\n\t * @param amount The amount to withdraw\n\t */\n\tfunction withdraw(address token, uint256 amount) external nonReentrant {\n\t\trequire(amount > 0, \"Crown::withdraw: cannot withdraw 0\");\n\t\tCrownStake memory s = getStake(msg.sender, token);\n\t\tuint256 vpToWithdraw = amount.mul(s.votingPower).div(s.amount);\n\t\t_withdraw(msg.sender, token, amount, vpToWithdraw);\n\t}\n\n\t/**\n\t * @notice Get total amount of KING tokens staked in contract by `staker`\n\t * @param staker The user with staked KING\n\t * @return total KING amount staked\n\t */\n\tfunction getGovernanceTokenAmountStaked(address staker) public view returns (uint256) {\n\t\treturn getGovernanceTokenStake(staker).amount;\n\t}\n\n\t/**\n\t * @notice Get total amount of tokens staked in contract by `staker`\n\t * @param staker The user with staked tokens\n\t * @param stakedToken The staked token\n\t * @return total amount staked\n\t */\n\tfunction getAmountStaked(address staker, address stakedToken) public view returns (uint256) {\n\t\treturn getStake(staker, stakedToken).amount;\n\t}\n\n\t/**\n\t * @notice Get staked amount and voting power from KING tokens staked in contract by `staker`\n\t * @param staker The user with staked KING\n\t * @return total KING staked\n\t */\n\tfunction getGovernanceTokenStake(address staker) public view returns (CrownStake memory) {\n\t\tCrownStorage storage crown = LibCrownStorage.crownStorage();\n\t\treturn getStake(staker, address(crown.govToken));\n\t}\n\n\t/**\n\t * @notice Get total staked amount and voting power from `stakedToken` staked in contract by `staker`\n\t * @param staker The user with staked tokens\n\t * @param stakedToken The staked token\n\t * @return total staked\n\t */\n\tfunction getStake(address staker, address stakedToken) public view returns (CrownStake memory) {\n\t\tCrownStakeStorage storage ss = LibCrownStorage.stakeStorage();\n\t\treturn ss.stakes[staker][stakedToken];\n\t}\n\n\t/**\n\t * @notice Gets the current votes balance for `account`\n\t * @param account The address to get votes balance\n\t * @return The number of current votes for `account`\n\t */\n\tfunction votingPowerOf(address account) public view returns (uint256) {\n\t\tCrownCheckpointStorage storage cs = LibCrownStorage.checkpointStorage();\n\t\tuint32 nCheckpoints = cs.numCheckpoints[account];\n\t\treturn nCheckpoints > 0 ? cs.checkpoints[account][nCheckpoints - 1].votes : 0;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of votes for an account as of a block number\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t * @param account The address of the account to check\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The number of votes the account had as of the given block\n\t */\n\tfunction votingPowerOfAt(address account, uint256 blockNumber) public view returns (uint256) {\n\t\trequire(blockNumber < block.number, \"Crown::votingPowerOfAt: not yet determined\");\n\n\t\tCrownCheckpointStorage storage cs = LibCrownStorage.checkpointStorage();\n\t\tuint32 nCheckpoints = cs.numCheckpoints[account];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (cs.checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn cs.checkpoints[account][nCheckpoints - 1].votes;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (cs.checkpoints[account][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCrownCheckpoint memory cp = cs.checkpoints[account][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.votes;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn cs.checkpoints[account][lower].votes;\n\t}\n\n\t/**\n\t * @notice Internal implementation of stake\n\t * @param voter The user that is staking tokens\n\t * @param token The token to stake\n\t * @param tokenAmount The amount of token to stake\n\t * @param votingPower The amount of voting power stake translates into\n\t */\n\tfunction _stake(\n\t\taddress voter,\n\t\taddress token,\n\t\tuint256 tokenAmount,\n\t\tuint256 votingPower\n\t) internal {\n\t\tIERC20(token).safeTransferFrom(voter, address(this), tokenAmount);\n\n\t\tCrownStakeStorage storage ss = LibCrownStorage.stakeStorage();\n\t\tss.stakes[voter][token].amount = ss.stakes[voter][token].amount.add(tokenAmount);\n\t\tss.stakes[voter][token].votingPower = ss.stakes[voter][token].votingPower.add(votingPower);\n\n\t\temit Staked(voter, token, tokenAmount, votingPower);\n\n\t\t_increaseVotingPower(voter, votingPower);\n\t}\n\n\t/**\n\t * @notice Internal implementation of withdraw\n\t * @param voter The user with tokens staked\n\t * @param token The token that is staked\n\t * @param tokenAmount The amount of token to withdraw\n\t * @param votingPower The amount of voting power stake translates into\n\t */\n\tfunction _withdraw(\n\t\taddress voter,\n\t\taddress token,\n\t\tuint256 tokenAmount,\n\t\tuint256 votingPower\n\t) internal {\n\t\tCrownStakeStorage storage ss = LibCrownStorage.stakeStorage();\n\t\trequire(ss.stakes[voter][token].amount >= tokenAmount, \"Crown::_withdraw: not enough tokens staked\");\n\t\trequire(ss.stakes[voter][token].votingPower >= votingPower, \"Crown::_withdraw: not enough voting power\");\n\t\tss.stakes[voter][token].amount = ss.stakes[voter][token].amount.sub(tokenAmount);\n\t\tss.stakes[voter][token].votingPower = ss.stakes[voter][token].votingPower.sub(votingPower);\n\n\t\tIERC20(token).safeTransfer(voter, tokenAmount);\n\n\t\temit Withdrawn(voter, token, tokenAmount, votingPower);\n\n\t\t_decreaseVotingPower(voter, votingPower);\n\t}\n\n\t/**\n\t * @notice Increase voting power of voter\n\t * @param voter The voter whose voting power is increasing\n\t * @param amount The amount of voting power to increase by\n\t */\n\tfunction _increaseVotingPower(address voter, uint256 amount) internal {\n\t\tCrownCheckpointStorage storage cs = LibCrownStorage.checkpointStorage();\n\t\tuint32 checkpointNum = cs.numCheckpoints[voter];\n\t\tuint256 votingPowerOld = checkpointNum > 0 ? cs.checkpoints[voter][checkpointNum - 1].votes : 0;\n\t\tuint256 votingPowerNew = votingPowerOld.add(amount);\n\t\t_writeCheckpoint(voter, checkpointNum, votingPowerOld, votingPowerNew);\n\t}\n\n\t/**\n\t * @notice Decrease voting power of voter\n\t * @param voter The voter whose voting power is decreasing\n\t * @param amount The amount of voting power to decrease by\n\t */\n\tfunction _decreaseVotingPower(address voter, uint256 amount) internal {\n\t\tCrownCheckpointStorage storage cs = LibCrownStorage.checkpointStorage();\n\t\tuint32 checkpointNum = cs.numCheckpoints[voter];\n\t\tuint256 votingPowerOld = checkpointNum > 0 ? cs.checkpoints[voter][checkpointNum - 1].votes : 0;\n\t\tuint256 votingPowerNew = votingPowerOld.sub(amount);\n\t\t_writeCheckpoint(voter, checkpointNum, votingPowerOld, votingPowerNew);\n\t}\n\n\t/**\n\t * @notice Create checkpoint of voting power for voter at current block number\n\t * @param voter The voter whose voting power is changing\n\t * @param nCheckpoints The current checkpoint number for voter\n\t * @param oldVotes The previous voting power of this voter\n\t * @param newVotes The new voting power of this voter\n\t */\n\tfunction _writeCheckpoint(\n\t\taddress voter,\n\t\tuint32 nCheckpoints,\n\t\tuint256 oldVotes,\n\t\tuint256 newVotes\n\t) internal {\n\t\tuint32 blockNumber = _safe32(block.number, \"Crown::_writeCheckpoint: block number exceeds 32 bits\");\n\n\t\tCrownCheckpointStorage storage cs = LibCrownStorage.checkpointStorage();\n\t\tif (nCheckpoints > 0 && cs.checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tcs.checkpoints[voter][nCheckpoints - 1].votes = newVotes;\n\t\t} else {\n\t\t\tcs.checkpoints[voter][nCheckpoints] = CrownCheckpoint(blockNumber, newVotes);\n\t\t\tcs.numCheckpoints[voter] = nCheckpoints + 1;\n\t\t}\n\n\t\temit VotingPowerChanged(voter, oldVotes, newVotes);\n\t}\n\n\t/**\n\t * @notice Converts uint256 to uint32 safely\n\t * @param n Number\n\t * @param errorMessage Error message to use if number cannot be converted\n\t * @return uint32 number\n\t */\n\tfunction _safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n}\n"
    },
    "contracts/libraries/governance/PrismProxyImplementation.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./PrismProxy.sol\";\n\ncontract PrismProxyImplementation is Initializable {\n\t/**\n\t * @notice Accept invitation to be implementation contract for proxy\n\t * @param prism Prism Proxy contract\n\t */\n\tfunction become(PrismProxy prism) public {\n\t\trequire(msg.sender == prism.proxyAdmin(), \"Prism::become: only proxy admin can change implementation\");\n\t\trequire(prism.acceptProxyImplementation() == true, \"Prism::become: change not authorized\");\n\t}\n}\n"
    },
    "contracts/libraries/security/ReentrancyGuardUpgradeSafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeSafe is Initializable {\n\tbool private _notEntered;\n\n\tfunction __ReentrancyGuard_init() internal initializer {\n\t\t__ReentrancyGuard_init_unchained();\n\t}\n\n\tfunction __ReentrancyGuard_init_unchained() internal initializer {\n\t\t// Storing an initial non-zero value makes deployment a bit more\n\t\t// expensive, but in exchange the refund on every call to nonReentrant\n\t\t// will be lower in amount. Since refunds are capped to a percetange of\n\t\t// the total transaction's gas, it is best to keep them low in cases\n\t\t// like this one, to increase the likelihood of the full refund coming\n\t\t// into effect.\n\t\t_notEntered = true;\n\t}\n\n\t/**\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\n\t * Calling a `nonReentrant` function from another `nonReentrant`\n\t * function is not supported. It is possible to prevent this from happening\n\t * by making the `nonReentrant` function external, and make it call a\n\t * `private` function that does the actual work.\n\t */\n\tmodifier nonReentrant() {\n\t\t// On the first call to nonReentrant, _notEntered will be true\n\t\trequire(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n\t\t// Any calls to nonReentrant after this point will fail\n\t\t_notEntered = false;\n\n\t\t_;\n\n\t\t// By storing the original value once again, a refund is triggered (see\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\n\t\t_notEntered = true;\n\t}\n\n\tuint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/governance/CrownPrism.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [Archer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by crownlicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../libraries/governance/PrismProxy.sol\";\n\n/**\n * @title CrownPrism (prev. VotingPowerPrism)\n * @dev Storage for voting power is at this address, while contract calls are delegated to the PrismProxy implementation\n * @dev All contracts that make use of voting powers should interact with this contract only\n */\ncontract CrownPrism is PrismProxy {\n\t/**\n\t * @notice Construct a new Voting Power Prism Proxy\n\t * @dev Sets initial proxy admin to `_admin`\n\t * @param _admin Initial proxy admin\n\t */\n\tconstructor(address _admin) {\n\t\t// Initialize storage\n\t\tProxyStorage storage s = proxyStorage();\n\t\t// Set initial proxy admin\n\t\ts.admin = _admin;\n\t}\n\n\t/**\n\t * @notice Forwards call to implementation contract\n\t */\n\treceive() external payable {\n\t\t_forwardToImplementation();\n\t}\n\n\t/**\n\t * @notice Forwards call to implementation contract\n\t */\n\tfallback() external payable {\n\t\t_forwardToImplementation();\n\t}\n}\n"
    },
    "contracts/governance/Monastery.sol": {
      "content": "/*\n\n\tCopyright (c) [2020] [KINGer DAO]\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n        _\n       ///-._\n      ////////-._\n     /////////////-.\n    ////////////////`.\n   //////////////// .'`.\n  //////////////// . '.'`.\n '|`'//////////// . .'.::|`\n  :    `'///////   . '.':|\n  |  .   . `'//  ' _|- ::|\n  |.  .-._  . | .   | .'::\n  |   |:|:|   |  ' ' '.::|\n  |   |:|:|   :.  . .'.':|\n  | . |:|:| . |    .._.:::\n  :    `':|   |  ' ////-:|\n  |.    .     |  '/////////-._\n  |   .     . : .//////////////-._\n  :           : ///////////////////-._\n  |.          |////////////////////////-._\n  |    .  .   :`'//////////////////////////-._\n  | .       _.-\\\\\\\\``'//////////////////////////-._\n  |        /\\\\\\\\\\\\\\\\..``'//////////////////////////\".\n  :  .  . /. \\\\\\\\\\\\\\\\\\.  .``'///////////////////// .'`.\n  :      /  _ \\\\\\\\\\\\\\\\\\.      ``'//////////////// .  .'`.\n  | .   /  (@) \\\\\\\\\\\\\\\\\\.  . .    ``'/////////// .  '.'::|.\n {`)._ '|  _`  .\\\\\\\\\\\\\\-`:|#|  .  .   ``'//////   '. .'.:|\n  `-{_/`| ||::.  \\\\'`.:|:.|#| |#|  .      ``'/  ' .##:':::\n      `-| |||||  |`.'::|::|#| |#| |#|  .  . '| . .|##|'.:|\n        | |||||  : .'::|:.'#| |#| |#| |#|    |    |##|'::|\n        | ||||| .| .'.:|::.'' '#| |#| |#| .  :  ' |##|'.:|\n       {`\\:||||  : .'::|:_.:.  .  '#| |#|    |   .|##|':::\n        `-{_/'|_ |_.-'/}_/'-._        '#|    :.   |##:'.:|\n           `'{._('}_)-'  `-}_}(-._ .    .    |  ' '` .'::|\n                `-'          `-.} /-._    .  :   .'.'_:-'\\\n                                 `-}_}(-._   | . _.-')_(-'\n                                     `-/_)`-.:.-{ \\{-'\n                                         `-{_'_)-''\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"hardhat/console.sol\";\n\nimport \"../interfaces/governance/IVotingPower.sol\";\nimport \"../interfaces/governance/ICrownGovernanceToken.sol\";\n\n/**\n * @title Monastery (prev. Vesting)\n * @dev The vesting contract for the initial governance token distribution\n */\ncontract Monastery {\n\t/// @notice Grant definition\n\tstruct Grant {\n\t\tuint256 startTime;\n\t\tuint256 amount;\n\t\tuint16 vestingDuration;\n\t\tuint16 vestingCliff;\n\t\tuint256 totalClaimed;\n\t}\n\n\t/// @dev Used to translate vesting periods specified in days to seconds\n\tuint256 internal constant SECONDS_PER_DAY = 86400;\n\n\t/// @dev Used to limit vesting periods specified in days\n\tuint16 internal constant MAX_GRANT_VESTING_DAYS = 9 * 365;\n\n\t/// @dev Used to limit cliff periods specified in days\n\tuint16 internal constant MAX_GRANT_CLIFF_DAYS = 1 * 365;\n\n\t/// @notice Crown Governance token\n\tICrownGovernanceToken public token;\n\n\t/// @notice Voting power contract\n\tIVotingPower public votingPower;\n\n\t/// @notice Mapping of recipient address > token grant\n\tmapping(address => Grant) public tokenGrants;\n\n\t/// @notice Current clergy of this contract\n\taddress public clergy;\n\n\t/// @notice only clergy can call function\n\tmodifier onlyTheChurch {\n\t\trequire(msg.sender == clergy, \"Monastery::onlyTheChurch: not clergy\");\n\t\t_;\n\t}\n\n\t/// @notice Event emitted when a new grant is created\n\tevent GrantAdded(\n\t\taddress indexed recipient,\n\t\tuint256 indexed amount,\n\t\tuint256 startTime,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 vestingCliffInDays\n\t);\n\n\t/// @notice Event emitted when tokens are claimed by a recipient from a grant\n\tevent GrantTokensClaimed(address indexed recipient, uint256 indexed amountClaimed);\n\n\t/// @notice Event emitted when the clergy of the vesting contract is updated\n\tevent ApostolicSuccession(address indexed oldOwner, address indexed newOwner);\n\n\t/// @notice Event emitted when the voting power contract referenced by the vesting contract is updated\n\tevent ChangedVotingPower(address indexed oldContract, address indexed newContract);\n\n\t/**\n\t * @notice Construct a new Vesting contract\n\t * @param _token Address of KING token\n\t */\n\tconstructor(address _token) {\n\t\trequire(_token != address(0), \"Monastery::constructor: must be valid token address\");\n\t\ttoken = ICrownGovernanceToken(_token);\n\t\tclergy = msg.sender;\n\t}\n\n\t/**\n\t * @notice Add a new token grant\n\t * @param recipient The address that is receiving the grant\n\t * @param startTime The unix timestamp when the grant will start\n\t * @param amount The amount of tokens being granted\n\t * @param vestingDurationInDays The vesting period in days\n\t * @param vestingCliffInDays The vesting cliff duration in days\n\t */\n\tfunction addTokenGrant(\n\t\taddress recipient,\n\t\tuint256 startTime,\n\t\tuint256 amount,\n\t\tuint16 vestingDurationInDays,\n\t\tuint16 vestingCliffInDays\n\t) external onlyTheChurch {\n\t\trequire(address(votingPower) != address(0), \"Monastery::addTokenGrant: Set Voting Power contract first\");\n\t\trequire(vestingCliffInDays <= MAX_GRANT_CLIFF_DAYS, \"Monastery::addTokenGrant: cliff more than 1 year\");\n\t\trequire(vestingDurationInDays > 0, \"Monastery::addTokenGrant: duration must be > 0\");\n\t\trequire(vestingDurationInDays <= MAX_GRANT_VESTING_DAYS, \"Monastery::addTokenGrant: duration more than 9 years\");\n\t\trequire(vestingDurationInDays >= vestingCliffInDays, \"Monastery::addTokenGrant: duration < cliff\");\n\t\trequire(tokenGrants[recipient].amount == 0, \"Monastery::addTokenGrant: grant already exists for account\");\n\n\t\tuint256 amountVestedPerDay = amount / vestingDurationInDays;\n\t\trequire(amountVestedPerDay > 0, \"Monastery::addTokenGrant: amountVestedPerDay > 0\");\n\n\t\t// Transfer the grant tokens into the vesting contract\n\t\trequire(token.transferFrom(clergy, address(this), amount), \"Monastery::addTokenGrant: transfer failed\");\n\n\t\tuint256 grantStartTime = startTime == 0 ? block.timestamp : startTime;\n\n\t\tGrant memory grant =\n\t\t\tGrant({\n\t\t\t\tstartTime: grantStartTime,\n\t\t\t\tamount: amount,\n\t\t\t\tvestingDuration: vestingDurationInDays,\n\t\t\t\tvestingCliff: vestingCliffInDays,\n\t\t\t\ttotalClaimed: 0\n\t\t\t});\n\t\ttokenGrants[recipient] = grant;\n\t\temit GrantAdded(recipient, amount, grantStartTime, vestingDurationInDays, vestingCliffInDays);\n\t\tvotingPower.addVotingPowerForVestingTokens(recipient, amount);\n\t}\n\n\t/**\n\t * @notice Get token grant for recipient\n\t * @param recipient The address that has a grant\n\t * @return the grant\n\t */\n\tfunction getTokenGrant(address recipient) public view returns (Grant memory) {\n\t\treturn tokenGrants[recipient];\n\t}\n\n\t/**\n\t * @notice Calculate the vested and unclaimed tokens available for `recipient` to claim\n\t * @dev Due to rounding errors once grant duration is reached, returns the entire left grant amount\n\t * @dev Returns 0 if cliff has not been reached\n\t * @param recipient The address that has a grant\n\t * @return The amount recipient can claim\n\t */\n\tfunction calculateGrantClaim(address recipient) public view returns (uint256) {\n\t\tGrant storage tokenGrant = tokenGrants[recipient];\n\n\t\t// For grants created with a future start date, that hasn't been reached, return 0, 0\n\t\tif (block.timestamp < tokenGrant.startTime) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Check cliff was reached\n\t\tuint256 elapsedTime = block.timestamp - tokenGrant.startTime;\n\t\tuint256 elapsedDays = elapsedTime / SECONDS_PER_DAY;\n\n\t\tif (elapsedDays < tokenGrant.vestingCliff) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// If over vesting duration, all tokens vested\n\t\tif (elapsedDays >= tokenGrant.vestingDuration) {\n\t\t\tuint256 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;\n\t\t\treturn remainingGrant;\n\t\t} else {\n\t\t\tuint256 vestingDurationInSecs = uint256(tokenGrant.vestingDuration) * SECONDS_PER_DAY;\n\t\t\tuint256 vestingAmountPerSec = tokenGrant.amount / vestingDurationInSecs;\n\t\t\tuint256 amountVested = vestingAmountPerSec * elapsedTime;\n\t\t\tuint256 claimableAmount = amountVested - tokenGrant.totalClaimed;\n\t\t\treturn claimableAmount;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Calculate the vested (claimed + unclaimed) tokens for `recipient`\n\t * @dev Returns 0 if cliff has not been reached\n\t * @param recipient The address that has a grant\n\t * @return Total vested balance (claimed + unclaimed)\n\t */\n\tfunction vestedBalance(address recipient) external view returns (uint256) {\n\t\tGrant storage tokenGrant = tokenGrants[recipient];\n\n\t\t// For grants created with a future start date, that hasn't been reached, return 0, 0\n\t\tif (block.timestamp < tokenGrant.startTime) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Check cliff was reached\n\t\tuint256 elapsedTime = block.timestamp - tokenGrant.startTime;\n\t\tuint256 elapsedDays = elapsedTime / SECONDS_PER_DAY;\n\n\t\tif (elapsedDays < tokenGrant.vestingCliff) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// If over vesting duration, all tokens vested\n\t\tif (elapsedDays >= tokenGrant.vestingDuration) {\n\t\t\treturn tokenGrant.amount;\n\t\t} else {\n\t\t\tuint256 vestingDurationInSecs = uint256(tokenGrant.vestingDuration) * SECONDS_PER_DAY;\n\t\t\tuint256 vestingAmountPerSec = tokenGrant.amount / vestingDurationInSecs;\n\t\t\tuint256 amountVested = vestingAmountPerSec * elapsedTime;\n\t\t\treturn amountVested;\n\t\t}\n\t}\n\n\t/**\n\t * @notice The balance claimed by `recipient`\n\t * @param recipient The address that has a grant\n\t * @return the number of claimed tokens by `recipient`\n\t */\n\tfunction claimedBalance(address recipient) external view returns (uint256) {\n\t\tGrant storage tokenGrant = tokenGrants[recipient];\n\t\treturn tokenGrant.totalClaimed;\n\t}\n\n\t/**\n\t * @notice Allows a grant recipient to claim their vested tokens\n\t * @dev Errors if no tokens have vested\n\t * @dev It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\n\t * @param recipient The address that has a grant\n\t */\n\tfunction claimVestedTokens(address recipient) external {\n\t\tuint256 amountVested = calculateGrantClaim(recipient);\n\t\trequire(amountVested > 0, \"Monastery::claimVested: amountVested is 0\");\n\t\tvotingPower.removeVotingPowerForClaimedTokens(recipient, amountVested);\n\n\t\tGrant storage tokenGrant = tokenGrants[recipient];\n\t\ttokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed + amountVested);\n\n\t\trequire(token.transfer(recipient, amountVested), \"Monastery::claimVested: transfer failed\");\n\t\temit GrantTokensClaimed(recipient, amountVested);\n\t}\n\n\t/**\n\t * @notice Calculate the number of tokens that will vest per day for the given recipient\n\t * @param recipient The address that has a grant\n\t * @return Number of tokens that will vest per day\n\t */\n\tfunction tokensVestedPerDay(address recipient) public view returns (uint256) {\n\t\tGrant storage tokenGrant = tokenGrants[recipient];\n\t\treturn tokenGrant.amount / uint256(tokenGrant.vestingDuration);\n\t}\n\n\t/**\n\t * @notice Set voting power contract address\n\t * @param newContract New voting power contract address\n\t */\n\tfunction setVotingPowerContract(address newContract) external onlyTheChurch {\n\t\trequire(\n\t\t\tnewContract != address(0) && newContract != address(this) && newContract != address(token),\n\t\t\t\"Monastery::setVotingPowerContract: not valid contract\"\n\t\t);\n\t\trequire(\n\t\t\tIVotingPower(newContract).govToken() == address(token),\n\t\t\t\"Monastery::setVotingPowerContract: voting power not initialized\"\n\t\t);\n\n\t\taddress oldContract = address(votingPower);\n\t\tvotingPower = IVotingPower(newContract);\n\t\temit ChangedVotingPower(oldContract, newContract);\n\t}\n\n\t/**\n\t * @notice Change clergy of vesting contract\n\t * @param newOwner New clergy address\n\t */\n\tfunction changeClergy(address newOwner) external onlyTheChurch {\n\t\trequire(\n\t\t\tnewOwner != address(0) && newOwner != address(this) && newOwner != address(token),\n\t\t\t\"Monastery::changeClergy: not valid address\"\n\t\t);\n\n\t\taddress oldOwner = clergy;\n\t\tclergy = newOwner;\n\t\temit ApostolicSuccession(oldOwner, newOwner);\n\t}\n}\n"
    },
    "contracts/Kingmaker.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"./libraries/diamond/LibDiamond.sol\";\nimport \"./libraries/diamond/LibDiamondOwnership.sol\";\n\nimport \"./interfaces/diamond/IDiamondLoupe.sol\";\nimport \"./interfaces/diamond/IDiamondCut.sol\";\nimport \"./interfaces/access/IERC173.sol\";\n\ncontract Kingmaker {\n\t// more arguments are added to this struct\n\t// this avoids stack too deep errors\n\tstruct CrownArgs {\n\t\taddress king;\n\t}\n\n\tconstructor(IDiamondCut.FacetCut[] memory _diamondCut, CrownArgs memory _args) payable {\n\t\tLibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\n\t\tLibDiamondOwnership.setContractOwner(_args.king);\n\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n\t\t// adding ERC165 data\n\t\tds.supportedInterfaces[type(IERC165).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\t}\n\n\t// Find facet for function that is called and execute the\n\t// function if a facet is found and return any value.\n\tfallback() external payable {\n\t\tLibDiamondStorage.DiamondStorage storage ds;\n\t\tbytes32 position = LibDiamondStorage.DIAMOND_STORAGE_POSITION;\n\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\n\t\taddress facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\t\trequire(facet != address(0), \"Diamond: Function does not exist\");\n\n\t\tassembly {\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(0, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(0, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n\n\treceive() external payable {}\n}\n"
    },
    "contracts/libraries/diamond/LibDiamond.sol": {
      "content": "/*\n\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./LibDiamondStorage.sol\";\n\nimport \"../../interfaces/diamond/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n\t// Internal function version of diamondCut.\n\t// Like normal proxies you can also execute a function at the time of an upgrade.\n\tfunction diamondCut(\n\t\tIDiamondCut.FacetCut[] memory _diamondCut,\n\t\taddress _init,\n\t\tbytes memory _calldata\n\t) internal {\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n\t\t\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n\t\t\tif (action == IDiamondCut.FacetCutAction.Add) {\n\t\t\t\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\n\t\t\t\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\n\t\t\t\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else {\n\t\t\t\trevert(\"DiamondCut: Incorrect FacetCutAction\");\n\t\t\t}\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tinitializeDiamondCut(_init, _calldata);\n\t}\n\n\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\t// uint16 selectorCount = uint16(diamondStorage().selectors.length);\n\t\trequire(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n\t\tuint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\tenforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n\t\t\tds.facetAddresses.push(_facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress == address(0), \"DiamondCut: Can't add function that already exists\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n\t\t\tds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n\t\t\tds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\trequire(_facetAddress != address(0), \"DiamondCut: Add facet can't be address(0)\");\n\t\tuint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\tenforceHasContractCode(_facetAddress, \"DiamondCut: New facet has no code\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n\t\t\tds.facetAddresses.push(_facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress != _facetAddress, \"DiamondCut: Can't replace function with same function\");\n\t\t\tremoveFunction(oldFacetAddress, selector);\n\t\t\t// add function\n\t\t\tds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n\t\t\tds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"DiamondCut: No selectors in facet to cut\");\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\t// if function does not exist then do nothing and return\n\t\trequire(_facetAddress == address(0), \"DiamondCut: Remove facet address must be address(0)\");\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\tremoveFunction(oldFacetAddress, selector);\n\t\t}\n\t}\n\n\tfunction removeFunction(address _facetAddress, bytes4 _selector) internal {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\trequire(_facetAddress != address(0), \"DiamondCut: Can't remove function that doesn't exist\");\n\t\t// an immutable function is a function defined directly in a diamond\n\t\trequire(_facetAddress != address(this), \"DiamondCut: Can't remove immutable function\");\n\t\t// replace selector with last selector, then delete last selector\n\t\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n\t\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\t\t// if not the same then replace _selector with lastSelector\n\t\tif (selectorPosition != lastSelectorPosition) {\n\t\t\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n\t\t\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\n\t\t}\n\t\t// delete the last selector\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n\t\tdelete ds.selectorToFacetAndPosition[_selector];\n\n\t\t// if no more selectors for facet address then delete the facet address\n\t\tif (lastSelectorPosition == 0) {\n\t\t\t// replace facet address with last facet address and delete last facet address\n\t\t\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n\t\t\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t\tif (facetAddressPosition != lastFacetAddressPosition) {\n\t\t\t\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n\t\t\t\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n\t\t\t\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\n\t\t\t}\n\t\t\tds.facetAddresses.pop();\n\t\t\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t}\n\t}\n\n\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\n\t\tif (_init == address(0)) {\n\t\t\trequire(_calldata.length == 0, \"DiamondCut: _init is address(0) but_calldata is not empty\");\n\t\t} else {\n\t\t\trequire(_calldata.length > 0, \"DiamondCut: _calldata is empty but _init is not address(0)\");\n\t\t\tif (_init != address(this)) {\n\t\t\t\tenforceHasContractCode(_init, \"DiamondCut: _init address has no code\");\n\t\t\t}\n\t\t\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\n\t\t\tif (!success) {\n\t\t\t\tif (error.length > 0) {\n\t\t\t\t\t// bubble up the error\n\t\t\t\t\trevert(string(error));\n\t\t\t\t} else {\n\t\t\t\t\trevert(\"DiamondCut: _init function reverted\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n\t\tuint256 contractSize;\n\t\tassembly {\n\t\t\tcontractSize := extcodesize(_contract)\n\t\t}\n\t\trequire(contractSize > 0, _errorMessage);\n\t}\n}\n"
    },
    "contracts/libraries/diamond/LibDiamondOwnership.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./LibDiamondStorage.sol\";\n\nlibrary LibDiamondOwnership {\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tfunction setContractOwner(address _newOwner) internal {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n\t\taddress previousOwner = ds.contractOwner;\n\t\trequire(previousOwner != _newOwner, \"Previous owner and new owner must be different\");\n\n\t\tds.contractOwner = _newOwner;\n\n\t\temit OwnershipTransferred(previousOwner, _newOwner);\n\t}\n\n\tfunction contractOwner() internal view returns (address contractOwner_) {\n\t\tcontractOwner_ = LibDiamondStorage.diamondStorage().contractOwner;\n\t}\n\n\tfunction enforceIsContractOwner() internal view {\n\t\trequire(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \"Diamond: Must be contract owner\");\n\t}\n\n\t/*\n\t * Helpful modifier, Ownable-style\n\t */\n\tmodifier onlyOwner {\n\t\trequire(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \"Diamond: Must be contract owner\");\n\t\t_;\n\t}\n}\n"
    },
    "contracts/interfaces/diamond/IDiamondLoupe.sol": {
      "content": "/*\n\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\n/**\n * A loupe is akin to a small magnifying glass used to look at diamonds and their facets.\n */\ninterface IDiamondLoupe {\n\t/// These functions are expected to be called frequently by off-chain code.\n\t/// (and almost never by on-chain code)\n\tstruct Facet {\n\t\taddress facetAddress;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Gets all facet addresses and their four byte function selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view returns (Facet[] memory facets_);\n\n\t/// @notice Gets all the function selectors supported by a specific facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view returns (address[] memory facetAddresses_);\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/diamond/IDiamondCut.sol": {
      "content": "/*\n\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\n/**\n * Each diamond cut is a powerful cutter used to alter diamond contracts (add, replace, remove facets).\n */\ninterface IDiamondCut {\n\tenum FacetCutAction { Add, Replace, Remove }\n\t// Add=0, Replace=1, Remove=2\n\n\tstruct FacetCut {\n\t\taddress facetAddress;\n\t\tFacetCutAction action;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(\n\t\tFacetCut[] calldata _diamondCut,\n\t\taddress _init,\n\t\tbytes calldata _calldata\n\t) external;\n\n\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n\t/// @dev This emits when ownership of a contract changes.\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/// @notice Get the address of the owner\n\t/// @return owner_ The address of the owner.\n\tfunction owner() external view returns (address owner_);\n\n\t/// @notice Set the address of the new owner of the contract\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\n\t/// @param _newOwner The address of the new owner of the contract\n\tfunction transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/libraries/diamond/LibDiamondStorage.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nlibrary LibDiamondStorage {\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n\tstruct FacetAddressAndPosition {\n\t\taddress facetAddress;\n\t\tuint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n\t}\n\n\tstruct FacetFunctionSelectors {\n\t\tbytes4[] functionSelectors;\n\t\tuint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n\t}\n\n\tstruct DiamondStorage {\n\t\t// maps function selector to the facet address and\n\t\t// the position of the selector in the facetFunctionSelectors.selectors array\n\t\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n\t\t// maps facet addresses to function selectors\n\t\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n\t\t// facet addresses\n\t\taddress[] facetAddresses;\n\t\t// Used to query if a contract implements an interface.\n\t\t// Used to implement ERC-165.\n\t\tmapping(bytes4 => bool) supportedInterfaces;\n\t\t// owner of the contract\n\t\taddress contractOwner;\n\t}\n\n\tfunction diamondStorage() internal pure returns (DiamondStorage storage ds) {\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\t}\n}\n"
    },
    "contracts/facets/diamond/OwnershipFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../../interfaces/access/IERC173.sol\";\n\nimport \"../../libraries/diamond/LibDiamondOwnership.sol\";\n\ncontract OwnershipFacet is IERC173 {\n\tfunction transferOwnership(address _newOwner) external override {\n\t\tLibDiamondOwnership.enforceIsContractOwner();\n\t\tLibDiamondOwnership.setContractOwner(_newOwner);\n\t}\n\n\tfunction owner() external view override returns (address owner_) {\n\t\towner_ = LibDiamondOwnership.contractOwner();\n\t}\n}\n"
    },
    "contracts/facets/diamond/DiamondLoupeFacet.sol": {
      "content": "/*\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"../../interfaces/diamond/IDiamondCut.sol\";\nimport \"../../interfaces/diamond/IDiamondLoupe.sol\";\n\nimport \"../../libraries/diamond/LibDiamondStorage.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n\t/// @notice Gets all facets and their selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view override returns (Facet[] memory facets_) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tuint256 numFacets = ds.facetAddresses.length;\n\t\tfacets_ = new Facet[](numFacets);\n\t\tfor (uint256 i; i < numFacets; i++) {\n\t\t\taddress facetAddress_ = ds.facetAddresses[i];\n\t\t\tfacets_[i].facetAddress = facetAddress_;\n\t\t\tfacets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n\t\t}\n\t}\n\n\t/// @notice Gets all the function selectors provided by a facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (bytes4[] memory facetFunctionSelectors_)\n\t{\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tfacetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n\t}\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view override returns (address[] memory facetAddresses_) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tfacetAddresses_ = ds.facetAddresses;\n\t}\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tfacetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n\t}\n\n\t// This implements ERC-165.\n\tfunction supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\treturn ds.supportedInterfaces[_interfaceId];\n\t}\n}\n"
    },
    "contracts/facets/diamond/DiamondCutFacet.sol": {
      "content": "/*\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../../libraries/diamond/LibDiamond.sol\";\nimport \"../../libraries/diamond/LibDiamondOwnership.sol\";\n\nimport \"../../interfaces/diamond/IDiamondCut.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n\t/// @notice Add/replace/remove any number of functions and optionally execute a function, with DELEGATECALL\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _callData A contract call with function selector and arguments is executed, with DELEGATECALL, at _init\n\tfunction diamondCut(\n\t\tFacetCut[] calldata _diamondCut,\n\t\taddress _init,\n\t\tbytes calldata _callData\n\t) external override {\n\t\tLibDiamondOwnership.enforceIsContractOwner();\n\t\tLibDiamond.diamondCut(_diamondCut, _init, _callData);\n\t}\n}\n"
    },
    "contracts/testing/TestToken.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"../tokens/UnlimitedApprovalERC20.sol\";\n\ncontract TestToken is UnlimitedApprovalERC20 {\n\tconstructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n\t/**\n\t * Allows anyone to arbitrarily mint themselves tokens for testing.\n\t */\n\tfunction mint(uint256 amount) public returns (bool) {\n\t\t_mint(msg.sender, amount);\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20(\"ERC20Mock\", \"MOCK\") {\n\tbool public transferFromCalled = false;\n\n\tbool public transferCalled = false;\n\taddress public transferRecipient = address(0);\n\tuint256 public transferAmount = 0;\n\n\tfunction mint(address user, uint256 amount) public {\n\t\t_mint(user, amount);\n\t}\n\n\tfunction burnFrom(address user, uint256 amount) public {\n\t\t_burn(user, amount);\n\t}\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\ttransferFromCalled = true;\n\n\t\treturn super.transferFrom(sender, recipient, amount);\n\t}\n\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\ttransferCalled = true;\n\t\ttransferRecipient = recipient;\n\t\ttransferAmount = amount;\n\n\t\treturn super.transfer(recipient, amount);\n\t}\n}\n"
    },
    "contracts/governance/Alchemist.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n               *    .\n        '  +   ___    @    .\n            .-\" __\"-.   +\n    *      /:.'`__`'.\\       '\n        . |:: .'_ `. :|   *\n   @      |:: '._' : :| .\n      +    \\:'.__.' :/       '\n            /`-...-'\\  '   +\n   '       /         \\   .    @\n     *     `-.,___,.-'\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * @title Alchemist\n * @dev Allows for the initial distribution of the governance token and the bootstrapping of initial locked liquidity.\n *      See also Mines.sol\n */\ncontract Alchemist {\n\n}\n"
    },
    "contracts/governance/Mines.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n                   _,-----------._\n               _,-'_,-----------._`-._\n            ,'_,-'  ___________  `-._`.\n          ,','  _,-'___________`-._  `.`.\n        ,','  ,'_,-'     .     `-._`.  `.`.\n       /,'  ,','        >|<        `.`.  `.\\\n      //  ,','      ><  ,^.  ><      `.`.  \\\\\n     //  /,'      ><   / | \\   ><      `.\\  \\\\\n    //  //      ><    \\/\\^/\\/    ><      \\\\  \\\\\n   ;;  ;;              `---'              ::  ::\n   ||  ||              (____              ||  ||\n  _||__||_            ,'----.            _||__||_\n (o.____.o)____        `---'        ____(o.____.o)\n   |    | /,--.)                   (,--.\\ |    |\n   |    |((  -`___               ___`   ))|    |\n   |    | \\\\,'',  `.           .'  .``.// |    |\n   |    |  // (___,'.         .'.___) \\\\  |    |\n  /|    | ;;))  ____) .     . (____  ((\\\\ |    |\\\n  \\|.__ | ||/ .'.--.\\/       `/,--.`. \\;: | __,|;\n   |`-,`;.| :/ /,'  `)-'   `-('  `.\\ \\: |.;',-'|\n   |   `..  ' / \\__.'         `.__/ \\ `  ,.'   |\n   |    |,\\  /,                     ,\\  /,|    |\n   |    ||: : )          .          ( : :||    |\n  /|    |:; |/  .      ./|\\,      ,  \\| :;|    |\\\n  \\|.__ |/  :  ,/-    <--:-->    ,\\.  ;  \\| __,|;\n   |`-.``:   `'/-.     '\\|/`     ,-\\`;   ;'',-'|\n   |   `..   ,' `'       '       `  `.   ,.'   |\n   |    ||  :                         :  ||    |\n   |    ||  |                         |  ||    |\n   |    ||  |                         |  ||    |\n   |    |'  |            _            |  `|    |\n   |    |   |          '|))           |   |    |\n   ;____:   `._        `'           _,'   ;____:\n  {______}     \\___________________/     {______}\n  |______|_______________________________|______|\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * @title Mines\n * @dev Manages permanently-locked LPs throughout the Kingmaker ecosystem\n */\ncontract Mines {\n\n}\n"
    },
    "contracts/interfaces/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/KingmakerStorage.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/// @notice ProtocolStorage struct\nstruct ProtocolStorage {\n\t// Crown owner\n\taddress king;\n}\n\nlibrary KingmakerStorage {\n\tbytes32 constant KINGMAKER_PROTOCOL_STORAGE = keccak256(\"kingmaker.protocol.storage\");\n\n\t/**\n\t * @notice Load and return protocol storage struct\n\t * @return proto ProtocolStorage struct\n\t */\n\tfunction protoStorage() internal pure returns (ProtocolStorage storage proto) {\n\t\tbytes32 position = KINGMAKER_PROTOCOL_STORAGE;\n\t\tassembly {\n\t\t\tproto.slot := position\n\t\t}\n\t}\n}\n"
    },
    "contracts/mock/Test1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ncontract Test1Facet {\n\tevent TestEvent(address something);\n\n\tfunction test1Func1() external {}\n\n\tfunction test1Func2() external {}\n\n\tfunction test1Func3() external {}\n\n\tfunction test1Func4() external {}\n\n\tfunction test1Func5() external {}\n\n\tfunction test1Func6() external {}\n\n\tfunction test1Func7() external {}\n\n\tfunction test1Func8() external {}\n\n\tfunction test1Func9() external {}\n\n\tfunction test1Func10() external {}\n\n\tfunction test1Func11() external {}\n\n\tfunction test1Func12() external {}\n\n\tfunction test1Func13() external {}\n\n\tfunction test1Func14() external {}\n\n\tfunction test1Func15() external {}\n\n\tfunction test1Func16() external {}\n\n\tfunction test1Func17() external {}\n\n\tfunction test1Func18() external {}\n\n\tfunction test1Func19() external {}\n\n\tfunction test1Func20() external {}\n\n\tfunction supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/mock/Test2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ncontract Test1Facet {\n\tfunction test2Func1() external {}\n\n\tfunction test2Func2() external {}\n\n\tfunction test2Func3() external {}\n\n\tfunction test2Func4() external {}\n\n\tfunction test2Func5() external {}\n\n\tfunction test2Func6() external {}\n\n\tfunction test2Func7() external {}\n\n\tfunction test2Func8() external {}\n\n\tfunction test2Func9() external {}\n\n\tfunction test2Func10() external {}\n\n\tfunction test2Func11() external {}\n\n\tfunction test2Func12() external {}\n\n\tfunction test2Func13() external {}\n\n\tfunction test2Func14() external {}\n\n\tfunction test2Func15() external {}\n\n\tfunction test2Func16() external {}\n\n\tfunction test2Func17() external {}\n\n\tfunction test2Func18() external {}\n\n\tfunction test2Func19() external {}\n\n\tfunction test2Func20() external {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
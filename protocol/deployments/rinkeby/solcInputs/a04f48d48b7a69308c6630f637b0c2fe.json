{
  "language": "Solidity",
  "sources": {
    "contracts/facets/governance/GovernanceToken.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"hardhat/console.sol\";\n\nimport \"../../interfaces/token/ERC20/IERC20.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\n\n/**\n * @title KING\n * @dev The governance token for the Kingmaker protocol\n * @notice ERC-20 with supply controls + add-ons to allow for offchain signing (see EIP-712, EIP-2612, and EIP-3009)\n */\ncontract GovernanceToken is IERC20 {\n\tusing SafeMath for uint256;\n\n\t/// @notice EIP-20 token name for this token\n\tstring public name = \"Kingmaker Governance Token\";\n\n\t/// @notice EIP-20 token symbol for this token\n\tstring public symbol = \"KING\";\n\n\t/// @notice EIP-20 token decimals for this token\n\tuint8 public constant decimals = 18;\n\n\t/// @notice Total number of tokens in circulation\n\tuint256 public override totalSupply = 90000e18; // 90 thousands units\n\n\t/// @notice Address which may mint/burn tokens\n\taddress public supplyManager;\n\n\t/// @notice Address which may change token metadata\n\taddress public metadataManager;\n\n\t/// @notice The timestamp after which a supply change may occur\n\tuint256 public supplyChangeAllowedAfter;\n\n\t/// @notice The initial minimum waiting time for changing the token supply\n\tuint32 public supplyChangeWaitingPeriod = 1 days * 365; // 1 year\n\n\t/// @notice Hard cap on the minimum waiting time for changing the token supply\n\tuint32 public constant supplyChangeWaitingPeriodMinimum = 1 days * 90;\n\t// solhint-disable-next-line max-line-length\n\t/// @notice Cap on the total amount that can be minted at each mint (measured in bips: 10,000 bips = 1% of current totalSupply)\n\tuint32 public mintCap = 900000;\n\n\t/// @dev Allowance amounts on behalf of others\n\tmapping(address => mapping(address => uint256)) internal allowances;\n\n\t/// @dev Official record of token balances for each account\n\tmapping(address => uint256) internal balances;\n\n\t/// @notice The EIP-712 typehash for the contract's domain\n\t/// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n\t/// @notice The EIP-712 version hash\n\t/// keccak256(\"1\");\n\tbytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n\t/// @notice The EIP-712 typehash for permit (EIP-2612)\n\t/// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/// @notice The EIP-712 typehash for transferWithAuthorization (EIP-3009)\n\t// solhint-disable-next-line max-line-length\n\t/// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n\t\t0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/// @notice The EIP-712 typehash for receiveWithAuthorization (EIP-3009)\n\t// solhint-disable-next-line max-line-length\n\t/// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\n\t\t0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/// @notice A record of states for signing / validating signatures\n\tmapping(address => uint256) public nonces;\n\n\t/// @dev authorizer address > nonce > state (true = used / false = unused)\n\tmapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n\t/// @notice An event that's emitted when the mintCap is changed\n\tevent MintCapChanged(uint32 indexed oldMintCap, uint32 indexed newMintCap);\n\n\t/// @notice An event that's emitted when the supplyManager address is changed\n\tevent SupplyManagerChanged(address indexed oldManager, address indexed newManager);\n\n\t/// @notice An event that's emitted when the supplyChangeWaitingPeriod is changed\n\tevent SupplyChangeWaitingPeriodChanged(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\n\n\t/// @notice An event that's emitted when the metadataManager address is changed\n\tevent MetadataManagerChanged(address indexed oldManager, address indexed newManager);\n\n\t/// @notice An event that's emitted when the token name and symbol are changed\n\tevent TokenMetaUpdated(string indexed name, string indexed symbol);\n\n\t/// @notice An event that's emitted whenever an authorized transfer occurs\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @notice Construct a new KING token\n\t * @param _metadataManager The address with the ability to alter the token metadata\n\t * @param _supplyManager The address with the ability to mint more tokens\n\t * @param _firstSupplyChangeAllowed The timestamp after which the first supply change may occur\n\t */\n\tconstructor(\n\t\taddress _metadataManager,\n\t\taddress _supplyManager,\n\t\tuint256 _firstSupplyChangeAllowed\n\t) {\n\t\trequire(\n\t\t\t_firstSupplyChangeAllowed >= block.timestamp,\n\t\t\t\"KING::constructor: minting can only begin after deployment\"\n\t\t);\n\n\t\tbalances[msg.sender] = totalSupply;\n\t\temit Transfer(address(0), msg.sender, totalSupply);\n\n\t\tsupplyChangeAllowedAfter = _firstSupplyChangeAllowed;\n\t\tsupplyManager = _supplyManager;\n\t\temit SupplyManagerChanged(address(0), _supplyManager);\n\n\t\tmetadataManager = _metadataManager;\n\t\temit MetadataManagerChanged(address(0), metadataManager);\n\t}\n\n\t/**\n\t * @notice Change the supplyManager address\n\t * @param newSupplyManager The address of the new supply manager\n\t * @return true if successful\n\t */\n\tfunction setSupplyManager(address newSupplyManager) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setSupplyManager: only SM can change SM\");\n\t\temit SupplyManagerChanged(supplyManager, newSupplyManager);\n\t\tsupplyManager = newSupplyManager;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Change the metadataManager address\n\t * @param newMetadataManager The address of the new metadata manager\n\t * @return true if successful\n\t */\n\tfunction setMetadataManager(address newMetadataManager) external returns (bool) {\n\t\trequire(msg.sender == metadataManager, \"KING::setMetadataManager: only MM can change MM\");\n\t\temit MetadataManagerChanged(metadataManager, newMetadataManager);\n\t\tmetadataManager = newMetadataManager;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Mint new tokens\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to be minted\n\t * @return Boolean indicating success of mint\n\t */\n\tfunction mint(address dst, uint256 amount) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::mint: only the supplyManager can mint\");\n\t\trequire(dst != address(0), \"KING::mint: cannot transfer to the zero address\");\n\t\trequire(amount <= (totalSupply * (mintCap)) / (1000000), \"KING::mint: exceeded mint cap\");\n\t\trequire(block.timestamp >= supplyChangeAllowedAfter, \"KING::mint: minting not allowed yet\");\n\n\t\t// update the next supply change allowed timestamp\n\t\tsupplyChangeAllowedAfter = block.timestamp + supplyChangeWaitingPeriod;\n\n\t\t// mint the amount\n\t\t_mint(dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Burn tokens\n\t * @param src The account that will burn tokens\n\t * @param amount The number of tokens to be burned\n\t * @return Boolean indicating success of burn\n\t */\n\tfunction burn(address src, uint256 amount) external returns (bool) {\n\t\taddress spender = msg.sender;\n\t\trequire(spender == supplyManager, \"KING::burn: only the supplyManager can burn\");\n\t\trequire(src != address(0), \"KING::burn: cannot transfer from the zero address\");\n\t\trequire(block.timestamp >= supplyChangeAllowedAfter, \"KING::burn: burning not allowed yet\");\n\n\t\tuint256 spenderAllowance = allowances[src][spender];\n\t\t// check allowance and reduce by amount\n\t\tif (spender != src && spenderAllowance != type(uint256).max) {\n\t\t\tuint256 newAllowance = spenderAllowance.sub(amount, \"KING::burn: burn amount exceeds allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t// update the next supply change allowed timestamp\n\t\tsupplyChangeAllowedAfter = block.timestamp + supplyChangeWaitingPeriod;\n\n\t\t// burn the amount\n\t\t_burn(src, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Set the maximum amount of tokens that can be minted at once\n\t * @param newCap The new mint cap in bips (10,000 bips = 1% of totalSupply)\n\t * @return true if successful\n\t */\n\tfunction setMintCap(uint16 newCap) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setMintCap: only SM can change mint cap\");\n\t\temit MintCapChanged(mintCap, newCap);\n\t\tmintCap = newCap;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Set the minimum time between supply changes\n\t * @param period The new supply change waiting period\n\t * @return true if succssful\n\t */\n\tfunction setSupplyChangeWaitingPeriod(uint32 period) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setSupplyChangeWaitingPeriod: only SM can change waiting period\");\n\t\trequire(\n\t\t\tperiod >= supplyChangeWaitingPeriodMinimum,\n\t\t\t\"KING::setSupplyChangeWaitingPeriod: waiting period must be > minimum\"\n\t\t);\n\t\temit SupplyChangeWaitingPeriodChanged(supplyChangeWaitingPeriod, period);\n\t\tsupplyChangeWaitingPeriod = period;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Update the token name and symbol\n\t * @param tokenName The new name for the token\n\t * @param tokenSymbol The new symbol for the token\n\t * @return true if successful\n\t */\n\tfunction updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external returns (bool) {\n\t\trequire(msg.sender == metadataManager, \"KING::updateTokenMeta: only MM can update token metadata\");\n\t\tname = tokenName;\n\t\tsymbol = tokenSymbol;\n\t\temit TokenMetaUpdated(name, symbol);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n\t * @param account The address of the account holding the funds\n\t * @param spender The address of the account spending the funds\n\t * @return The number of tokens approved\n\t */\n\tfunction allowance(address account, address spender) external view override returns (uint256) {\n\t\treturn allowances[account][spender];\n\t}\n\n\t/**\n\t * @notice Approve `spender` to transfer up to `amount` from `src`\n\t * @dev This will overwrite the approval amount for `spender`\n\t * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\t * It is recommended to use increaseAllowance and decreaseAllowance instead\n\t * @param spender The address of the account which may transfer tokens\n\t * @param amount The number of tokens that are approved (2^256-1 means infinite)\n\t * @return Whether or not the approval succeeded\n\t */\n\tfunction approve(address spender, uint256 amount) external override returns (bool) {\n\t\t_approve(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Increase the allowance by a given amount\n\t * @param spender Spender's address\n\t * @param addedValue Amount of increase in allowance\n\t * @return True if successful\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n\t\t_increaseAllowance(msg.sender, spender, addedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Decrease the allowance by a given amount\n\t * @param spender Spender's address\n\t * @param subtractedValue Amount of decrease in allowance\n\t * @return True if successful\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n\t\t_decreaseAllowance(msg.sender, spender, subtractedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Triggers an approval from owner to spender\n\t * @param owner The address to approve from\n\t * @param spender The address to be approved\n\t * @param value The number of tokens that are approved (2^256-1 means infinite)\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(deadline >= block.timestamp, \"KING::permit: signature expired\");\n\n\t\tbytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n\t\t_validateSignedData(owner, encodeData, v, r, s);\n\n\t\t_approve(owner, spender, value);\n\t}\n\n\t/**\n\t * @notice Get the number of tokens held by the `account`\n\t * @param account The address of the account to get the balance of\n\t * @return The number of tokens held\n\t */\n\tfunction balanceOf(address account) external view override returns (uint256) {\n\t\treturn balances[account];\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transfer(address dst, uint256 amount) external override returns (bool) {\n\t\t_transferTokens(msg.sender, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `src` to `dst`\n\t * @param src The address of the source account\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transferFrom(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 amount\n\t) external override returns (bool) {\n\t\taddress spender = msg.sender;\n\t\tuint256 spenderAllowance = allowances[src][spender];\n\n\t\tif (spender != src && spenderAllowance != type(uint256).max) {\n\t\t\tuint256 newAllowance = spenderAllowance.sub(amount, \"KING::transferFrom: transfer amount exceeds allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t_transferTokens(src, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer tokens with a signed authorization\n\t * @param from Payer's address (Authorizer)\n\t * @param to Payee's address\n\t * @param value Amount to be transferred\n\t * @param validAfter The time after which this is valid (unix time)\n\t * @param validBefore The time before which this is valid (unix time)\n\t * @param nonce Unique nonce\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(block.timestamp > validAfter, \"KING::transferWithAuth: auth not yet valid\");\n\t\trequire(block.timestamp < validBefore, \"KING::transferWithAuth: auth expired\");\n\t\trequire(!authorizationState[from][nonce], \"KING::transferWithAuth: auth already used\");\n\n\t\tbytes32 encodeData =\n\t\t\tkeccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n\t\t_validateSignedData(from, encodeData, v, r, s);\n\n\t\tauthorizationState[from][nonce] = true;\n\t\temit AuthorizationUsed(from, nonce);\n\n\t\t_transferTokens(from, to, value);\n\t}\n\n\t/**\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t * @dev This has an additional check to ensure that the payee's address matches\n\t * the caller of this function to prevent front-running attacks.\n\t * @param from Payer's address (Authorizer)\n\t * @param to Payee's address\n\t * @param value Amount to be transferred\n\t * @param validAfter The time after which this is valid (unix time)\n\t * @param validBefore The time before which this is valid (unix time)\n\t * @param nonce Unique nonce\n\t * @param v v of the signature\n\t * @param r r of the signature\n\t * @param s s of the signature\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(to == msg.sender, \"KING::receiveWithAuth: caller must be the payee\");\n\t\trequire(block.timestamp > validAfter, \"KING::receiveWithAuth: auth not yet valid\");\n\t\trequire(block.timestamp < validBefore, \"KING::receiveWithAuth: auth expired\");\n\t\trequire(!authorizationState[from][nonce], \"KING::receiveWithAuth: auth already used\");\n\n\t\tbytes32 encodeData =\n\t\t\tkeccak256(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n\t\t_validateSignedData(from, encodeData, v, r, s);\n\n\t\tauthorizationState[from][nonce] = true;\n\t\temit AuthorizationUsed(from, nonce);\n\n\t\t_transferTokens(from, to, value);\n\t}\n\n\t/**\n\t * @notice EIP-712 Domain separator\n\t * @return Separator\n\t */\n\tfunction getDomainSeparator() public view returns (bytes32) {\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), VERSION_HASH, _getChainId(), address(this)));\n\t}\n\n\t/**\n\t * @notice Recovers address from signed data and validates the signature\n\t * @param signer Address that signed the data\n\t * @param encodeData Data signed by the address\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction _validateSignedData(\n\t\taddress signer,\n\t\tbytes32 encodeData,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal view {\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData));\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n\n\t\t// Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == signer, \"KING::validateSig: invalid signature\");\n\t}\n\n\t/**\n\t * @notice Approval implementation\n\t * @param owner The address of the account which owns tokens\n\t * @param spender The address of the account which may transfer tokens\n\t * @param amount The number of tokens that are approved (2^256-1 means infinite)\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(owner != address(0), \"KING::_approve: approve from the zero address\");\n\t\trequire(spender != address(0), \"KING::_approve: approve to the zero address\");\n\t\tallowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction _increaseAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 addedValue\n\t) internal {\n\t\t_approve(owner, spender, allowances[owner][spender] + addedValue);\n\t}\n\n\tfunction _decreaseAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 subtractedValue\n\t) internal {\n\t\t_approve(\n\t\t\towner,\n\t\t\tspender,\n\t\t\tallowances[owner][spender].sub(subtractedValue, \"KING::_decreaseAllowance: decreased allowance below zero\")\n\t\t);\n\t}\n\n\t/**\n\t * @notice Transfer implementation\n\t * @param from The address of the account which owns tokens\n\t * @param to The address of the account which is receiving tokens\n\t * @param value The number of tokens that are being transferred\n\t */\n\tfunction _transferTokens(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\trequire(to != address(0), \"KING::_transferTokens: cannot transfer to the zero address\");\n\n\t\tbalances[from] = balances[from].sub(value, \"KING::_transferTokens: transfer exceeds from balance\");\n\t\tbalances[to] = balances[to] + value;\n\t\temit Transfer(from, to, value);\n\t}\n\n\t/**\n\t * @notice Mint implementation\n\t * @param to The address of the account which is receiving tokens\n\t * @param value The number of tokens that are being minted\n\t */\n\tfunction _mint(address to, uint256 value) internal {\n\t\ttotalSupply = totalSupply + value;\n\t\tbalances[to] = balances[to] + value;\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\t/**\n\t * @notice Burn implementation\n\t * @param from The address of the account which owns tokens\n\t * @param value The number of tokens that are being burned\n\t */\n\tfunction _burn(address from, uint256 value) internal {\n\t\tbalances[from] = balances[from].sub(value, \"KING::_burn: burn amount exceeds from balance\");\n\t\ttotalSupply = totalSupply.sub(value, \"KING::_burn: burn amount exceeds total supply\");\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\t/**\n\t * @notice Current id of the chain where this contract is deployed\n\t * @return Chain id\n\t */\n\tfunction _getChainId() internal view returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tuint256 c = a + b;\n\t\t\tif (c < a) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b > a) return (false, 0);\n\t\t\treturn (true, a - b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t\t// benefit is lost if 'b' is also tested.\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\t\tif (a == 0) return (true, 0);\n\t\t\tuint256 c = a * b;\n\t\t\tif (c / a != b) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a / b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a % b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a * b;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a / b;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a % b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {trySub}.\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b <= a, errorMessage);\n\t\t\treturn a - b;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a / b;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting with custom message when dividing by zero.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a % b;\n\t\t}\n\t}\n}\n"
    },
    "contracts/Crown.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./libraries/diamond/LibDiamond.sol\";\nimport \"./interfaces/diamond/IDiamondLoupe.sol\";\nimport \"./interfaces/diamond/IDiamondCut.sol\";\nimport \"./interfaces/access/IERC173.sol\";\nimport \"./interfaces/introspection/IERC165.sol\";\n\ncontract Crown {\n\t// more arguments are added to this struct\n\t// this avoids stack too deep errors\n\tstruct CrownArgs {\n\t\taddress king;\n\t}\n\n\tconstructor(IDiamondCut.FacetCut[] memory _diamondCut, CrownArgs memory _args) payable {\n\t\tLibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\n\t\tLibDiamond.setContractOwner(_args.king);\n\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\n\t\t// adding ERC165 data\n\t\tds.supportedInterfaces[type(IERC165).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\t}\n\n\t// Find facet for function that is called and execute the\n\t// function if a facet is found and return any value.\n\tfallback() external payable {\n\t\tLibDiamond.DiamondStorage storage ds;\n\t\tbytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\n\t\taddress facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\t\trequire(facet != address(0), \"Diamond: Function does not exist\");\n\n\t\tassembly {\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(0, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(0, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n\n\treceive() external payable {}\n}\n"
    },
    "contracts/libraries/diamond/LibDiamond.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* Contributors: [ lepidotteri, ]\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../../interfaces/diamond/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tstruct FacetAddressAndPosition {\n\t\taddress facetAddress;\n\t\tuint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n\t}\n\n\tstruct FacetFunctionSelectors {\n\t\tbytes4[] functionSelectors;\n\t\tuint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n\t}\n\n\tstruct DiamondStorage {\n\t\t// maps function selector to the facet address and\n\t\t// the position of the selector in the facetFunctionSelectors.selectors array\n\t\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n\t\t// maps facet addresses to function selectors\n\t\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n\t\t// facet addresses\n\t\taddress[] facetAddresses;\n\t\t// Used to query if a contract implements an interface.\n\t\t// Used to implement ERC-165.\n\t\tmapping(bytes4 => bool) supportedInterfaces;\n\t\t// owner of the contract\n\t\taddress contractOwner;\n\t}\n\n\tfunction diamondStorage() internal pure returns (DiamondStorage storage ds) {\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\t}\n\n\tfunction setContractOwner(address _newOwner) internal {\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\taddress previousOwner = ds.contractOwner;\n\t\tds.contractOwner = _newOwner;\n\t\temit OwnershipTransferred(previousOwner, _newOwner);\n\t}\n\n\tfunction contractOwner() internal view returns (address contractOwner_) {\n\t\tcontractOwner_ = diamondStorage().contractOwner;\n\t}\n\n\tfunction enforceIsContractOwner() internal view {\n\t\trequire(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n\t}\n\n\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n\t// Internal function version of diamondCut\n\tfunction diamondCut(\n\t\tIDiamondCut.FacetCut[] memory _diamondCut,\n\t\taddress _init,\n\t\tbytes memory _calldata\n\t) internal {\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n\t\t\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n\t\t\tif (action == IDiamondCut.FacetCutAction.Add) {\n\t\t\t\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\n\t\t\t\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\n\t\t\t\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else {\n\t\t\t\trevert(\"LibDiamondCut: Incorrect FacetCutAction\");\n\t\t\t}\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tinitializeDiamondCut(_init, _calldata);\n\t}\n\n\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\t// uint16 selectorCount = uint16(diamondStorage().selectors.length);\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\tenforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n\t\t\tds.facetAddresses.push(_facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n\t\t\tds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n\t\t\tds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\tenforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n\t\t\tds.facetAddresses.push(_facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n\t\t\tremoveFunction(oldFacetAddress, selector);\n\t\t\t// add function\n\t\t\tds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n\t\t\tds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\t// if function does not exist then do nothing and return\n\t\trequire(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\tremoveFunction(oldFacetAddress, selector);\n\t\t}\n\t}\n\n\tfunction removeFunction(address _facetAddress, bytes4 _selector) internal {\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\t\t// an immutable function is a function defined directly in a diamond\n\t\trequire(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n\t\t// replace selector with last selector, then delete last selector\n\t\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n\t\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\t\t// if not the same then replace _selector with lastSelector\n\t\tif (selectorPosition != lastSelectorPosition) {\n\t\t\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n\t\t\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\n\t\t}\n\t\t// delete the last selector\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n\t\tdelete ds.selectorToFacetAndPosition[_selector];\n\n\t\t// if no more selectors for facet address then delete the facet address\n\t\tif (lastSelectorPosition == 0) {\n\t\t\t// replace facet address with last facet address and delete last facet address\n\t\t\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n\t\t\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t\tif (facetAddressPosition != lastFacetAddressPosition) {\n\t\t\t\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n\t\t\t\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n\t\t\t\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\n\t\t\t}\n\t\t\tds.facetAddresses.pop();\n\t\t\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t}\n\t}\n\n\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\n\t\tif (_init == address(0)) {\n\t\t\trequire(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n\t\t} else {\n\t\t\trequire(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n\t\t\tif (_init != address(this)) {\n\t\t\t\tenforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n\t\t\t}\n\t\t\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\n\t\t\tif (!success) {\n\t\t\t\tif (error.length > 0) {\n\t\t\t\t\t// bubble up the error\n\t\t\t\t\trevert(string(error));\n\t\t\t\t} else {\n\t\t\t\t\trevert(\"LibDiamondCut: _init function reverted\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n\t\tuint256 contractSize;\n\t\tassembly {\n\t\t\tcontractSize := extcodesize(_contract)\n\t\t}\n\t\trequire(contractSize > 0, _errorMessage);\n\t}\n}\n"
    },
    "contracts/interfaces/diamond/IDiamondLoupe.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n/**\n * A loupe is a small magnifying glass used to look at diamonds.\n */\ninterface IDiamondLoupe {\n\t/// These functions are expected to be called frequently by off-chain code.\n\t/// (and almost never by on-chain code)\n\tstruct Facet {\n\t\taddress facetAddress;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Gets all facet addresses and their four byte function selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view returns (Facet[] memory facets_);\n\n\t/// @notice Gets all the function selectors supported by a specific facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view returns (address[] memory facetAddresses_);\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/diamond/IDiamondCut.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n/**\n * A cut is a powerful cutter used to alter diamonds.\n */\ninterface IDiamondCut {\n\tenum FacetCutAction { Add, Replace, Remove }\n\t// Add=0, Replace=1, Remove=2\n\n\tstruct FacetCut {\n\t\taddress facetAddress;\n\t\tFacetCutAction action;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(\n\t\tFacetCut[] calldata _diamondCut,\n\t\taddress _init,\n\t\tbytes calldata _calldata\n\t) external;\n\n\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n\t/// @dev This emits when ownership of a contract changes.\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/// @notice Get the address of the owner\n\t/// @return owner_ The address of the owner.\n\tfunction owner() external view returns (address owner_);\n\n\t/// @notice Set the address of the new owner of the contract\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\n\t/// @param _newOwner The address of the new owner of the contract\n\tfunction transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* Contributors: [ lepidotteri, ]\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../libraries/diamond/LibDiamond.sol\";\nimport \"../interfaces/diamond/IDiamondCut.sol\";\nimport \"../interfaces/diamond/IDiamondLoupe.sol\";\nimport \"../interfaces/introspection/IERC165.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n\t/// @notice Gets all facets and their selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view override returns (Facet[] memory facets_) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tuint256 numFacets = ds.facetAddresses.length;\n\t\tfacets_ = new Facet[](numFacets);\n\t\tfor (uint256 i; i < numFacets; i++) {\n\t\t\taddress facetAddress_ = ds.facetAddresses[i];\n\t\t\tfacets_[i].facetAddress = facetAddress_;\n\t\t\tfacets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n\t\t}\n\t}\n\n\t/// @notice Gets all the function selectors provided by a facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (bytes4[] memory facetFunctionSelectors_)\n\t{\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tfacetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n\t}\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view override returns (address[] memory facetAddresses_) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tfacetAddresses_ = ds.facetAddresses;\n\t}\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tfacetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n\t}\n\n\t// This implements ERC-165.\n\tfunction supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\treturn ds.supportedInterfaces[_interfaceId];\n\t}\n}\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* Contributors: [ lepidotteri, ]\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../libraries/diamond/LibDiamond.sol\";\nimport \"../interfaces/diamond/IDiamondCut.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n\t/// @notice Add/replace/remove any number of functions and optionally execute a function, with DELEGATECALL\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _callData A contract call with function selector and arguments is executed, with DELEGATECALL, at _init\n\tfunction diamondCut(\n\t\tFacetCut[] calldata _diamondCut,\n\t\taddress _init,\n\t\tbytes calldata _callData\n\t) external override {\n\t\tLibDiamond.enforceIsContractOwner();\n\t\tLibDiamond.diamondCut(_diamondCut, _init, _callData);\n\t}\n}\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport \"../libraries/diamond/LibDiamond.sol\";\nimport \"../interfaces/access/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n\tfunction transferOwnership(address _newOwner) external override {\n\t\tLibDiamond.enforceIsContractOwner();\n\t\tLibDiamond.setContractOwner(_newOwner);\n\t}\n\n\tfunction owner() external view override returns (address king_) {\n\t\tking_ = LibDiamond.contractOwner();\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
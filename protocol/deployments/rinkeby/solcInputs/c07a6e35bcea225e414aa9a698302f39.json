{
  "language": "Solidity",
  "sources": {
    "contracts/common/invoke/IInvocationHook.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface IInvocationHook {\n\tfunction currentSender() external view returns (address);\n\n\tfunction currentTokenAddress() external view returns (address);\n\n\tfunction currentTokenAmount() external view returns (uint256);\n\n\tfunction currentRepaymentAmount() external view returns (uint256);\n}\n"
    },
    "contracts/tokens/ktoken/KToken.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../CollateralizedToken.sol\";\nimport \"../../libraries/access/Ownable.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../libraries/utils/Pausable.sol\";\nimport \"../../common/invoke/IInvocationHook.sol\";\nimport \"../../common/invoke/IInvokable.sol\";\n\nabstract contract KToken is IInvocationHook, CollateralizedToken, Ownable, Pausable {\n\tusing SafeMath for uint256;\n\n\tevent Invocation(address invokeTo, uint256 invokeValue, bytes32 invokeDataHash, uint256 underlyingAmount);\n\tevent Reward(uint256 poolReward, uint256 platformReward, address tokenAddress);\n\n\t/* Reward (in bips) distributed to pool per transaction */\n\tuint256 internal _poolRewardBips;\n\n\t/* Reward (in bips) distributed to platform per transaction */\n\tuint256 internal _platformRewardBips;\n\n\t/* Address that collects the platform reward disbursements */\n\taddress internal _platformVaultAddress;\n\n\t/* Helper - store called token amount for retrieval */\n\taddress internal _currentSender;\n\n\t/* Helper - store called token amount for retrieval */\n\tuint256 internal _currentTokenAmount;\n\n\t/* Helper - store expected balance for currently executing transaction */\n\tuint256 internal _currentExpectedBalance;\n\n\tconstructor() {}\n\n\tfunction invoke(\n\t\taddress invokeTo,\n\t\tbytes calldata invokeData,\n\t\tuint256 underlyingAmount\n\t) external payable nonReentrant whenNotPaused {\n\t\trequire(invokeTo != address(this), \"KToken: cannot invoke this contract\");\n\n\t\t/* Record starting and expected ending balance */\n\t\tuint256 startingBalance = totalReserve().sub(payableReserveAdjustment());\n\t\tsetInvocationState(msg.sender, underlyingAmount, calculateExpectedBalance(startingBalance, underlyingAmount));\n\n\t\t/* Transfer invocation amount of underlying token to caller's invocation address */\n\t\trequire(transferUnderlying(invokeTo, underlyingAmount), \"KToken: unable to transfer invocation amount\");\n\n\t\t/* Invoke caller's function */\n\t\tIInvokable(invokeTo).execute{ value: msg.value }(invokeData);\n\t\temit Invocation(invokeTo, msg.value, keccak256(invokeData), underlyingAmount);\n\n\t\t/* Verify tokens were returned with correct reward */\n\t\trequire(totalReserve() == _currentExpectedBalance, \"KToken: incorrect ending balance\");\n\n\t\t/* Extract platform reward */\n\t\tuint256 platformReward = calculatePlatformReward(underlyingAmount);\n\n\t\trequire(transferUnderlying(_platformVaultAddress, platformReward), \"KToken: unable to transfer platform reward\");\n\t\temit Reward(calculatePoolReward(underlyingAmount), platformReward, underlying());\n\n\t\t/* Reset data for gas refund */\n\t\tsetInvocationState(address(0), 0, 0);\n\t}\n\n\tfunction payableReserveAdjustment() internal virtual returns (uint256) {\n\t\treturn 0;\n\t}\n\n\tfunction setInvocationState(\n\t\taddress currentSender,\n\t\tuint256 currentTokenAmount,\n\t\tuint256 currentExpectedBalance\n\t) internal {\n\t\t_currentSender = currentSender;\n\t\t_currentTokenAmount = currentTokenAmount;\n\t\t_currentExpectedBalance = currentExpectedBalance;\n\t}\n\n\tfunction calculatePoolReward(uint256 tokenAmount) internal view returns (uint256) {\n\t\treturn tokenAmount.mul(_poolRewardBips).div(10000);\n\t}\n\n\tfunction calculatePlatformReward(uint256 tokenAmount) internal view returns (uint256) {\n\t\treturn tokenAmount.mul(_platformRewardBips).div(10000);\n\t}\n\n\tfunction calculateExpectedBalance(uint256 startingBalance, uint256 tokenAmount) internal view returns (uint256) {\n\t\treturn startingBalance.add(calculatePoolReward(tokenAmount)).add(calculatePlatformReward(tokenAmount));\n\t}\n\n\tfunction calculateRepaymentAmount(uint256 tokenAmount) external view returns (uint256) {\n\t\treturn tokenAmount.add(calculatePoolReward(tokenAmount)).add(calculatePlatformReward(tokenAmount));\n\t}\n\n\tfunction poolReward() external view returns (uint256) {\n\t\treturn _poolRewardBips;\n\t}\n\n\tfunction platformReward() external view returns (uint256) {\n\t\treturn _platformRewardBips;\n\t}\n\n\tfunction platformVaultAddress() external view returns (address) {\n\t\treturn _platformVaultAddress;\n\t}\n\n\tfunction isKToken() external pure returns (bool) {\n\t\treturn true;\n\t}\n\n\t/* Helper hook for invoked transaction */\n\tfunction currentSender() external view override returns (address) {\n\t\treturn _currentSender;\n\t}\n\n\tfunction currentTokenAddress() external view override returns (address) {\n\t\treturn _underlying;\n\t}\n\n\tfunction currentTokenAmount() external view override returns (uint256) {\n\t\treturn _currentTokenAmount;\n\t}\n\n\tfunction currentRepaymentAmount() external view override returns (uint256) {\n\t\treturn _currentExpectedBalance.sub(totalReserve());\n\t}\n\n\t/* ADMIN FUNCTIONS */\n\n\tfunction setPoolReward(uint256 poolRewardBips) external onlyOwner {\n\t\t_poolRewardBips = poolRewardBips;\n\t}\n\n\tfunction setPlatformReward(uint256 platformRewardBips) external onlyOwner {\n\t\t_platformRewardBips = platformRewardBips;\n\t}\n\n\tfunction setPlatformVaultAddress(address vaultAddress) external onlyOwner {\n\t\t_platformVaultAddress = vaultAddress;\n\t}\n\n\tfunction pause() external onlyOwner whenNotPaused {\n\t\t_pause();\n\t}\n\n\tfunction unpause() external onlyOwner whenPaused {\n\t\t_unpause();\n\t}\n}\n"
    },
    "contracts/tokens/CollateralizedToken.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./UnlimitedApprovalERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../libraries/utils/ReentrancyGuard.sol\";\nimport \"../common/utils/ExtendedMath.sol\";\n\nabstract contract CollateralizedToken is ExtendedMath, ReentrancyGuard, UnlimitedApprovalERC20 {\n\tusing SafeMath for uint256;\n\n\tevent Mint(address minter, uint256 tokenAmount, uint256 kTokenAmount);\n\tevent Redeem(address redeemer, uint256 tokenAmount, uint256 kTokenAmount);\n\n\taddress internal _underlying;\n\n\tconstructor(address underlying) {\n\t\t_underlying = underlying;\n\t}\n\n\t/*\n\t * BALANCE UPDATE\n\t */\n\n\tfunction redeem(uint256 kTokenAmount) external returns (bool) {\n\t\trequire(totalSupply() > 0, \"CollateralizedToken: no supply\");\n\t\treturn redeemInternal(nativeAmountToUnderlyingAmount(kTokenAmount), kTokenAmount);\n\t}\n\n\tfunction redeemUnderlying(uint256 tokenAmount) external returns (bool) {\n\t\trequire(totalReserve() > 0, \"CollateralizedToken: no reserve\");\n\t\treturn redeemInternal(tokenAmount, underlyingAmountToNativeAmountInternal(tokenAmount, true, false));\n\t}\n\n\tfunction mintInternal(uint256 amount) internal nonReentrant returns (bool) {\n\t\tuint256 kTokenAmount;\n\t\tif (totalReserve().sub(amount) > 0) {\n\t\t\tkTokenAmount = underlyingAmountToNativeAmountInternal(amount, false, true);\n\t\t} else {\n\t\t\tkTokenAmount = amount;\n\t\t}\n\t\t_mint(msg.sender, kTokenAmount);\n\t\temit Mint(msg.sender, amount, kTokenAmount);\n\n\t\treturn true;\n\t}\n\n\tfunction redeemInternal(uint256 tokenAmount, uint256 kTokenAmount) internal nonReentrant returns (bool) {\n\t\t_burn(msg.sender, kTokenAmount);\n\t\trequire(transferUnderlying(msg.sender, tokenAmount), \"CollateralizedToken: token transfer failed\");\n\t\temit Redeem(msg.sender, tokenAmount, kTokenAmount);\n\n\t\treturn true;\n\t}\n\n\tfunction transferUnderlying(address to, uint256 amount) internal virtual returns (bool);\n\n\t/*\n\t * VIEWS\n\t */\n\n\tfunction nativeAmountToUnderlyingAmount(uint256 nativeAmount) public view returns (uint256) {\n\t\tif (totalSupply() == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn nativeAmount.mul(totalReserve()).div(totalSupply());\n\t}\n\n\tfunction underlyingAmountToNativeAmount(uint256 underlyingAmount, bool ceil) public view returns (uint256) {\n\t\treturn underlyingAmountToNativeAmountInternal(underlyingAmount, ceil, false);\n\t}\n\n\tfunction underlyingAmountToNativeAmountInternal(\n\t\tuint256 underlyingAmount,\n\t\tbool ceil,\n\t\tbool subtractDeposit\n\t) internal view returns (uint256) {\n\t\tif (totalReserve() == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* mint() pulls in funds before calling mintInternal() - normalize for pre-funding amount */\n\t\tuint256 adjustedTotalReserve = subtractDeposit ? totalReserve().sub(underlyingAmount) : totalReserve();\n\n\t\t/* round mint() down and redeemUnderlying() up to avoid over-ownership exploits */\n\t\treturn divAndRound(underlyingAmount.mul(totalSupply()), adjustedTotalReserve, ceil);\n\t}\n\n\tfunction isUnderlyingEther() public view virtual returns (bool);\n\n\tfunction totalReserve() public view virtual returns (uint256);\n\n\tfunction balanceOfUnderlying(address owner) public view returns (uint256) {\n\t\treturn nativeAmountToUnderlyingAmount(balanceOf(owner));\n\t}\n\n\tfunction underlying() public view returns (address) {\n\t\treturn _underlying;\n\t}\n}\n"
    },
    "contracts/libraries/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tuint256 c = a + b;\n\t\t\tif (c < a) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b > a) return (false, 0);\n\t\t\treturn (true, a - b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t\t// benefit is lost if 'b' is also tested.\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\t\tif (a == 0) return (true, 0);\n\t\t\tuint256 c = a * b;\n\t\t\tif (c / a != b) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a / b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a % b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a * b;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a / b;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a % b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {trySub}.\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b <= a, errorMessage);\n\t\t\treturn a - b;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a / b;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting with custom message when dividing by zero.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a % b;\n\t\t}\n\t}\n}\n"
    },
    "contracts/libraries/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n\t/**\n\t * @dev Emitted when the pause is triggered by `account`.\n\t */\n\tevent Paused(address account);\n\n\t/**\n\t * @dev Emitted when the pause is lifted by `account`.\n\t */\n\tevent Unpaused(address account);\n\n\tbool private _paused;\n\n\t/**\n\t * @dev Initializes the contract in unpaused state.\n\t */\n\tconstructor() {\n\t\t_paused = false;\n\t}\n\n\t/**\n\t * @dev Returns true if the contract is paused, and false otherwise.\n\t */\n\tfunction paused() public view virtual returns (bool) {\n\t\treturn _paused;\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only when the contract is not paused.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must not be paused.\n\t */\n\tmodifier whenNotPaused() {\n\t\trequire(!paused(), \"Pausable: paused\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only when the contract is paused.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must be paused.\n\t */\n\tmodifier whenPaused() {\n\t\trequire(paused(), \"Pausable: not paused\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Triggers stopped state.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must not be paused.\n\t */\n\tfunction _pause() internal virtual whenNotPaused {\n\t\t_paused = true;\n\t\temit Paused(_msgSender());\n\t}\n\n\t/**\n\t * @dev Returns to normal state.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must be paused.\n\t */\n\tfunction _unpause() internal virtual whenPaused {\n\t\t_paused = false;\n\t\temit Unpaused(_msgSender());\n\t}\n}\n"
    },
    "contracts/common/invoke/IInvokable.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface IInvokable {\n\tfunction execute(bytes calldata data) external payable;\n}\n"
    },
    "contracts/tokens/UnlimitedApprovalERC20.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../libraries/token/ERC20/ERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nabstract contract UnlimitedApprovalERC20 is ERC20 {\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t// Check for and update remaining allowance\n\t\tif (allowance(sender, _msgSender()) != type(uint256).max) {\n\t\t\t_approve(\n\t\t\t\tsender,\n\t\t\t\t_msgSender(),\n\t\t\t\tSafeMath.sub(\n\t\t\t\t\tallowance(sender, _msgSender()),\n\t\t\t\t\tamount,\n\t\t\t\t\t\"UnlimitedApprovalERC20: transfer amount exceeds allowance\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/libraries/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n\t// Booleans are more expensive than uint256 or any type that takes up a full\n\t// word because each write operation emits an extra SLOAD to first read the\n\t// slot's contents, replace the bits taken up by the boolean, and then write\n\t// back. This is the compiler's defense against contract upgrades and\n\t// pointer aliasing, and it cannot be disabled.\n\n\t// The values being non-zero value makes deployment a bit more expensive,\n\t// but in exchange the refund on every call to nonReentrant will be lower in\n\t// amount. Since refunds are capped to a percentage of the total\n\t// transaction's gas, it is best to keep them low in cases like this one, to\n\t// increase the likelihood of the full refund coming into effect.\n\tuint256 private constant _NOT_ENTERED = 1;\n\tuint256 private constant _ENTERED = 2;\n\n\tuint256 private _status;\n\n\tconstructor() {\n\t\t_status = _NOT_ENTERED;\n\t}\n\n\t/**\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\n\t * Calling a `nonReentrant` function from another `nonReentrant`\n\t * function is not supported. It is possible to prevent this from happening\n\t * by making the `nonReentrant` function external, and make it call a\n\t * `private` function that does the actual work.\n\t */\n\tmodifier nonReentrant() {\n\t\t// On the first call to nonReentrant, _notEntered will be true\n\t\trequire(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n\t\t// Any calls to nonReentrant after this point will fail\n\t\t_status = _ENTERED;\n\n\t\t_;\n\n\t\t// By storing the original value once again, a refund is triggered (see\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\n\t\t_status = _NOT_ENTERED;\n\t}\n}\n"
    },
    "contracts/common/utils/ExtendedMath.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../../libraries/math/SafeMath.sol\";\n\ncontract ExtendedMath {\n\tusing SafeMath for uint256;\n\n\t// divide a/b then optionally floor or ceiling\n\tfunction divAndRound(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tbool ceiling\n\t) internal pure returns (uint256) {\n\t\tuint256 floor = a.div(b);\n\t\treturn (ceiling && a.mod(b) != 0) ? floor.add(1) : floor;\n\t}\n}\n"
    },
    "contracts/libraries/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"../../../interfaces/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n\tmapping(address => uint256) private _balances;\n\n\tmapping(address => mapping(address => uint256)) private _allowances;\n\n\tuint256 private _totalSupply;\n\n\tstring private _name;\n\tstring private _symbol;\n\n\t/**\n\t * @dev Sets the values for {name} and {symbol}.\n\t *\n\t * The defaut value of {decimals} is 18. To select a different value for\n\t * {decimals} you should overload it.\n\t *\n\t * All three of these values are immutable: they can only be set once during\n\t * construction.\n\t */\n\tconstructor(string memory name_, string memory symbol_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t}\n\n\t/**\n\t * @dev Returns the name of the token.\n\t */\n\tfunction name() public view virtual returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev Returns the symbol of the token, usually a shorter version of the\n\t * name.\n\t */\n\tfunction symbol() public view virtual returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * Tokens usually opt for a value of 18, imitating the relationship between\n\t * Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t * overloaded;\n\t *\n\t * NOTE: This information is only used for _display_ purposes: it in\n\t * no way affects any of the arithmetic of the contract, including\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\n\t */\n\tfunction decimals() public view virtual returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {IERC20-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {IERC20-balanceOf}.\n\t */\n\tfunction balanceOf(address account) public view virtual override returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Requirements:\n\t *\n\t * - `recipient` cannot be the zero address.\n\t * - the caller must have a balance of at least `amount`.\n\t */\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-allowance}.\n\t */\n\tfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev See {IERC20-approve}.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP. See the note at the beginning of {ERC20}.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` and `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - the caller must have allowance for ``sender``'s tokens of at least\n\t * `amount`.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\n\t\tuint256 currentAllowance = _allowances[sender][_msgSender()];\n\t\trequire(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n\t\t_approve(sender, _msgSender(), currentAllowance - amount);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically increases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t * - `spender` must have allowance for the caller of at least\n\t * `subtractedValue`.\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\t\tuint256 currentAllowance = _allowances[_msgSender()][spender];\n\t\trequire(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n\t\t_approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves tokens `amount` from `sender` to `recipient`.\n\t *\n\t * This is internal function is equivalent to {transfer}, and can be used to\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\tuint256 senderBalance = _balances[sender];\n\t\trequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\t\t_balances[sender] = senderBalance - amount;\n\t\t_balances[recipient] += amount;\n\n\t\temit Transfer(sender, recipient, amount);\n\t}\n\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t */\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\n\t\t_totalSupply += amount;\n\t\t_balances[account] += amount;\n\t\temit Transfer(address(0), account, amount);\n\t}\n\n\t/**\n\t * @dev Destroys `amount` tokens from `account`, reducing the\n\t * total supply.\n\t *\n\t * Emits a {Transfer} event with `to` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t * - `account` must have at least `amount` tokens.\n\t */\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\tuint256 accountBalance = _balances[account];\n\t\trequire(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n\t\t_balances[account] = accountBalance - amount;\n\t\t_totalSupply -= amount;\n\n\t\temit Transfer(account, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n\t *\n\t * This internal function is equivalent to `approve`, and can be used to\n\t * e.g. set automatic allowances for certain subsystems, etc.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev Hook that is called before any transfer of tokens. This includes\n\t * minting and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\t * will be to transferred to `to`.\n\t * - when `from` is zero, `amount` tokens will be minted for `to`.\n\t * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual {}\n}\n"
    },
    "contracts/libraries/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n"
    },
    "contracts/interfaces/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/tokens/ktoken/KEther.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./KToken.sol\";\nimport \"../CollateralizedEther.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\n\ncontract KEther is KToken, CollateralizedEther {\n\tconstructor() CollateralizedEther() ERC20(\"Kingmaker/Ether\", \"kETH\") {}\n\n\tfunction payableReserveAdjustment() internal override returns (uint256) {\n\t\treturn msg.value;\n\t}\n\n\t// TODO: define role that receive/fallback default functions can play within the protocol inner workings\n\treceive() external payable {}\n}\n"
    },
    "contracts/tokens/CollateralizedEther.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./CollateralizedToken.sol\";\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../common/utils/ExternalCaller.sol\";\n\nabstract contract CollateralizedEther is CollateralizedToken, ExternalCaller {\n\tusing SafeMath for uint256;\n\n\tconstructor() CollateralizedToken(address(1)) {}\n\n\tfunction mint() external payable returns (bool) {\n\t\treturn mintInternal(msg.value);\n\t}\n\n\tfunction transferUnderlying(address to, uint256 amount) internal override returns (bool) {\n\t\trequire(address(this).balance >= amount, \"CollateralizedEther: not enough ETH balance\");\n\t\texternalTransfer(to, amount);\n\t\treturn true;\n\t}\n\n\tfunction isUnderlyingEther() public pure override returns (bool) {\n\t\treturn true;\n\t}\n\n\tfunction totalReserve() public view override returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n}\n"
    },
    "contracts/common/utils/ExternalCaller.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ncontract ExternalCaller {\n\tfunction externalTransfer(address _to, uint256 _value) internal {\n\t\trequire(address(this).balance >= _value, \"ExternalCaller: insufficient ether balance\");\n\t\texternalCall(_to, _value, \"\");\n\t}\n\n\tfunction externalCall(\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tbytes memory _data\n\t) internal {\n\t\t(bool success, bytes memory returndata) = _to.call{ value: _value }(_data);\n\t\trequire(success, string(returndata));\n\t}\n}\n"
    },
    "contracts/common/utils/BalanceCarrier.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./ExternalCaller.sol\";\nimport \"../../interfaces/token/ERC20/IERC20.sol\";\n\nabstract contract BalanceCarrier is ExternalCaller {\n\taddress private _ethTokenAddress;\n\n\tconstructor(address ethTokenAddress) {\n\t\t_ethTokenAddress = ethTokenAddress;\n\t}\n\n\tfunction transfer(\n\t\taddress tokenAddress,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal returns (bool) {\n\t\tif (tokenAddress == _ethTokenAddress) {\n\t\t\texternalTransfer(to, amount);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn IERC20(tokenAddress).transfer(to, amount);\n\t\t}\n\t}\n\n\tfunction balanceOf(address tokenAddress) internal view returns (uint256) {\n\t\tif (tokenAddress == _ethTokenAddress) {\n\t\t\treturn address(this).balance;\n\t\t} else {\n\t\t\treturn IERC20(tokenAddress).balanceOf(address(this));\n\t\t}\n\t}\n}\n"
    },
    "contracts/liquidity/kingmaker/KingmakerLiquidityProxy.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../ILiquidityProxy.sol\";\nimport \"../../libraries/utils/Pausable.sol\";\nimport \"../../libraries/access/Ownable.sol\";\nimport \"../../common/invoke/IInvoker.sol\";\nimport \"../../common/utils/BalanceCarrier.sol\";\nimport \"../../tokens/CollateralizedToken.sol\";\nimport \"../../tokens/ktoken/KToken.sol\";\n\ncontract KingmakerLiquidityProxy is BalanceCarrier, IInvokable, ILiquidityProxy, Ownable {\n\tmapping(address => address) _tokenAddressToKTokenAddress;\n\n\taddress payable internal _scheduleInvokerAddress;\n\taddress internal _scheduleTokenAddress;\n\tuint256 internal _scheduleTokenAmount;\n\n\tconstructor() BalanceCarrier(address(1)) {}\n\n\tfunction registerPool(address tokenAddress, address kTokenAddress) external onlyOwner {\n\t\t_tokenAddressToKTokenAddress[tokenAddress] = kTokenAddress;\n\t}\n\n\tfunction deregisterPool(address tokenAddress) external onlyOwner {\n\t\t_tokenAddressToKTokenAddress[tokenAddress] = address(0);\n\t}\n\n\tfunction getRepaymentAddress(address tokenAddress) external view override returns (address) {\n\t\treturn poolAddress(tokenAddress);\n\t}\n\n\tfunction getTotalReserve(address tokenAddress) external view override returns (uint256) {\n\t\tif (isRegistered(tokenAddress) && !isPaused(tokenAddress)) {\n\t\t\tCollateralizedToken pool = CollateralizedToken(poolAddress(tokenAddress));\n\t\t\treturn pool.totalReserve();\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction getRepaymentAmount(address tokenAddress, uint256 tokenAmount) external view override returns (uint256) {\n\t\tKToken pool = KToken(poolAddress(tokenAddress));\n\t\treturn pool.calculateRepaymentAmount(tokenAmount);\n\t}\n\n\tfunction borrow(address tokenAddress, uint256 tokenAmount) external override {\n\t\t_scheduleInvokerAddress = payable(msg.sender);\n\t\t_scheduleTokenAddress = tokenAddress;\n\t\t_scheduleTokenAmount = tokenAmount;\n\n\t\tKToken pool = KToken(poolAddress(tokenAddress));\n\t\tpool.invoke(address(this), \"\", tokenAmount);\n\n\t\t_scheduleInvokerAddress = payable(address(0));\n\t\t_scheduleTokenAddress = address(0);\n\t\t_scheduleTokenAmount = 0;\n\t}\n\n\tfunction execute(bytes calldata data) external payable override {\n\t\trequire(_scheduleInvokerAddress != address(0), \"KingmakerLiquidityProxy: not scheduled\");\n\n\t\trequire(\n\t\t\ttransfer(_scheduleTokenAddress, _scheduleInvokerAddress, _scheduleTokenAmount),\n\t\t\t\"KingmakerLiquidityProxy: transfer to invoker failed\"\n\t\t);\n\n\t\tIInvoker invoker = IInvoker(_scheduleInvokerAddress);\n\t\tinvoker.invokeCallback();\n\t}\n\n\tfunction poolAddress(address tokenAddress) internal view returns (address) {\n\t\treturn _tokenAddressToKTokenAddress[tokenAddress];\n\t}\n\n\tfunction isRegistered(address tokenAddress) internal view returns (bool) {\n\t\treturn poolAddress(tokenAddress) != address(0);\n\t}\n\n\tfunction isPaused(address tokenAddress) internal view returns (bool) {\n\t\treturn Pausable(poolAddress(tokenAddress)).paused();\n\t}\n\n\tfallback() external {}\n}\n"
    },
    "contracts/liquidity/ILiquidityProxy.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface ILiquidityProxy {\n\tfunction getTotalReserve(address tokenAddress) external view returns (uint256);\n\n\tfunction getRepaymentAddress(address tokenAddress) external view returns (address);\n\n\tfunction getRepaymentAmount(address tokenAddress, uint256 tokenAmount) external view returns (uint256);\n\n\tfunction borrow(address tokenAddress, uint256 tokenAmount) external;\n}\n"
    },
    "contracts/common/invoke/IInvoker.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./IInvocationHook.sol\";\n\ninterface IInvoker is IInvocationHook {\n\tfunction invoke(\n\t\taddress invokeTo,\n\t\tbytes calldata invokeData,\n\t\taddress tokenAddress,\n\t\tuint256 tokenAmount\n\t) external payable;\n\n\tfunction invokeCallback() external;\n\n\tfunction poolReward() external view returns (uint256);\n\n\tfunction poolRewardAddress(address tokenAddress) external view returns (address);\n\n\tfunction platformReward() external view returns (uint256);\n\n\tfunction platformVaultAddress() external view returns (address);\n\n\tfunction isTokenAddressRegistered(address tokenAddress) external view returns (bool);\n\n\tfunction totalLiquidity(address tokenAddress) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/CollateralizedERC20.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./CollateralizedToken.sol\";\nimport \"../libraries/math/SafeMath.sol\";\n\nabstract contract CollateralizedERC20 is CollateralizedToken {\n\tusing SafeMath for uint256;\n\n\tfunction mint(uint256 tokenAmount) external returns (bool) {\n\t\tIERC20 token = IERC20(underlying());\n\t\trequire(\n\t\t\ttoken.transferFrom(msg.sender, address(this), tokenAmount),\n\t\t\t\"CollateralizedERC20: token transferFrom failed\"\n\t\t);\n\t\treturn mintInternal(tokenAmount);\n\t}\n\n\tfunction transferUnderlying(address to, uint256 amount) internal override returns (bool) {\n\t\treturn IERC20(underlying()).transfer(to, amount);\n\t}\n\n\tfunction isUnderlyingEther() public pure override returns (bool) {\n\t\treturn false;\n\t}\n\n\tfunction totalReserve() public view override returns (uint256) {\n\t\treturn IERC20(underlying()).balanceOf(address(this));\n\t}\n}\n"
    },
    "contracts/tokens/ktoken/KERC20.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./KToken.sol\";\nimport \"../CollateralizedERC20.sol\";\n\ncontract KERC20 is KToken, CollateralizedERC20 {\n\tconstructor(\n\t\taddress underlying,\n\t\tstring memory name,\n\t\tstring memory symbol\n\t) CollateralizedToken(underlying) ERC20(name, symbol) {}\n\n\t// TODO: define role that receive/fallback default functions can play within the protocol inner workings\n\treceive() external payable {}\n}\n"
    },
    "contracts/testing/TestCollateralizedERC20.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../tokens/CollateralizedERC20.sol\";\nimport \"../tokens/CollateralizedToken.sol\";\n\ncontract TestCollateralizedERC20 is CollateralizedERC20 {\n\tconstructor(\n\t\taddress underlying,\n\t\tstring memory name,\n\t\tstring memory symbol\n\t) ERC20(name, symbol) CollateralizedToken(underlying) {}\n}\n"
    },
    "contracts/testing/TestToken.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../tokens/UnlimitedApprovalERC20.sol\";\n\ncontract TestToken is UnlimitedApprovalERC20 {\n\tconstructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n\t/**\n\t * Allows anyone to arbitrarily mint themselves tokens for testing.\n\t */\n\tfunction mint(uint256 amount) public returns (bool) {\n\t\t_mint(msg.sender, amount);\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../libraries/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20(\"ERC20Mock\", \"MOCK\") {\n\tbool public transferFromCalled = false;\n\n\tbool public transferCalled = false;\n\taddress public transferRecipient = address(0);\n\tuint256 public transferAmount = 0;\n\n\tfunction mint(address user, uint256 amount) public {\n\t\t_mint(user, amount);\n\t}\n\n\tfunction burnFrom(address user, uint256 amount) public {\n\t\t_burn(user, amount);\n\t}\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\ttransferFromCalled = true;\n\n\t\treturn super.transferFrom(sender, recipient, amount);\n\t}\n\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\ttransferCalled = true;\n\t\ttransferRecipient = recipient;\n\t\ttransferAmount = amount;\n\n\t\treturn super.transfer(recipient, amount);\n\t}\n}\n"
    },
    "contracts/testing/MockSoloMargin.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../interfaces/token/ERC20/IERC20.sol\";\nimport \"../libraries/math/SafeMath.sol\";\nimport \"../liquidity/dydx/ISoloMargin.sol\";\nimport \"../liquidity/dydx/ICallee.sol\";\n\ncontract MockSoloMargin is ISoloMargin {\n\tusing SafeMath for uint256;\n\n\tmapping(uint256 => address) internal _markets;\n\tbool internal _isClosed;\n\n\tuint256 internal _scheduledTokenAmount;\n\tuint256 internal _scheduleMarketId;\n\taddress internal _scheduleAccountAddress;\n\tuint256 internal _scheduleAccountNumber;\n\n\tconstructor(uint256[] memory marketIds, address[] memory tokenAddresses) {\n\t\tfor (uint256 i = 0; i < marketIds.length; i++) {\n\t\t\t_markets[marketIds[i]] = tokenAddresses[i];\n\t\t}\n\t\t_isClosed = false;\n\t}\n\n\tfunction operate(Types.AccountInfo[] memory accounts, Types.ActionArgs[] memory actions) public override {\n\t\t/* data */\n\t\trequire(accounts.length == 1, \"MockSoloMargin: incorrect accounts length\");\n\t\trequire(actions.length == 3, \"MockSoloMargin: incorrect actions length\");\n\t\t_scheduleAccountAddress = accounts[0].owner;\n\t\t_scheduleAccountNumber = accounts[0].number;\n\n\t\t/* withdraw */\n\t\tTypes.ActionArgs memory withdraw = actions[0];\n\t\t_scheduledTokenAmount = withdraw.amount.value;\n\t\t_scheduleMarketId = withdraw.primaryMarketId;\n\n\t\trequire(withdraw.amount.sign == false, \"MockSoloMargin: incorrect withdraw sign\");\n\t\trequire(\n\t\t\twithdraw.amount.denomination == Types.AssetDenomination.Wei,\n\t\t\t\"MockSoloMargin: incorrect withdraw denomination\"\n\t\t);\n\t\trequire(withdraw.amount.ref == Types.AssetReference.Delta, \"MockSoloMargin: incorrect withdraw reference\");\n\n\t\trequire(withdraw.actionType == Types.ActionType.Withdraw, \"MockSoloMargin: incorrect withdraw action type\");\n\t\trequire(withdraw.accountId == 0, \"MockSoloMargin: must use first account\");\n\t\trequire(withdraw.otherAddress == msg.sender, \"MockSoloMargin: not sending to proxy\");\n\n\t\t/* call */\n\t\tTypes.ActionArgs memory call = actions[1];\n\t\trequire(call.actionType == Types.ActionType.Call, \"MockSoloMargin: incorrect call action type\");\n\t\trequire(call.accountId == 0, \"MockSoloMargin: must use first account\");\n\t\trequire(call.otherAddress == msg.sender, \"MockSoloMargin: not invoking proxy\");\n\n\t\t/* deposit */\n\t\tTypes.ActionArgs memory deposit = actions[2];\n\t\trequire(_scheduleMarketId == deposit.primaryMarketId, \"MockSoloMargin: marketId mismatch\");\n\n\t\tuint256 depositValue = withdraw.amount.value.add(repaymentFee(withdraw.primaryMarketId));\n\t\trequire(deposit.amount.value == depositValue, \"MockSoloMargin: incorrect deposit value\");\n\t\trequire(deposit.amount.sign == true, \"MockSoloMargin: incorrect deposit sign\");\n\t\trequire(\n\t\t\tdeposit.amount.denomination == Types.AssetDenomination.Wei,\n\t\t\t\"MockSoloMargin: incorrect deposit denomination\"\n\t\t);\n\t\trequire(deposit.amount.ref == Types.AssetReference.Delta, \"MockSoloMargin: incorrect deposit reference\");\n\n\t\trequire(deposit.actionType == Types.ActionType.Deposit, \"MockSoloMargin: incorrect deposit action type\");\n\t\trequire(deposit.accountId == 0, \"MockSoloMargin: must use first account\");\n\t\trequire(deposit.otherAddress == msg.sender, \"MockSoloMargin: not sending to proxy\");\n\n\t\tuint256 balanceBefore = balanceOf(withdraw.primaryMarketId);\n\n\t\ttransfer(withdraw.primaryMarketId, msg.sender, withdraw.amount.value);\n\n\t\tICallee(msg.sender).callFunction(\n\t\t\tmsg.sender,\n\t\t\tTypes.AccountInfo({ owner: _scheduleAccountAddress, number: _scheduleAccountNumber }),\n\t\t\t\"\"\n\t\t);\n\n\t\ttransferFrom(deposit.primaryMarketId, msg.sender, address(this), deposit.amount.value);\n\t\tuint256 balanceAfter = balanceOf(withdraw.primaryMarketId);\n\n\t\trequire(\n\t\t\tbalanceAfter == balanceBefore.add(repaymentFee(withdraw.primaryMarketId)),\n\t\t\t\"MockSoloMargin: Incorrect ending balance\"\n\t\t);\n\n\t\t_scheduledTokenAmount = 0;\n\t\t_scheduleMarketId = 0;\n\t\t_scheduleAccountAddress = address(0);\n\t\t_scheduleAccountNumber = 0;\n\t}\n\n\tfunction getMarketIsClosing(uint256 marketId) public view override returns (bool) {\n\t\treturn _isClosed;\n\t}\n\n\tfunction setClosed(bool closed) external {\n\t\t_isClosed = closed;\n\t}\n\n\tfunction getMarketTokenAddress(uint256 marketId) public view override returns (address) {\n\t\treturn _markets[marketId];\n\t}\n\n\tfunction repaymentFee(uint256 marketId) internal pure returns (uint256) {\n\t\treturn marketId < 2 ? 1 : 2;\n\t}\n\n\tfunction transfer(\n\t\tuint256 marketId,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal returns (bool) {\n\t\treturn IERC20(_markets[marketId]).transfer(to, amount);\n\t}\n\n\tfunction transferFrom(\n\t\tuint256 marketId,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal returns (bool) {\n\t\treturn IERC20(_markets[marketId]).transferFrom(from, to, amount);\n\t}\n\n\tfunction balanceOf(uint256 marketId) internal view returns (uint256) {\n\t\treturn IERC20(_markets[marketId]).balanceOf(address(this));\n\t}\n\n\tfallback() external {}\n}\n"
    },
    "contracts/liquidity/dydx/ISoloMargin.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./Types.sol\";\n\ninterface ISoloMargin {\n\tfunction operate(Types.AccountInfo[] memory accounts, Types.ActionArgs[] memory actions) external;\n\n\tfunction getMarketIsClosing(uint256 marketId) external view returns (bool);\n\n\tfunction getMarketTokenAddress(uint256 marketId) external view returns (address);\n}\n"
    },
    "contracts/liquidity/dydx/ICallee.sol": {
      "content": "/*\n    Copyright 2019 dYdX Trading Inc.\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./Types.sol\";\n\n/**\n * @title ICallee\n * @author dYdX\n *\n * Interface that Callees for Solo must implement in order to ingest data.\n */\ninterface ICallee {\n\t/**\n\t * Allows users to send this contract arbitrary data.\n\t *\n\t * @param  sender       The msg.sender to Solo\n\t * @param  accountInfo  The account from which the data is being sent\n\t * @param  data         Arbitrary data given by the sender\n\t */\n\tfunction callFunction(\n\t\taddress sender,\n\t\tTypes.AccountInfo memory accountInfo,\n\t\tbytes memory data\n\t) external;\n}\n"
    },
    "contracts/liquidity/dydx/Types.sol": {
      "content": "/*\n\n    Copyright 2019 dYdX Trading Inc.\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nlibrary Types {\n\tenum ActionType {\n\t\tDeposit, // supply tokens\n\t\tWithdraw, // borrow tokens\n\t\tTransfer, // transfer balance between accounts\n\t\tBuy, // buy an amount of some token (externally)\n\t\tSell, // sell an amount of some token (externally)\n\t\tTrade, // trade tokens against another account\n\t\tLiquidate, // liquidate an undercollateralized or expiring account\n\t\tVaporize, // use excess tokens to zero-out a completely negative account\n\t\tCall // send arbitrary data to an address\n\t}\n\n\tenum AssetDenomination {\n\t\tWei, // the amount is denominated in wei\n\t\tPar // the amount is denominated in par\n\t}\n\n\tenum AssetReference {\n\t\tDelta, // the amount is given as a delta from the current value\n\t\tTarget // the amount is given as an exact number to end up at\n\t}\n\n\tstruct AssetAmount {\n\t\tbool sign; // true if positive\n\t\tAssetDenomination denomination;\n\t\tAssetReference ref;\n\t\tuint256 value;\n\t}\n\n\tstruct Wei {\n\t\tbool sign; // true if positive\n\t\tuint256 value;\n\t}\n\n\tstruct ActionArgs {\n\t\tActionType actionType;\n\t\tuint256 accountId;\n\t\tAssetAmount amount;\n\t\tuint256 primaryMarketId;\n\t\tuint256 secondaryMarketId;\n\t\taddress otherAddress;\n\t\tuint256 otherAccountId;\n\t\tbytes data;\n\t}\n\n\tstruct AccountInfo {\n\t\taddress owner; // The address that owns the account\n\t\tuint256 number; // A nonce that allows a single address to control many accounts\n\t}\n}\n"
    },
    "contracts/liquidity/dydx/SoloLiquidityProxy.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./ICallee.sol\";\nimport \"./ISoloMargin.sol\";\nimport \"./Types.sol\";\nimport \"../ILiquidityProxy.sol\";\nimport \"../../libraries/access/Ownable.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../interfaces/token/ERC20/IERC20.sol\";\nimport \"../../common/invoke/IInvoker.sol\";\nimport \"../../common/utils/BalanceCarrier.sol\";\nimport \"../../common/utils/WETHHandler.sol\";\n\ncontract SoloLiquidityProxy is BalanceCarrier, ICallee, ILiquidityProxy, Ownable, WETHHandler {\n\tusing SafeMath for uint256;\n\n\tuint256 internal NULL_ACCOUNT_ID = 0;\n\tuint256 internal NULL_MARKET_ID = 0;\n\tTypes.AssetAmount internal NULL_AMOUNT =\n\t\tTypes.AssetAmount({\n\t\t\tsign: false,\n\t\t\tdenomination: Types.AssetDenomination.Wei,\n\t\t\tref: Types.AssetReference.Delta,\n\t\t\tvalue: 0\n\t\t});\n\tbytes internal NULL_DATA = \"\";\n\n\taddress internal _soloMarginAddress;\n\tmapping(address => uint256) internal _tokenAddressToMarketId;\n\tmapping(uint256 => address) internal _marketIdToTokenAddress;\n\tmapping(address => bool) internal _tokenAddressRegistered;\n\n\taddress payable internal _scheduleInvokerAddress;\n\taddress internal _scheduleTokenAddress;\n\tuint256 internal _scheduleTokenAmount;\n\n\tconstructor(address soloMarginAddress, address payable wethAddress)\n\t\tBalanceCarrier(address(1))\n\t\tWETHHandler(wethAddress)\n\t{\n\t\t_soloMarginAddress = soloMarginAddress;\n\t}\n\n\tfunction registerPool(uint256 marketId) external onlyOwner {\n\t\taddress tokenAddress = unmapTokenAddress(ISoloMargin(_soloMarginAddress).getMarketTokenAddress(marketId));\n\t\trequire(tokenAddress != address(0), \"SoloLiquidityProxy: cannot register empty market\");\n\n\t\t_tokenAddressToMarketId[tokenAddress] = marketId;\n\t\t_marketIdToTokenAddress[marketId] = tokenAddress;\n\t\t_tokenAddressRegistered[tokenAddress] = true;\n\t\tIERC20(remapTokenAddress(tokenAddress)).approve(_soloMarginAddress, type(uint256).max);\n\t}\n\n\tfunction deregisterPool(uint256 marketId) external onlyOwner {\n\t\taddress tokenAddress = _marketIdToTokenAddress[marketId];\n\n\t\t_tokenAddressToMarketId[tokenAddress] = 0;\n\t\t_marketIdToTokenAddress[marketId] = address(0);\n\t\t_tokenAddressRegistered[tokenAddress] = false;\n\t\tIERC20(remapTokenAddress(tokenAddress)).approve(_soloMarginAddress, 0);\n\t}\n\n\tfunction getRepaymentAddress(address tokenAddress) external view override returns (address) {\n\t\treturn address(this);\n\t}\n\n\tfunction getTotalReserve(address tokenAddress) external view override returns (uint256) {\n\t\tif (isRegistered(tokenAddress) && !isClosing(tokenAddress)) {\n\t\t\treturn IERC20(remapTokenAddress(tokenAddress)).balanceOf(_soloMarginAddress);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getRepaymentAmount(address tokenAddress, uint256 tokenAmount) external view override returns (uint256) {\n\t\treturn getRepaymentAmountInternal(tokenAddress, tokenAmount);\n\t}\n\n\tfunction getRepaymentAmountInternal(address tokenAddress, uint256 tokenAmount) internal view returns (uint256) {\n\t\t// Add 1 wei for markets 0-1 and 2 wei for markets 2-3\n\t\treturn tokenAmount.add(marketIdFromTokenAddress(tokenAddress) < 2 ? 1 : 2);\n\t}\n\n\tfunction borrow(address tokenAddress, uint256 tokenAmount) external override {\n\t\t_scheduleInvokerAddress = payable(msg.sender);\n\t\t_scheduleTokenAddress = tokenAddress;\n\t\t_scheduleTokenAmount = tokenAmount;\n\n\t\tISoloMargin solo = ISoloMargin(_soloMarginAddress);\n\t\tTypes.ActionArgs[] memory operations = new Types.ActionArgs[](3);\n\t\toperations[0] = getWithdrawAction(tokenAddress, tokenAmount);\n\t\toperations[1] = getCallAction();\n\t\toperations[2] = getDepositAction(tokenAddress, getRepaymentAmountInternal(tokenAddress, tokenAmount));\n\t\tTypes.AccountInfo[] memory accountInfos = new Types.AccountInfo[](1);\n\t\taccountInfos[0] = getAccountInfo();\n\n\t\tsolo.operate(accountInfos, operations);\n\n\t\t_scheduleInvokerAddress = payable(address(0));\n\t\t_scheduleTokenAddress = address(0);\n\t\t_scheduleTokenAmount = 0;\n\t}\n\n\tfunction callFunction(\n\t\taddress sender,\n\t\tTypes.AccountInfo memory accountInfo,\n\t\tbytes memory data\n\t) public override {\n\t\trequire(_scheduleInvokerAddress != address(0), \"SoloLiquidityProxy: not scheduled\");\n\n\t\tif (_scheduleTokenAddress == address(1)) {\n\t\t\tunwrap(_scheduleTokenAmount);\n\t\t}\n\n\t\trequire(\n\t\t\ttransfer(_scheduleTokenAddress, _scheduleInvokerAddress, _scheduleTokenAmount),\n\t\t\t\"SoloLiquidityProxy: transfer to invoker failed\"\n\t\t);\n\n\t\tIInvoker invoker = IInvoker(_scheduleInvokerAddress);\n\t\tinvoker.invokeCallback();\n\n\t\tif (_scheduleTokenAddress == address(1)) {\n\t\t\twrap(getRepaymentAmountInternal(_scheduleTokenAddress, _scheduleTokenAmount));\n\t\t}\n\t}\n\n\tfunction getAccountInfo() internal view returns (Types.AccountInfo memory) {\n\t\treturn Types.AccountInfo({ owner: address(this), number: 1 });\n\t}\n\n\tfunction getWithdrawAction(address tokenAddress, uint256 tokenAmount)\n\t\tinternal\n\t\tview\n\t\treturns (Types.ActionArgs memory)\n\t{\n\t\treturn\n\t\t\tTypes.ActionArgs({\n\t\t\t\tactionType: Types.ActionType.Withdraw,\n\t\t\t\taccountId: 0,\n\t\t\t\tamount: Types.AssetAmount({\n\t\t\t\t\tsign: false,\n\t\t\t\t\tdenomination: Types.AssetDenomination.Wei,\n\t\t\t\t\tref: Types.AssetReference.Delta,\n\t\t\t\t\tvalue: tokenAmount\n\t\t\t\t}),\n\t\t\t\tprimaryMarketId: marketIdFromTokenAddress(tokenAddress),\n\t\t\t\tsecondaryMarketId: NULL_MARKET_ID,\n\t\t\t\totherAddress: address(this),\n\t\t\t\totherAccountId: NULL_ACCOUNT_ID,\n\t\t\t\tdata: NULL_DATA\n\t\t\t});\n\t}\n\n\tfunction getDepositAction(address tokenAddress, uint256 repaymentAmount)\n\t\tinternal\n\t\tview\n\t\treturns (Types.ActionArgs memory)\n\t{\n\t\treturn\n\t\t\tTypes.ActionArgs({\n\t\t\t\tactionType: Types.ActionType.Deposit,\n\t\t\t\taccountId: 0,\n\t\t\t\tamount: Types.AssetAmount({\n\t\t\t\t\tsign: true,\n\t\t\t\t\tdenomination: Types.AssetDenomination.Wei,\n\t\t\t\t\tref: Types.AssetReference.Delta,\n\t\t\t\t\tvalue: repaymentAmount\n\t\t\t\t}),\n\t\t\t\tprimaryMarketId: marketIdFromTokenAddress(tokenAddress),\n\t\t\t\tsecondaryMarketId: NULL_MARKET_ID,\n\t\t\t\totherAddress: address(this),\n\t\t\t\totherAccountId: NULL_ACCOUNT_ID,\n\t\t\t\tdata: NULL_DATA\n\t\t\t});\n\t}\n\n\tfunction getCallAction() internal view returns (Types.ActionArgs memory) {\n\t\treturn\n\t\t\tTypes.ActionArgs({\n\t\t\t\tactionType: Types.ActionType.Call,\n\t\t\t\taccountId: 0,\n\t\t\t\tamount: NULL_AMOUNT,\n\t\t\t\tprimaryMarketId: NULL_MARKET_ID,\n\t\t\t\tsecondaryMarketId: NULL_MARKET_ID,\n\t\t\t\totherAddress: address(this),\n\t\t\t\totherAccountId: NULL_ACCOUNT_ID,\n\t\t\t\tdata: NULL_DATA\n\t\t\t});\n\t}\n\n\tfunction isRegistered(address tokenAddress) internal view returns (bool) {\n\t\treturn _tokenAddressRegistered[tokenAddress];\n\t}\n\n\tfunction marketIdFromTokenAddress(address tokenAddress) internal view returns (uint256) {\n\t\treturn _tokenAddressToMarketId[tokenAddress];\n\t}\n\n\tfunction remapTokenAddress(address tokenAddress) internal view returns (address) {\n\t\treturn tokenAddress == address(1) ? _wethAddress : tokenAddress;\n\t}\n\n\tfunction unmapTokenAddress(address tokenAddress) internal view returns (address) {\n\t\treturn tokenAddress == _wethAddress ? address(1) : tokenAddress;\n\t}\n\n\tfunction isClosing(address tokenAddress) internal view returns (bool) {\n\t\tuint256 marketId = _tokenAddressToMarketId[tokenAddress];\n\t\treturn ISoloMargin(_soloMarginAddress).getMarketIsClosing(marketId);\n\t}\n\n\tfallback() external payable {}\n}\n"
    },
    "contracts/common/utils/WETHHandler.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./IWETH9.sol\";\n\nabstract contract WETHHandler {\n\taddress payable internal _wethAddress;\n\n\tconstructor(address payable wethAddress) {\n\t\t_wethAddress = wethAddress;\n\t}\n\n\tfunction wrap(uint256 tokenAmount) internal {\n\t\trequire(address(this).balance >= tokenAmount, \"WETHHandler: not enough ether balance\");\n\t\tIWETH9(_wethAddress).deposit{ value: tokenAmount }();\n\t}\n\n\tfunction unwrap(uint256 tokenAmount) internal {\n\t\tIWETH9 weth = IWETH9(_wethAddress);\n\t\trequire(weth.balanceOf(address(this)) >= tokenAmount, \"WETHHandler: not enough weth balance\");\n\t\tweth.withdraw(tokenAmount);\n\t}\n}\n"
    },
    "contracts/common/utils/IWETH9.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nabstract contract IWETH9 {\n\tmapping(address => uint256) public balanceOf;\n\n\tfunction deposit() public payable virtual;\n\n\tfunction withdraw(uint256 wad) public virtual;\n}\n"
    },
    "contracts/liquidity/aave/AaveLiquidityProxy.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./ILendingPool.sol\";\nimport \"./ILendingPoolAddressesProvider.sol\";\nimport \"./ILendingPoolCore.sol\";\nimport \"./ILendingPoolParametersProvider.sol\";\nimport \"../ILiquidityProxy.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\nimport \"../../interfaces/token/ERC20/IERC20.sol\";\nimport \"../../common/invoke/IInvoker.sol\";\nimport \"../../common/utils/BalanceCarrier.sol\";\n\ncontract AaveLiquidityProxy is BalanceCarrier, ILiquidityProxy {\n\tusing SafeMath for uint256;\n\n\taddress internal ETHER_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\tILendingPoolAddressesProvider internal _lendingPoolAddressProvider;\n\n\taddress payable internal _scheduleInvokerAddress;\n\n\tconstructor(ILendingPoolAddressesProvider lendingPoolAddressProvider) BalanceCarrier(ETHER_TOKEN_ADDRESS) {\n\t\t_lendingPoolAddressProvider = lendingPoolAddressProvider;\n\t}\n\n\tfunction getRepaymentAddress(address tokenAddress) external view override returns (address) {\n\t\treturn _lendingPoolAddressProvider.getLendingPoolCore();\n\t}\n\n\tfunction getTotalReserve(address tokenAddress) external view override returns (uint256) {\n\t\taddress core = _lendingPoolAddressProvider.getLendingPoolCore();\n\n\t\tif (isRegistered(tokenAddress)) {\n\t\t\treturn tokenAddress == address(1) ? core.balance : IERC20(tokenAddress).balanceOf(core);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfunction getRepaymentAmount(address tokenAddress, uint256 tokenAmount) external view override returns (uint256) {\n\t\tILendingPoolParametersProvider params =\n\t\t\tILendingPoolParametersProvider(_lendingPoolAddressProvider.getLendingPoolParametersProvider());\n\t\t(uint256 totalFeeBips, uint256 _void) = params.getFlashLoanFeesInBips();\n\n\t\tuint256 amountFee = tokenAmount.mul(totalFeeBips).div(10000);\n\t\treturn tokenAmount.add(amountFee);\n\t}\n\n\tfunction borrow(address tokenAddress, uint256 tokenAmount) external override {\n\t\t_scheduleInvokerAddress = payable(msg.sender);\n\n\t\tILendingPool lendingPool = ILendingPool(_lendingPoolAddressProvider.getLendingPool());\n\t\tlendingPool.flashLoan(address(this), remapTokenAddress(tokenAddress), tokenAmount, \"\");\n\n\t\t_scheduleInvokerAddress = payable(address(0));\n\t}\n\n\tfunction executeOperation(\n\t\taddress _reserve,\n\t\tuint256 _amount,\n\t\tuint256 _fee,\n\t\tbytes calldata _params\n\t) external {\n\t\trequire(_scheduleInvokerAddress != address(0), \"AaveLiquidityProxy: not scheduled\");\n\n\t\trequire(transfer(_reserve, _scheduleInvokerAddress, _amount), \"AaveLiquidityProxy: transfer to invoker failed\");\n\n\t\tIInvoker invoker = IInvoker(_scheduleInvokerAddress);\n\t\tinvoker.invokeCallback();\n\t}\n\n\tfunction isRegistered(address tokenAddress) internal view returns (bool) {\n\t\tILendingPoolCore core = ILendingPoolCore(_lendingPoolAddressProvider.getLendingPoolCore());\n\t\treturn core.getReserveIsActive(remapTokenAddress(tokenAddress));\n\t}\n\n\tfunction remapTokenAddress(address tokenAddress) internal view returns (address) {\n\t\treturn tokenAddress == address(1) ? ETHER_TOKEN_ADDRESS : tokenAddress;\n\t}\n\n\tfallback() external {}\n}\n"
    },
    "contracts/liquidity/aave/ILendingPool.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface ILendingPool {\n\tfunction flashLoan(\n\t\taddress _receiver,\n\t\taddress _reserve,\n\t\tuint256 _amount,\n\t\tbytes memory _params\n\t) external;\n}\n"
    },
    "contracts/liquidity/aave/ILendingPoolAddressesProvider.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface ILendingPoolAddressesProvider {\n\tfunction getLendingPool() external view returns (address);\n\n\tfunction getLendingPoolCore() external view returns (address payable);\n\n\tfunction getLendingPoolParametersProvider() external view returns (address);\n}\n"
    },
    "contracts/liquidity/aave/ILendingPoolCore.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface ILendingPoolCore {\n\tfunction getReserveIsActive(address _reserve) external view returns (bool);\n}\n"
    },
    "contracts/liquidity/aave/ILendingPoolParametersProvider.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ninterface ILendingPoolParametersProvider {\n\tfunction getFlashLoanFeesInBips() external pure returns (uint256, uint256);\n}\n"
    },
    "contracts/Invoker.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./common/utils/BalanceCarrier.sol\";\nimport \"./common/invoke/IInvokable.sol\";\nimport \"./common/invoke/IInvoker.sol\";\nimport \"./libraries/access/Ownable.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./liquidity/ILiquidityProxy.sol\";\n\ncontract Invoker is BalanceCarrier, IInvoker, Ownable {\n\tusing SafeMath for uint256;\n\n\tevent Invocation(address invokeTo, uint256 invokeValue, bytes32 invokeDataHash, uint256 underlyingAmount);\n\tevent Reward(uint256 poolReward, uint256 platformReward, address tokenAddress);\n\n\tmapping(address => address[]) internal _liquidityProxies;\n\tuint256 internal _poolRewardBips;\n\tmapping(address => address) _poolRewardAddresses;\n\tuint256 internal _platformRewardBips;\n\taddress internal _platformVaultAddress;\n\n\tbool internal _scheduled;\n\tuint256 internal _schedulePriorTokenAmount;\n\taddress internal _scheduleInvokeSender;\n\taddress internal _scheduleInvokeTo;\n\tuint256 internal _scheduleInvokeValue;\n\tbytes internal _scheduleInvokeData;\n\tuint256 internal _scheduleIndex;\n\taddress internal _scheduleTokenAddress;\n\tuint256 internal _scheduleTokenAmount;\n\tuint256[] internal _scheduleTokenAmounts;\n\tuint256 internal _scheduleRepayAmount;\n\tuint256[] internal _scheduleRepayAmounts;\n\tuint256 internal _schedulePoolReward;\n\tuint256 internal _schedulePlatformReward;\n\n\tconstructor() BalanceCarrier(address(1)) {}\n\n\tfunction invoke(\n\t\taddress invokeTo,\n\t\tbytes calldata invokeData,\n\t\taddress tokenAddress,\n\t\tuint256 tokenAmount\n\t) external payable override onlyFresh {\n\t\trequire(isTokenAddressRegistered(tokenAddress), \"Invoker: no liquidity for token\");\n\t\trequire(invokeTo != address(this), \"Invoker: cannot invoke this contract\");\n\n\t\tscheduleExecution(msg.sender, invokeTo, msg.value, invokeData, tokenAddress, tokenAmount);\n\n\t\tinvokeNext();\n\n\t\tdisburseReward();\n\n\t\tcleanSchedule();\n\t}\n\n\tfunction invokeNext() internal {\n\t\tILiquidityProxy proxy = ILiquidityProxy(liquidityProxy(_scheduleIndex));\n\t\tproxy.borrow(_scheduleTokenAddress, _scheduleTokenAmounts[_scheduleIndex]);\n\t}\n\n\tfunction invokeCallback() external override onlyScheduled {\n\t\t_scheduleIndex++;\n\t\tif (_scheduleIndex == _scheduleTokenAmounts.length) {\n\t\t\tinvokeFinal();\n\t\t} else {\n\t\t\tinvokeNext();\n\t\t}\n\t}\n\n\tfunction invokeFinal() internal {\n\t\tuint256 expectedPriorTokenAmount = _schedulePriorTokenAmount.add(_scheduleTokenAmount);\n\t\tuint256 currentTokenAmount = balanceOf(_scheduleTokenAddress).sub(payableReserveAdjustment());\n\t\trequire(currentTokenAmount == expectedPriorTokenAmount, \"Invoker: incorrect liquidity amount sourced\");\n\t\trequire(transfer(_scheduleTokenAddress, _scheduleInvokeTo, _scheduleTokenAmount), \"Invoker: transfer failed\");\n\n\t\tIInvokable(_scheduleInvokeTo).execute{ value: _scheduleInvokeValue }(_scheduleInvokeData);\n\t\temit Invocation(_scheduleInvokeTo, _scheduleInvokeValue, keccak256(_scheduleInvokeData), _scheduleTokenAmount);\n\n\t\tuint256 expectedResultingTokenAmount = _schedulePriorTokenAmount.add(_scheduleRepayAmount);\n\t\trequire(balanceOf(_scheduleTokenAddress) == expectedResultingTokenAmount, \"Invoker: incorrect repayment amount\");\n\n\t\tfor (uint256 i = 0; i < _scheduleRepayAmounts.length; i++) {\n\t\t\taddress repaymentAddress = ILiquidityProxy(liquidityProxy(i)).getRepaymentAddress(_scheduleTokenAddress);\n\t\t\trequire(\n\t\t\t\ttransfer(_scheduleTokenAddress, repaymentAddress, _scheduleRepayAmounts[i]),\n\t\t\t\t\"Invoker: pool repayment transfer failed\"\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction disburseReward() internal {\n\t\tuint256 modifiedPoolReward = _poolRewardAddresses[_scheduleTokenAddress] == address(0) ? 0 : _schedulePoolReward;\n\t\tif (modifiedPoolReward > 0) {\n\t\t\trequire(\n\t\t\t\ttransfer(_scheduleTokenAddress, _poolRewardAddresses[_scheduleTokenAddress], modifiedPoolReward),\n\t\t\t\t\"Invoker: pool reward transfer failed\"\n\t\t\t);\n\t\t}\n\t\tif (_schedulePlatformReward > 0) {\n\t\t\trequire(\n\t\t\t\ttransfer(_scheduleTokenAddress, _platformVaultAddress, _schedulePlatformReward),\n\t\t\t\t\"Invoker: platform reward transfer failed\"\n\t\t\t);\n\t\t}\n\t\temit Reward(modifiedPoolReward, _schedulePlatformReward, _scheduleTokenAddress);\n\t}\n\n\t/*\n\t * EXECUTION SCHEDULING\n\t */\n\n\tfunction scheduleExecution(\n\t\taddress invokeSender,\n\t\taddress invokeTo,\n\t\tuint256 invokeValue,\n\t\tbytes memory invokeData,\n\t\taddress tokenAddress,\n\t\tuint256 tokenAmount\n\t) internal {\n\t\t_scheduleInvokeSender = invokeSender;\n\t\t_scheduleInvokeTo = invokeTo;\n\t\t_scheduleInvokeValue = invokeValue;\n\t\t_scheduleInvokeData = invokeData;\n\t\t_scheduleTokenAddress = tokenAddress;\n\t\t_scheduleTokenAmount = tokenAmount;\n\t\t_schedulePriorTokenAmount = balanceOf(tokenAddress).sub(payableReserveAdjustment());\n\n\t\tuint256 tokenAmountLeft = tokenAmount;\n\t\tfor (uint256 i = 0; i < liquidityProxiesForToken(); i++) {\n\t\t\tILiquidityProxy proxy = ILiquidityProxy(liquidityProxy(i));\n\t\t\tuint256 totalReserve = proxy.getTotalReserve(tokenAddress);\n\t\t\tif (totalReserve == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tokenAmountLeft <= totalReserve) {\n\t\t\t\tuint256 proxyRepayAmount = proxy.getRepaymentAmount(tokenAddress, tokenAmountLeft);\n\t\t\t\t_scheduleTokenAmounts.push(tokenAmountLeft);\n\t\t\t\t_scheduleRepayAmounts.push(proxyRepayAmount);\n\t\t\t\t_scheduleRepayAmount = _scheduleRepayAmount.add(proxyRepayAmount);\n\t\t\t\ttokenAmountLeft = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tuint256 proxyRepayAmount = proxy.getRepaymentAmount(tokenAddress, totalReserve);\n\t\t\t\t_scheduleTokenAmounts.push(totalReserve);\n\t\t\t\t_scheduleRepayAmounts.push(proxyRepayAmount);\n\t\t\t\t_scheduleRepayAmount = _scheduleRepayAmount.add(proxyRepayAmount);\n\t\t\t\ttokenAmountLeft = tokenAmountLeft.sub(totalReserve);\n\t\t\t}\n\t\t}\n\t\trequire(tokenAmountLeft == 0, \"Invoker: not enough liquidity\");\n\n\t\t_schedulePoolReward = calculatePoolReward(_scheduleTokenAmount);\n\t\t_schedulePlatformReward = calculatePlatformReward(_scheduleTokenAmount);\n\t\t_scheduleRepayAmount = _scheduleRepayAmount.add(_schedulePoolReward).add(_schedulePlatformReward);\n\n\t\t_scheduled = true;\n\t}\n\n\tfunction cleanSchedule() internal {\n\t\t_scheduled = false;\n\t\t_schedulePriorTokenAmount = 0;\n\t\t_scheduleInvokeSender = address(0);\n\t\t_scheduleInvokeTo = address(0);\n\t\t_scheduleInvokeValue = 0;\n\t\tdelete _scheduleInvokeData;\n\t\t_scheduleIndex = 0;\n\t\t_scheduleTokenAddress = address(0);\n\t\t_scheduleTokenAmount = 0;\n\t\tdelete _scheduleTokenAmounts;\n\t\t_scheduleRepayAmount = 0;\n\t\tdelete _scheduleRepayAmounts;\n\t\t_schedulePoolReward = 0;\n\t\t_schedulePlatformReward = 0;\n\t}\n\n\t/*\n\t * INVOKABLE HELPERS\n\t */\n\n\tfunction currentSender() external view override returns (address) {\n\t\treturn _scheduleInvokeSender;\n\t}\n\n\tfunction currentTokenAddress() external view override returns (address) {\n\t\treturn _scheduleTokenAddress;\n\t}\n\n\tfunction currentTokenAmount() external view override returns (uint256) {\n\t\treturn _scheduleTokenAmount;\n\t}\n\n\tfunction currentRepaymentAmount() external view override returns (uint256) {\n\t\treturn _scheduleRepayAmount;\n\t}\n\n\tfunction estimateRepaymentAmount(address tokenAddress, uint256 tokenAmount) external view returns (uint256) {\n\t\trequire(isTokenAddressRegistered(tokenAddress), \"Invoker: no liquidity for token\");\n\n\t\tuint256 repaymentAmount = 0;\n\t\tuint256 tokenAmountLeft = tokenAmount;\n\n\t\tfor (uint256 i = 0; i < _liquidityProxies[tokenAddress].length; i++) {\n\t\t\tILiquidityProxy proxy = ILiquidityProxy(_liquidityProxies[tokenAddress][i]);\n\t\t\tuint256 totalReserve = proxy.getTotalReserve(tokenAddress);\n\t\t\tif (tokenAmountLeft <= totalReserve) {\n\t\t\t\tuint256 proxyRepayAmount = proxy.getRepaymentAmount(tokenAddress, tokenAmountLeft);\n\t\t\t\trepaymentAmount = repaymentAmount.add(proxyRepayAmount);\n\t\t\t\ttokenAmountLeft = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tuint256 proxyRepayAmount = proxy.getRepaymentAmount(tokenAddress, totalReserve);\n\t\t\t\trepaymentAmount = repaymentAmount.add(proxyRepayAmount);\n\t\t\t\ttokenAmountLeft = tokenAmountLeft.sub(totalReserve);\n\t\t\t}\n\t\t}\n\t\trequire(tokenAmountLeft == 0, \"Invoker: not enough liquidity\");\n\n\t\treturn repaymentAmount.add(calculatePoolReward(tokenAmount)).add(calculatePlatformReward(tokenAmount));\n\t}\n\n\t/*\n\t * REWARDS\n\t */\n\n\tfunction calculatePoolReward(uint256 tokenAmount) internal view returns (uint256) {\n\t\treturn tokenAmount.mul(_poolRewardBips).div(10000);\n\t}\n\n\tfunction calculatePlatformReward(uint256 tokenAmount) internal view returns (uint256) {\n\t\treturn tokenAmount.mul(_platformRewardBips).div(10000);\n\t}\n\n\tfunction poolReward() external view override returns (uint256) {\n\t\treturn _poolRewardBips;\n\t}\n\n\tfunction poolRewardAddress(address tokenAddress) external view override returns (address) {\n\t\treturn _poolRewardAddresses[tokenAddress];\n\t}\n\n\tfunction platformReward() external view override returns (uint256) {\n\t\treturn _platformRewardBips;\n\t}\n\n\tfunction platformVaultAddress() external view override returns (address) {\n\t\treturn _platformVaultAddress;\n\t}\n\n\tfunction setPoolReward(uint256 poolRewardBips) external onlyFresh onlyOwner {\n\t\t_poolRewardBips = poolRewardBips;\n\t}\n\n\tfunction setPoolRewardAddress(address tokenAddress, address rewardAddress) external onlyFresh onlyOwner {\n\t\t_poolRewardAddresses[tokenAddress] = rewardAddress;\n\t}\n\n\tfunction setPlatformReward(uint256 platformRewardBips) external onlyFresh onlyOwner {\n\t\t_platformRewardBips = platformRewardBips;\n\t}\n\n\tfunction setPlatformVaultAddress(address vaultAddress) external onlyFresh onlyOwner {\n\t\t_platformVaultAddress = vaultAddress;\n\t}\n\n\t/*\n\t * ASSET HELPERS\n\t */\n\n\tfunction payableReserveAdjustment() internal view returns (uint256) {\n\t\treturn _scheduleTokenAddress == address(1) ? _scheduleInvokeValue : 0;\n\t}\n\n\t/*\n\t * LIQUIDITY PROXIES\n\t */\n\n\tfunction setLiquidityProxies(address tokenAddress, address[] calldata liquidityProxies) external onlyFresh onlyOwner {\n\t\t_liquidityProxies[tokenAddress] = liquidityProxies;\n\t}\n\n\tfunction liquidityProxies(address tokenAddress) external view returns (address[] memory) {\n\t\treturn _liquidityProxies[tokenAddress];\n\t}\n\n\tfunction isTokenAddressRegistered(address tokenAddress) public view override returns (bool) {\n\t\treturn _liquidityProxies[tokenAddress].length > 0;\n\t}\n\n\tfunction liquidityProxy(uint256 index) internal view returns (address) {\n\t\treturn _liquidityProxies[_scheduleTokenAddress][index];\n\t}\n\n\tfunction liquidityProxiesForToken() internal view returns (uint256) {\n\t\treturn _liquidityProxies[_scheduleTokenAddress].length;\n\t}\n\n\tfunction totalLiquidity(address tokenAddress) external view override returns (uint256) {\n\t\tif (isTokenAddressRegistered(tokenAddress)) {\n\t\t\tuint256 total = 0;\n\t\t\tfor (uint256 i = 0; i < _liquidityProxies[tokenAddress].length; i++) {\n\t\t\t\tILiquidityProxy proxy = ILiquidityProxy(_liquidityProxies[tokenAddress][i]);\n\t\t\t\ttotal = total.add(proxy.getTotalReserve(tokenAddress));\n\t\t\t}\n\t\t\treturn total;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* This contract should never have a token balance at rest. If so it is in error, then transfer the tokens to vault */\n\tfunction removeStuckTokens(address tokenAddress, uint256 amount) external onlyFresh onlyOwner returns (bool) {\n\t\treturn transfer(tokenAddress, _platformVaultAddress, amount);\n\t}\n\n\t/*\n\t * MODIFIERS\n\t */\n\n\tmodifier onlyFresh() {\n\t\trequire(!_scheduled, \"Invoker: not fresh environment\");\n\t\t_;\n\t}\n\n\tmodifier onlyScheduled() {\n\t\trequire(_scheduled, \"Invoker: not scheduled\");\n\t\t_;\n\t}\n\n\tfallback() external payable {}\n}\n"
    },
    "contracts/testing/TestOnChainInvokable.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../libraries/access/Ownable.sol\";\nimport \"../common/invoke/KingmakerInvokable.sol\";\n\n/*\n *  NOTICE: ONLY FOR ON-CHAIN TESTING - THIS CONTRACT IS VULNERABLE TO LOSS OF FUNDS\n */\ncontract TestOnChainInvokable is KingmakerInvokable, Ownable {\n\tconstructor() {}\n\n\tevent HelperDump(\n\t\taddress sender,\n\t\tbytes32 dataHash,\n\t\taddress currentTokenAddress,\n\t\tuint256 currentTokenAmount,\n\t\tuint256 currentRepaymentAmount,\n\t\tbool isCurrentTokenEther\n\t);\n\n\tfunction execute(bytes calldata data) external payable override {\n\t\temitHelper(data);\n\t\trepay();\n\t}\n\n\tfunction emitHelper(bytes memory data) internal {\n\t\temit HelperDump(\n\t\t\tcurrentSender(),\n\t\t\tkeccak256(data),\n\t\t\tcurrentTokenAddress(),\n\t\t\tcurrentTokenAmount(),\n\t\t\tcurrentRepaymentAmount(),\n\t\t\tisCurrentTokenEther()\n\t\t);\n\t}\n\n\tfunction withdraw(address tokenAddress, uint256 amount) external onlyOwner returns (bool) {\n\t\treturn transfer(tokenAddress, msg.sender, amount);\n\t}\n\n\tfallback() external {}\n}\n"
    },
    "contracts/common/invoke/KingmakerInvokable.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./IInvokable.sol\";\nimport \"./IInvocationHook.sol\";\nimport \"../utils/BalanceCarrier.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\n\nabstract contract KingmakerInvokable is BalanceCarrier, IInvokable {\n\tusing SafeMath for uint256;\n\n\tuint256 internal MAX_REWARD_BIPS = 100;\n\n\tconstructor() BalanceCarrier(address(1)) {}\n\n\tfunction repay() internal repaymentSafeguard {\n\t\trequire(\n\t\t\ttransfer(currentTokenAddress(), msg.sender, currentRepaymentAmount()),\n\t\t\t\"KingmakerInvokable: failed to repay\"\n\t\t);\n\t}\n\n\tfunction currentSender() internal view returns (address) {\n\t\treturn IInvocationHook(msg.sender).currentSender();\n\t}\n\n\tfunction currentTokenAddress() internal view returns (address) {\n\t\treturn IInvocationHook(msg.sender).currentTokenAddress();\n\t}\n\n\tfunction currentTokenAmount() internal view returns (uint256) {\n\t\treturn IInvocationHook(msg.sender).currentTokenAmount();\n\t}\n\n\tfunction currentRepaymentAmount() internal view returns (uint256) {\n\t\treturn IInvocationHook(msg.sender).currentRepaymentAmount();\n\t}\n\n\tfunction isCurrentTokenEther() internal view returns (bool) {\n\t\treturn currentTokenAddress() == address(1);\n\t}\n\n\tmodifier repaymentSafeguard() {\n\t\tuint256 effectiveReward = currentRepaymentAmount().sub(currentTokenAmount()).mul(10000).div(currentTokenAmount());\n\n\t\trequire(effectiveReward <= MAX_REWARD_BIPS, \"KingmakerInvokable: repayment reward too high\");\n\t\t_;\n\t}\n}\n"
    },
    "contracts/testing/TestInvokable.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../common/invoke/KingmakerInvokable.sol\";\n\ncontract TestInvokable is KingmakerInvokable {\n\tconstructor() {}\n\n\tevent HelperDump(\n\t\taddress sender,\n\t\tbytes32 dataHash,\n\t\taddress currentTokenAddress,\n\t\tuint256 currentTokenAmount,\n\t\tuint256 currentRepaymentAmount,\n\t\tbool isCurrentTokenEther\n\t);\n\tevent SwapDump(bytes swapData);\n\n\t// To setup state for specific tests\n\tfunction invoke(address invokeAddress, bytes calldata invokeData) external payable {\n\t\texternalCall(invokeAddress, msg.value, invokeData);\n\t}\n\n\tfunction execute(bytes calldata data) external payable override {\n\t\temitHelper(data);\n\n\t\tif (data.length == 0) {\n\t\t\treturn executeNoop();\n\t\t}\n\n\t\t(uint256 testType, bytes memory testData) = abi.decode(data, (uint256, bytes));\n\t\tif (testType == 1) {\n\t\t\tuint256 repaymentAmount = abi.decode(testData, (uint256));\n\t\t\treturn executeRepayAmount(repaymentAmount);\n\t\t}\n\t\tif (testType == 3) {\n\t\t\t(address invokeAddress, bytes memory invokeData) = abi.decode(testData, (address, bytes));\n\t\t\treturn executeInvoke(invokeAddress, invokeData);\n\t\t}\n\t\tif (testType == 4) {\n\t\t\tuint256 amount = abi.decode(testData, (uint256));\n\t\t\treturn executePayable(amount);\n\t\t}\n\t}\n\n\tfunction executeNoop() internal {\n\t\trepay();\n\t}\n\n\tfunction executeRepayAmount(uint256 amount) internal {\n\t\ttransfer(currentTokenAddress(), msg.sender, amount);\n\t}\n\n\tfunction executeInvoke(address invokeAddress, bytes memory invokeData) internal {\n\t\texternalCall(invokeAddress, msg.value, invokeData);\n\t\trepay();\n\t}\n\n\tfunction executePayable(uint256 amount) internal {\n\t\trequire(msg.value == amount, \"TestInvokable: did not forward value\");\n\t\trepay();\n\t}\n\n\tfunction emitHelper(bytes memory data) internal {\n\t\temit HelperDump(\n\t\t\tcurrentSender(),\n\t\t\tkeccak256(data),\n\t\t\tcurrentTokenAddress(),\n\t\t\tcurrentTokenAmount(),\n\t\t\tcurrentRepaymentAmount(),\n\t\t\tisCurrentTokenEther()\n\t\t);\n\t}\n\n\tfallback() external payable {}\n}\n"
    },
    "contracts/facets/governance/CrownGovernanceToken.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"hardhat/console.sol\";\n\nimport \"../../interfaces/token/ERC20/IERC20.sol\";\nimport \"../../libraries/math/SafeMath.sol\";\n\n/**\n * @title KING\n * @dev The governance token for the Kingmaker protocol\n * @notice ERC-20 with supply controls + add-ons to allow for offchain signing (see EIP-712, EIP-2612, and EIP-3009)\n */\ncontract CrownGovernanceToken is IERC20 {\n\tusing SafeMath for uint256;\n\n\t/// @notice EIP-20 token name for this token\n\tstring public name = \"Kingmaker Governance Token\";\n\n\t/// @notice EIP-20 token symbol for this token\n\tstring public symbol = \"KING\";\n\n\t/// @notice EIP-20 token decimals for this token\n\tuint8 public constant decimals = 18;\n\n\t/// @notice Total number of tokens in circulation\n\tuint256 public override totalSupply = 90000e18; // 90 thousands units\n\n\t/// @notice Address which may mint/burn tokens\n\taddress public supplyManager;\n\n\t/// @notice Address which may change token metadata\n\taddress public metadataManager;\n\n\t/// @notice The timestamp after which a supply change may occur\n\tuint256 public supplyChangeAllowedAfter;\n\n\t/// @notice The initial minimum waiting time for changing the token supply\n\tuint32 public supplyChangeWaitingPeriod = 1 days * 365; // 1 year\n\n\t/// @notice Hard cap on the minimum waiting time for changing the token supply\n\tuint32 public constant supplyChangeWaitingPeriodMinimum = 1 days * 90;\n\t// solhint-disable-next-line max-line-length\n\t/// @notice Cap on the total amount that can be minted at each mint (measured in bips: 10,000 bips = 1% of current totalSupply)\n\tuint32 public mintCap = 900000;\n\n\t/// @dev Allowance amounts on behalf of others\n\tmapping(address => mapping(address => uint256)) internal allowances;\n\n\t/// @dev Official record of token balances for each account\n\tmapping(address => uint256) internal balances;\n\n\t/// @notice The EIP-712 typehash for the contract's domain\n\t/// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n\t/// @notice The EIP-712 version hash\n\t/// keccak256(\"1\");\n\tbytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n\t/// @notice The EIP-712 typehash for permit (EIP-2612)\n\t/// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/// @notice The EIP-712 typehash for transferWithAuthorization (EIP-3009)\n\t// solhint-disable-next-line max-line-length\n\t/// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n\t\t0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/// @notice The EIP-712 typehash for receiveWithAuthorization (EIP-3009)\n\t// solhint-disable-next-line max-line-length\n\t/// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\n\t\t0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/// @notice A record of states for signing / validating signatures\n\tmapping(address => uint256) public nonces;\n\n\t/// @dev authorizer address > nonce > state (true = used / false = unused)\n\tmapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n\t/// @notice An event that's emitted when the mintCap is changed\n\tevent MintCapChanged(uint32 indexed oldMintCap, uint32 indexed newMintCap);\n\n\t/// @notice An event that's emitted when the supplyManager address is changed\n\tevent SupplyManagerChanged(address indexed oldManager, address indexed newManager);\n\n\t/// @notice An event that's emitted when the supplyChangeWaitingPeriod is changed\n\tevent SupplyChangeWaitingPeriodChanged(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\n\n\t/// @notice An event that's emitted when the metadataManager address is changed\n\tevent MetadataManagerChanged(address indexed oldManager, address indexed newManager);\n\n\t/// @notice An event that's emitted when the token name and symbol are changed\n\tevent TokenMetaUpdated(string indexed name, string indexed symbol);\n\n\t/// @notice An event that's emitted whenever an authorized transfer occurs\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @notice Construct a new KING token\n\t * @param _metadataManager The address with the ability to alter the token metadata\n\t * @param _supplyManager The address with the ability to mint more tokens\n\t * @param _firstSupplyChangeAllowed The timestamp after which the first supply change may occur\n\t */\n\tconstructor(\n\t\taddress _metadataManager,\n\t\taddress _supplyManager,\n\t\tuint256 _firstSupplyChangeAllowed\n\t) {\n\t\trequire(\n\t\t\t_firstSupplyChangeAllowed >= block.timestamp,\n\t\t\t\"KING::constructor: minting can only begin after deployment\"\n\t\t);\n\n\t\tbalances[msg.sender] = totalSupply;\n\t\temit Transfer(address(0), msg.sender, totalSupply);\n\n\t\tsupplyChangeAllowedAfter = _firstSupplyChangeAllowed;\n\t\tsupplyManager = _supplyManager;\n\t\temit SupplyManagerChanged(address(0), _supplyManager);\n\n\t\tmetadataManager = _metadataManager;\n\t\temit MetadataManagerChanged(address(0), metadataManager);\n\t}\n\n\t/**\n\t * @notice Change the supplyManager address\n\t * @param newSupplyManager The address of the new supply manager\n\t * @return true if successful\n\t */\n\tfunction setSupplyManager(address newSupplyManager) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setSupplyManager: only SM can change SM\");\n\t\temit SupplyManagerChanged(supplyManager, newSupplyManager);\n\t\tsupplyManager = newSupplyManager;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Change the metadataManager address\n\t * @param newMetadataManager The address of the new metadata manager\n\t * @return true if successful\n\t */\n\tfunction setMetadataManager(address newMetadataManager) external returns (bool) {\n\t\trequire(msg.sender == metadataManager, \"KING::setMetadataManager: only MM can change MM\");\n\t\temit MetadataManagerChanged(metadataManager, newMetadataManager);\n\t\tmetadataManager = newMetadataManager;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Mint new tokens\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to be minted\n\t * @return Boolean indicating success of mint\n\t */\n\tfunction mint(address dst, uint256 amount) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::mint: only the supplyManager can mint\");\n\t\trequire(dst != address(0), \"KING::mint: cannot transfer to the zero address\");\n\t\trequire(amount <= (totalSupply * (mintCap)) / (1000000), \"KING::mint: exceeded mint cap\");\n\t\trequire(block.timestamp >= supplyChangeAllowedAfter, \"KING::mint: minting not allowed yet\");\n\n\t\t// update the next supply change allowed timestamp\n\t\tsupplyChangeAllowedAfter = block.timestamp + supplyChangeWaitingPeriod;\n\n\t\t// mint the amount\n\t\t_mint(dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Burn tokens\n\t * @param src The account that will burn tokens\n\t * @param amount The number of tokens to be burned\n\t * @return Boolean indicating success of burn\n\t */\n\tfunction burn(address src, uint256 amount) external returns (bool) {\n\t\taddress spender = msg.sender;\n\t\trequire(spender == supplyManager, \"KING::burn: only the supplyManager can burn\");\n\t\trequire(src != address(0), \"KING::burn: cannot transfer from the zero address\");\n\t\trequire(block.timestamp >= supplyChangeAllowedAfter, \"KING::burn: burning not allowed yet\");\n\n\t\tuint256 spenderAllowance = allowances[src][spender];\n\t\t// check allowance and reduce by amount\n\t\tif (spender != src && spenderAllowance != type(uint256).max) {\n\t\t\tuint256 newAllowance = spenderAllowance.sub(amount, \"KING::burn: burn amount exceeds allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t// update the next supply change allowed timestamp\n\t\tsupplyChangeAllowedAfter = block.timestamp + supplyChangeWaitingPeriod;\n\n\t\t// burn the amount\n\t\t_burn(src, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Set the maximum amount of tokens that can be minted at once\n\t * @param newCap The new mint cap in bips (10,000 bips = 1% of totalSupply)\n\t * @return true if successful\n\t */\n\tfunction setMintCap(uint16 newCap) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setMintCap: only SM can change mint cap\");\n\t\temit MintCapChanged(mintCap, newCap);\n\t\tmintCap = newCap;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Set the minimum time between supply changes\n\t * @param period The new supply change waiting period\n\t * @return true if succssful\n\t */\n\tfunction setSupplyChangeWaitingPeriod(uint32 period) external returns (bool) {\n\t\trequire(msg.sender == supplyManager, \"KING::setSupplyChangeWaitingPeriod: only SM can change waiting period\");\n\t\trequire(\n\t\t\tperiod >= supplyChangeWaitingPeriodMinimum,\n\t\t\t\"KING::setSupplyChangeWaitingPeriod: waiting period must be > minimum\"\n\t\t);\n\t\temit SupplyChangeWaitingPeriodChanged(supplyChangeWaitingPeriod, period);\n\t\tsupplyChangeWaitingPeriod = period;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Update the token name and symbol\n\t * @param tokenName The new name for the token\n\t * @param tokenSymbol The new symbol for the token\n\t * @return true if successful\n\t */\n\tfunction updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external returns (bool) {\n\t\trequire(msg.sender == metadataManager, \"KING::updateTokenMeta: only MM can update token metadata\");\n\t\tname = tokenName;\n\t\tsymbol = tokenSymbol;\n\t\temit TokenMetaUpdated(name, symbol);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n\t * @param account The address of the account holding the funds\n\t * @param spender The address of the account spending the funds\n\t * @return The number of tokens approved\n\t */\n\tfunction allowance(address account, address spender) external view override returns (uint256) {\n\t\treturn allowances[account][spender];\n\t}\n\n\t/**\n\t * @notice Approve `spender` to transfer up to `amount` from `src`\n\t * @dev This will overwrite the approval amount for `spender`\n\t * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\t * It is recommended to use increaseAllowance and decreaseAllowance instead\n\t * @param spender The address of the account which may transfer tokens\n\t * @param amount The number of tokens that are approved (2^256-1 means infinite)\n\t * @return Whether or not the approval succeeded\n\t */\n\tfunction approve(address spender, uint256 amount) external override returns (bool) {\n\t\t_approve(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Increase the allowance by a given amount\n\t * @param spender Spender's address\n\t * @param addedValue Amount of increase in allowance\n\t * @return True if successful\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n\t\t_increaseAllowance(msg.sender, spender, addedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Decrease the allowance by a given amount\n\t * @param spender Spender's address\n\t * @param subtractedValue Amount of decrease in allowance\n\t * @return True if successful\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n\t\t_decreaseAllowance(msg.sender, spender, subtractedValue);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Triggers an approval from owner to spender\n\t * @param owner The address to approve from\n\t * @param spender The address to be approved\n\t * @param value The number of tokens that are approved (2^256-1 means infinite)\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(deadline >= block.timestamp, \"KING::permit: signature expired\");\n\n\t\tbytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n\t\t_validateSignedData(owner, encodeData, v, r, s);\n\n\t\t_approve(owner, spender, value);\n\t}\n\n\t/**\n\t * @notice Get the number of tokens held by the `account`\n\t * @param account The address of the account to get the balance of\n\t * @return The number of tokens held\n\t */\n\tfunction balanceOf(address account) external view override returns (uint256) {\n\t\treturn balances[account];\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transfer(address dst, uint256 amount) external override returns (bool) {\n\t\t_transferTokens(msg.sender, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `src` to `dst`\n\t * @param src The address of the source account\n\t * @param dst The address of the destination account\n\t * @param amount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transferFrom(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 amount\n\t) external override returns (bool) {\n\t\taddress spender = msg.sender;\n\t\tuint256 spenderAllowance = allowances[src][spender];\n\n\t\tif (spender != src && spenderAllowance != type(uint256).max) {\n\t\t\tuint256 newAllowance = spenderAllowance.sub(amount, \"KING::transferFrom: transfer amount exceeds allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t_transferTokens(src, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer tokens with a signed authorization\n\t * @param from Payer's address (Authorizer)\n\t * @param to Payee's address\n\t * @param value Amount to be transferred\n\t * @param validAfter The time after which this is valid (unix time)\n\t * @param validBefore The time before which this is valid (unix time)\n\t * @param nonce Unique nonce\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(block.timestamp > validAfter, \"KING::transferWithAuth: auth not yet valid\");\n\t\trequire(block.timestamp < validBefore, \"KING::transferWithAuth: auth expired\");\n\t\trequire(!authorizationState[from][nonce], \"KING::transferWithAuth: auth already used\");\n\n\t\tbytes32 encodeData =\n\t\t\tkeccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n\t\t_validateSignedData(from, encodeData, v, r, s);\n\n\t\tauthorizationState[from][nonce] = true;\n\t\temit AuthorizationUsed(from, nonce);\n\n\t\t_transferTokens(from, to, value);\n\t}\n\n\t/**\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t * @dev This has an additional check to ensure that the payee's address matches\n\t * the caller of this function to prevent front-running attacks.\n\t * @param from Payer's address (Authorizer)\n\t * @param to Payee's address\n\t * @param value Amount to be transferred\n\t * @param validAfter The time after which this is valid (unix time)\n\t * @param validBefore The time before which this is valid (unix time)\n\t * @param nonce Unique nonce\n\t * @param v v of the signature\n\t * @param r r of the signature\n\t * @param s s of the signature\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(to == msg.sender, \"KING::receiveWithAuth: caller must be the payee\");\n\t\trequire(block.timestamp > validAfter, \"KING::receiveWithAuth: auth not yet valid\");\n\t\trequire(block.timestamp < validBefore, \"KING::receiveWithAuth: auth expired\");\n\t\trequire(!authorizationState[from][nonce], \"KING::receiveWithAuth: auth already used\");\n\n\t\tbytes32 encodeData =\n\t\t\tkeccak256(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n\t\t_validateSignedData(from, encodeData, v, r, s);\n\n\t\tauthorizationState[from][nonce] = true;\n\t\temit AuthorizationUsed(from, nonce);\n\n\t\t_transferTokens(from, to, value);\n\t}\n\n\t/**\n\t * @notice EIP-712 Domain separator\n\t * @return Separator\n\t */\n\tfunction getDomainSeparator() public view returns (bytes32) {\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), VERSION_HASH, _getChainId(), address(this)));\n\t}\n\n\t/**\n\t * @notice Recovers address from signed data and validates the signature\n\t * @param signer Address that signed the data\n\t * @param encodeData Data signed by the address\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction _validateSignedData(\n\t\taddress signer,\n\t\tbytes32 encodeData,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal view {\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData));\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n\n\t\t// Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == signer, \"KING::validateSig: invalid signature\");\n\t}\n\n\t/**\n\t * @notice Approval implementation\n\t * @param owner The address of the account which owns tokens\n\t * @param spender The address of the account which may transfer tokens\n\t * @param amount The number of tokens that are approved (2^256-1 means infinite)\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(owner != address(0), \"KING::_approve: approve from the zero address\");\n\t\trequire(spender != address(0), \"KING::_approve: approve to the zero address\");\n\t\tallowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction _increaseAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 addedValue\n\t) internal {\n\t\t_approve(owner, spender, allowances[owner][spender] + addedValue);\n\t}\n\n\tfunction _decreaseAllowance(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 subtractedValue\n\t) internal {\n\t\t_approve(\n\t\t\towner,\n\t\t\tspender,\n\t\t\tallowances[owner][spender].sub(subtractedValue, \"KING::_decreaseAllowance: decreased allowance below zero\")\n\t\t);\n\t}\n\n\t/**\n\t * @notice Transfer implementation\n\t * @param from The address of the account which owns tokens\n\t * @param to The address of the account which is receiving tokens\n\t * @param value The number of tokens that are being transferred\n\t */\n\tfunction _transferTokens(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\trequire(to != address(0), \"KING::_transferTokens: cannot transfer to the zero address\");\n\n\t\tbalances[from] = balances[from].sub(value, \"KING::_transferTokens: transfer exceeds from balance\");\n\t\tbalances[to] = balances[to] + value;\n\t\temit Transfer(from, to, value);\n\t}\n\n\t/**\n\t * @notice Mint implementation\n\t * @param to The address of the account which is receiving tokens\n\t * @param value The number of tokens that are being minted\n\t */\n\tfunction _mint(address to, uint256 value) internal {\n\t\ttotalSupply = totalSupply + value;\n\t\tbalances[to] = balances[to] + value;\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\t/**\n\t * @notice Burn implementation\n\t * @param from The address of the account which owns tokens\n\t * @param value The number of tokens that are being burned\n\t */\n\tfunction _burn(address from, uint256 value) internal {\n\t\tbalances[from] = balances[from].sub(value, \"KING::_burn: burn amount exceeds from balance\");\n\t\ttotalSupply = totalSupply.sub(value, \"KING::_burn: burn amount exceeds total supply\");\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\t/**\n\t * @notice Current id of the chain where this contract is deployed\n\t * @return Chain id\n\t */\n\tfunction _getChainId() internal view returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Greeter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.1;\n\nimport \"hardhat/console.sol\";\n\ncontract Greeter {\n\tstring greeting;\n\n\tconstructor(string memory _greeting) {\n\t\tconsole.log(\"Deploying a Greeter with greeting:\", _greeting);\n\t\tgreeting = _greeting;\n\t}\n\n\tfunction greet() public view returns (string memory) {\n\t\treturn greeting;\n\t}\n\n\tfunction setGreeting(string memory _greeting) public {\n\t\tconsole.log(\"Changing greeting from '%s' to '%s'\", greeting, _greeting);\n\t\tgreeting = _greeting;\n\t}\n}\n"
    },
    "contracts/testing/TestCollateralizedEther.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"../tokens/CollateralizedEther.sol\";\n\ncontract TestCollateralizedEther is CollateralizedEther {\n\tconstructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n}\n"
    },
    "contracts/Crown.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\nimport \"./libraries/diamond/LibDiamond.sol\";\nimport \"./libraries/diamond/LibOwnership.sol\";\nimport \"./interfaces/diamond/IDiamondLoupe.sol\";\nimport \"./interfaces/diamond/IDiamondCut.sol\";\nimport \"./interfaces/access/IERC173.sol\";\nimport \"./interfaces/introspection/IERC165.sol\";\n\ncontract Crown {\n\t// more arguments are added to this struct\n\t// this avoids stack too deep errors\n\tstruct CrownArgs {\n\t\taddress king;\n\t}\n\n\tconstructor(IDiamondCut.FacetCut[] memory _diamondCut, CrownArgs memory _args) payable {\n\t\tLibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\n\t\tLibOwnership.setContractOwner(_args.king);\n\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n\t\t// adding ERC165 data\n\t\tds.supportedInterfaces[type(IERC165).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\t}\n\n\t// Find facet for function that is called and execute the\n\t// function if a facet is found and return any value.\n\tfallback() external payable {\n\t\tLibDiamondStorage.DiamondStorage storage ds;\n\t\tbytes32 position = LibDiamondStorage.DIAMOND_STORAGE_POSITION;\n\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\n\t\taddress facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n\t\trequire(facet != address(0), \"Diamond: Function does not exist\");\n\n\t\tassembly {\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(0, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(0, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n\n\treceive() external payable {}\n}\n"
    },
    "contracts/libraries/diamond/LibDiamond.sol": {
      "content": "/*\n\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/********************************************************************\\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535 *\n/********************************************************************/\n\nimport \"./LibDiamondStorage.sol\";\nimport \"../../interfaces/diamond/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n\t// Internal function version of diamondCut.\n\t// Like normal proxies you can also execute a function at the time of an upgrade.\n\tfunction diamondCut(\n\t\tIDiamondCut.FacetCut[] memory _diamondCut,\n\t\taddress _init,\n\t\tbytes memory _calldata\n\t) internal {\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n\t\t\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n\t\t\tif (action == IDiamondCut.FacetCutAction.Add) {\n\t\t\t\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\n\t\t\t\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\n\t\t\t\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n\t\t\t} else {\n\t\t\t\trevert(\"LibDiamondCut: Incorrect FacetCutAction\");\n\t\t\t}\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tinitializeDiamondCut(_init, _calldata);\n\t}\n\n\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\t// uint16 selectorCount = uint16(diamondStorage().selectors.length);\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\tenforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n\t\t\tds.facetAddresses.push(_facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n\t\t\tds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n\t\t\tds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n\t\tuint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n\t\t// add new facet address if it does not exist\n\t\tif (selectorPosition == 0) {\n\t\t\tenforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n\t\t\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n\t\t\tds.facetAddresses.push(_facetAddress);\n\t\t}\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\trequire(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n\t\t\tremoveFunction(oldFacetAddress, selector);\n\t\t\t// add function\n\t\t\tds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n\t\t\tds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n\t\t\tselectorPosition++;\n\t\t}\n\t}\n\n\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n\t\trequire(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\t// if function does not exist then do nothing and return\n\t\trequire(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n\t\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n\t\t\tbytes4 selector = _functionSelectors[selectorIndex];\n\t\t\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n\t\t\tremoveFunction(oldFacetAddress, selector);\n\t\t}\n\t}\n\n\tfunction removeFunction(address _facetAddress, bytes4 _selector) internal {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\trequire(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\t\t// an immutable function is a function defined directly in a diamond\n\t\trequire(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n\t\t// replace selector with last selector, then delete last selector\n\t\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n\t\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n\t\t// if not the same then replace _selector with lastSelector\n\t\tif (selectorPosition != lastSelectorPosition) {\n\t\t\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n\t\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n\t\t\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\n\t\t}\n\t\t// delete the last selector\n\t\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n\t\tdelete ds.selectorToFacetAndPosition[_selector];\n\n\t\t// if no more selectors for facet address then delete the facet address\n\t\tif (lastSelectorPosition == 0) {\n\t\t\t// replace facet address with last facet address and delete last facet address\n\t\t\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n\t\t\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t\tif (facetAddressPosition != lastFacetAddressPosition) {\n\t\t\t\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n\t\t\t\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n\t\t\t\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\n\t\t\t}\n\t\t\tds.facetAddresses.pop();\n\t\t\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n\t\t}\n\t}\n\n\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\n\t\tif (_init == address(0)) {\n\t\t\trequire(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n\t\t} else {\n\t\t\trequire(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n\t\t\tif (_init != address(this)) {\n\t\t\t\tenforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n\t\t\t}\n\t\t\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\n\t\t\tif (!success) {\n\t\t\t\tif (error.length > 0) {\n\t\t\t\t\t// bubble up the error\n\t\t\t\t\trevert(string(error));\n\t\t\t\t} else {\n\t\t\t\t\trevert(\"LibDiamondCut: _init function reverted\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n\t\tuint256 contractSize;\n\t\tassembly {\n\t\t\tcontractSize := extcodesize(_contract)\n\t\t}\n\t\trequire(contractSize > 0, _errorMessage);\n\t}\n}\n"
    },
    "contracts/libraries/diamond/LibOwnership.sol": {
      "content": "/*\n\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/********************************************************************\\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535 *\n/********************************************************************/\n\nimport \"./LibDiamondStorage.sol\";\n\nlibrary LibOwnership {\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tfunction setContractOwner(address _newOwner) internal {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n\t\taddress previousOwner = ds.contractOwner;\n\t\trequire(previousOwner != _newOwner, \"Previous owner and new owner must be different\");\n\n\t\tds.contractOwner = _newOwner;\n\n\t\temit OwnershipTransferred(previousOwner, _newOwner);\n\t}\n\n\tfunction contractOwner() internal view returns (address contractOwner_) {\n\t\tcontractOwner_ = LibDiamondStorage.diamondStorage().contractOwner;\n\t}\n\n\tfunction enforceIsContractOwner() internal view {\n\t\trequire(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n\t}\n\n\t/*\n\t * Helpful modifier, Ownable-style\n\t */\n\tmodifier onlyOwner {\n\t\trequire(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n\t\t_;\n\t}\n}\n"
    },
    "contracts/interfaces/diamond/IDiamondLoupe.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n/**\n * A loupe is a small magnifying glass used to look at diamonds.\n */\ninterface IDiamondLoupe {\n\t/// These functions are expected to be called frequently by off-chain code.\n\t/// (and almost never by on-chain code)\n\tstruct Facet {\n\t\taddress facetAddress;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Gets all facet addresses and their four byte function selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view returns (Facet[] memory facets_);\n\n\t/// @notice Gets all the function selectors supported by a specific facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view returns (address[] memory facetAddresses_);\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/diamond/IDiamondCut.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n/**\n * A cut is a powerful cutter used to alter diamonds.\n */\ninterface IDiamondCut {\n\tenum FacetCutAction { Add, Replace, Remove }\n\t// Add=0, Replace=1, Remove=2\n\n\tstruct FacetCut {\n\t\taddress facetAddress;\n\t\tFacetCutAction action;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(\n\t\tFacetCut[] calldata _diamondCut,\n\t\taddress _init,\n\t\tbytes calldata _calldata\n\t) external;\n\n\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n\t/// @dev This emits when ownership of a contract changes.\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/// @notice Get the address of the owner\n\t/// @return owner_ The address of the owner.\n\tfunction owner() external view returns (address owner_);\n\n\t/// @notice Set the address of the new owner of the contract\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\n\t/// @param _newOwner The address of the new owner of the contract\n\tfunction transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/diamond/LibDiamondStorage.sol": {
      "content": "/*\n\n\tCopyright 2020 Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nlibrary LibDiamondStorage {\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n\tstruct FacetAddressAndPosition {\n\t\taddress facetAddress;\n\t\tuint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n\t}\n\n\tstruct FacetFunctionSelectors {\n\t\tbytes4[] functionSelectors;\n\t\tuint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n\t}\n\n\tstruct DiamondStorage {\n\t\t// maps function selector to the facet address and\n\t\t// the position of the selector in the facetFunctionSelectors.selectors array\n\t\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n\t\t// maps facet addresses to function selectors\n\t\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n\t\t// facet addresses\n\t\taddress[] facetAddresses;\n\t\t// Used to query if a contract implements an interface.\n\t\t// Used to implement ERC-165.\n\t\tmapping(bytes4 => bool) supportedInterfaces;\n\t\t// owner of the contract\n\t\taddress contractOwner;\n\t}\n\n\tfunction diamondStorage() internal pure returns (DiamondStorage storage ds) {\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\t}\n}\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* Contributors: [ lepidotteri, ]\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../libraries/diamond/LibDiamondStorage.sol\";\nimport \"../interfaces/diamond/IDiamondCut.sol\";\nimport \"../interfaces/diamond/IDiamondLoupe.sol\";\nimport \"../interfaces/introspection/IERC165.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n\t/// @notice Gets all facets and their selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view override returns (Facet[] memory facets_) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tuint256 numFacets = ds.facetAddresses.length;\n\t\tfacets_ = new Facet[](numFacets);\n\t\tfor (uint256 i; i < numFacets; i++) {\n\t\t\taddress facetAddress_ = ds.facetAddresses[i];\n\t\t\tfacets_[i].facetAddress = facetAddress_;\n\t\t\tfacets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n\t\t}\n\t}\n\n\t/// @notice Gets all the function selectors provided by a facet.\n\t/// @param _facet The facet address.\n\t/// @return facetFunctionSelectors_\n\tfunction facetFunctionSelectors(address _facet)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (bytes4[] memory facetFunctionSelectors_)\n\t{\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tfacetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n\t}\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view override returns (address[] memory facetAddresses_) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tfacetAddresses_ = ds.facetAddresses;\n\t}\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\tfacetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n\t}\n\n\t// This implements ERC-165.\n\tfunction supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n\t\tLibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\t\treturn ds.supportedInterfaces[_interfaceId];\n\t}\n}\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* Contributors: [ lepidotteri, ]\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../libraries/diamond/LibDiamond.sol\";\nimport \"../libraries/diamond/LibOwnership.sol\";\nimport \"../interfaces/diamond/IDiamondCut.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n\t/// @notice Add/replace/remove any number of functions and optionally execute a function, with DELEGATECALL\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _callData A contract call with function selector and arguments is executed, with DELEGATECALL, at _init\n\tfunction diamondCut(\n\t\tFacetCut[] calldata _diamondCut,\n\t\taddress _init,\n\t\tbytes calldata _callData\n\t) external override {\n\t\tLibOwnership.enforceIsContractOwner();\n\t\tLibDiamond.diamondCut(_diamondCut, _init, _callData);\n\t}\n}\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport \"../libraries/diamond/LibOwnership.sol\";\nimport \"../interfaces/access/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n\tfunction transferOwnership(address _newOwner) external override {\n\t\tLibOwnership.enforceIsContractOwner();\n\t\tLibOwnership.setContractOwner(_newOwner);\n\t}\n\n\tfunction owner() external view override returns (address owner_) {\n\t\towner_ = LibOwnership.contractOwner();\n\t}\n}\n"
    },
    "contracts/libraries/diamond/LibCrownStorage.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport \"./LibDiamondStorage.sol\";\n\nlibrary LibCrownStorage {\n\tbytes32 constant CROWN_STORAGE_POSITION = keccak256(\"dev.kingmaker.crown.storage\");\n\t//\n\t// TODO: everything below this point is a placeholder\n\t//\n\tstruct Checkpoint {\n\t\tuint256 timestamp;\n\t\tuint256 amount;\n\t}\n\n\tstruct Stake {\n\t\tuint256 timestamp;\n\t\tuint256 amount;\n\t\tuint256 expiryTimestamp;\n\t\taddress delegatedTo;\n\t}\n\n\tstruct Storage {\n\t\tbool initialized;\n\t\t// mapping of user address to history of Stake objects\n\t\t// every user action creates a new object in the history\n\t\tmapping(address => Stake[]) userStakeHistory;\n\t\t// array of bond staked Checkpoint\n\t\t// deposits/withdrawals create a new object in the history (max one per block)\n\t\tCheckpoint[] bondStakedHistory;\n\t\t// mapping of user address to history of delegated power\n\t\t// every delegate/stopDelegate call create a new checkpoint (max one per block)\n\t\tmapping(address => Checkpoint[]) delegatedPowerHistory;\n\n\t\t//IERC20 bond;\n\t\t//IRewards rewards;\n\t}\n\n\tfunction barnStorage() internal pure returns (Storage storage ds) {\n\t\tbytes32 position = CROWN_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\t}\n}\n"
    },
    "contracts/facets/governance/CrownGovernanceFacet.sol": {
      "content": "/*\n\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ncontract CrownGovernanceFacet {\n\tfunction govern(string calldata name) external pure returns (string memory) {\n\t\treturn string(abi.encodePacked(\"Greetings, \", name));\n\t}\n}\n"
    },
    "contracts/mock/Test1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Test1Facet {\n\tevent TestEvent(address something);\n\n\tfunction test1Func1() external {}\n\n\tfunction test1Func2() external {}\n\n\tfunction test1Func3() external {}\n\n\tfunction test1Func4() external {}\n\n\tfunction test1Func5() external {}\n\n\tfunction test1Func6() external {}\n\n\tfunction test1Func7() external {}\n\n\tfunction test1Func8() external {}\n\n\tfunction test1Func9() external {}\n\n\tfunction test1Func10() external {}\n\n\tfunction test1Func11() external {}\n\n\tfunction test1Func12() external {}\n\n\tfunction test1Func13() external {}\n\n\tfunction test1Func14() external {}\n\n\tfunction test1Func15() external {}\n\n\tfunction test1Func16() external {}\n\n\tfunction test1Func17() external {}\n\n\tfunction test1Func18() external {}\n\n\tfunction test1Func19() external {}\n\n\tfunction test1Func20() external {}\n\n\tfunction supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/mock/Test2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ncontract Test1Facet {\n\tfunction test2Func1() external {}\n\n\tfunction test2Func2() external {}\n\n\tfunction test2Func3() external {}\n\n\tfunction test2Func4() external {}\n\n\tfunction test2Func5() external {}\n\n\tfunction test2Func6() external {}\n\n\tfunction test2Func7() external {}\n\n\tfunction test2Func8() external {}\n\n\tfunction test2Func9() external {}\n\n\tfunction test2Func10() external {}\n\n\tfunction test2Func11() external {}\n\n\tfunction test2Func12() external {}\n\n\tfunction test2Func13() external {}\n\n\tfunction test2Func14() external {}\n\n\tfunction test2Func15() external {}\n\n\tfunction test2Func16() external {}\n\n\tfunction test2Func17() external {}\n\n\tfunction test2Func18() external {}\n\n\tfunction test2Func19() external {}\n\n\tfunction test2Func20() external {}\n}\n"
    },
    "contracts/testing/InvokableCatcher.sol": {
      "content": "/*\n\n    Copyright 2020 Kollateral LLC\n    Copyright 2020-2021 ARM Finance LLC\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\ncontract InvokableCatcher {\n\tconstructor() {}\n\n\tevent InvokeCatch(address sender, bytes32 data);\n\n\tfunction invokeCatch(bytes32 data) external {\n\t\temit InvokeCatch(msg.sender, data);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}